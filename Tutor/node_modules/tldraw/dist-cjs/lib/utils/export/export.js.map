{
  "version": 3,
  "sources": ["../../../../src/lib/utils/export/export.ts"],
  "sourcesContent": ["import {\n\tEditor,\n\tPngHelpers,\n\tTLShapeId,\n\tTLSvgOptions,\n\tdebugFlags,\n\texhaustiveSwitchError,\n} from '@tldraw/editor'\nimport { clampToBrowserMaxCanvasSize } from '../../shapes/shared/getBrowserCanvasMaxSize'\n\n/** @public */\nexport async function getSvgAsImage(\n\tsvg: SVGElement,\n\tisSafari: boolean,\n\toptions: {\n\t\ttype: 'png' | 'jpeg' | 'webp'\n\t\tquality: number\n\t\tscale: number\n\t}\n) {\n\tconst { type, quality, scale } = options\n\n\tconst width = +svg.getAttribute('width')!\n\tconst height = +svg.getAttribute('height')!\n\tlet [clampedWidth, clampedHeight] = await clampToBrowserMaxCanvasSize(\n\t\twidth * scale,\n\t\theight * scale\n\t)\n\tclampedWidth = Math.floor(clampedWidth)\n\tclampedHeight = Math.floor(clampedHeight)\n\tconst effectiveScale = clampedWidth / width\n\n\tconst svgString = await getSvgAsString(svg)\n\tconst svgUrl = URL.createObjectURL(new Blob([svgString], { type: 'image/svg+xml' }))\n\n\tconst canvas = await new Promise<HTMLCanvasElement | null>((resolve) => {\n\t\tconst image = new Image()\n\t\timage.crossOrigin = 'anonymous'\n\n\t\timage.onload = async () => {\n\t\t\t// safari will fire `onLoad` before the fonts in the SVG are\n\t\t\t// actually loaded. just waiting around a while is brittle, but\n\t\t\t// there doesn't seem to be any better solution for now :( see\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=219770\n\t\t\tif (isSafari) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 250))\n\t\t\t}\n\n\t\t\tconst canvas = document.createElement('canvas') as HTMLCanvasElement\n\t\t\tconst ctx = canvas.getContext('2d')!\n\n\t\t\tcanvas.width = clampedWidth\n\t\t\tcanvas.height = clampedHeight\n\n\t\t\tctx.imageSmoothingEnabled = true\n\t\t\tctx.imageSmoothingQuality = 'high'\n\t\t\tctx.drawImage(image, 0, 0, clampedWidth, clampedHeight)\n\n\t\t\tURL.revokeObjectURL(svgUrl)\n\n\t\t\tresolve(canvas)\n\t\t}\n\n\t\timage.onerror = () => {\n\t\t\tresolve(null)\n\t\t}\n\n\t\timage.src = svgUrl\n\t})\n\n\tif (!canvas) return null\n\n\tconst blob = await new Promise<Blob | null>((resolve) =>\n\t\tcanvas.toBlob(\n\t\t\t(blob) => {\n\t\t\t\tif (!blob || debugFlags.throwToBlob.get()) {\n\t\t\t\t\tresolve(null)\n\t\t\t\t}\n\t\t\t\tresolve(blob)\n\t\t\t},\n\t\t\t'image/' + type,\n\t\t\tquality\n\t\t)\n\t)\n\n\tif (!blob) return null\n\n\tif (type === 'png') {\n\t\tconst view = new DataView(await blob.arrayBuffer())\n\t\treturn PngHelpers.setPhysChunk(view, effectiveScale, {\n\t\t\ttype: 'image/' + type,\n\t\t})\n\t} else {\n\t\treturn blob\n\t}\n}\n\n/** @public */\nexport async function getSvgAsString(svg: SVGElement) {\n\tconst clone = svg.cloneNode(true) as SVGGraphicsElement\n\n\tsvg.setAttribute('width', +svg.getAttribute('width')! + '')\n\tsvg.setAttribute('height', +svg.getAttribute('height')! + '')\n\n\tconst fileReader = new FileReader()\n\tconst imgs = Array.from(clone.querySelectorAll('image')) as SVGImageElement[]\n\n\tfor (const img of imgs) {\n\t\tconst src = img.getAttribute('xlink:href')\n\t\tif (src) {\n\t\t\tif (!src.startsWith('data:')) {\n\t\t\t\tconst blob = await (await fetch(src)).blob()\n\t\t\t\tconst base64 = await new Promise<string>((resolve, reject) => {\n\t\t\t\t\tfileReader.onload = () => resolve(fileReader.result as string)\n\t\t\t\t\tfileReader.onerror = () => reject(fileReader.error)\n\t\t\t\t\tfileReader.readAsDataURL(blob)\n\t\t\t\t})\n\t\t\t\timg.setAttribute('xlink:href', base64)\n\t\t\t}\n\t\t}\n\t}\n\n\tconst out = new XMLSerializer()\n\t\t.serializeToString(clone)\n\t\t.replaceAll('&#10;      ', '')\n\t\t.replaceAll(/((\\s|\")[0-9]*\\.[0-9]{2})([0-9]*)(\\b|\"|\\))/g, '$1')\n\n\treturn out\n}\n\nasync function getSvg(editor: Editor, ids: TLShapeId[], opts: Partial<TLSvgOptions>) {\n\tconst svg = await editor.getSvg(ids?.length ? ids : [...editor.getCurrentPageShapeIds()], {\n\t\tscale: 1,\n\t\tbackground: editor.getInstanceState().exportBackground,\n\t\t...opts,\n\t})\n\tif (!svg) {\n\t\tthrow new Error('Could not construct SVG.')\n\t}\n\treturn svg\n}\n\nexport async function exportToString(\n\teditor: Editor,\n\tids: TLShapeId[],\n\tformat: 'svg' | 'json',\n\topts = {} as Partial<TLSvgOptions>\n) {\n\tswitch (format) {\n\t\tcase 'svg': {\n\t\t\treturn getSvgAsString(await getSvg(editor, ids, opts))\n\t\t}\n\t\tcase 'json': {\n\t\t\tconst data = editor.getContentFromCurrentPage(ids)\n\t\t\treturn JSON.stringify(data)\n\t\t}\n\t\tdefault: {\n\t\t\texhaustiveSwitchError(format)\n\t\t}\n\t}\n}\n\n/**\n * Export the given shapes as a blob.\n * @param editor - The editor instance.\n * @param ids - The ids of the shapes to export.\n * @param format - The format to export as.\n * @param opts - Rendering options.\n * @returns A promise that resolves to a blob.\n * @public\n */\nexport async function exportToBlob({\n\teditor,\n\tids,\n\tformat,\n\topts = {} as Partial<TLSvgOptions>,\n}: {\n\teditor: Editor\n\tids: TLShapeId[]\n\tformat: 'svg' | 'png' | 'jpeg' | 'webp' | 'json'\n\topts?: Partial<TLSvgOptions>\n}): Promise<Blob> {\n\tswitch (format) {\n\t\tcase 'svg':\n\t\t\treturn new Blob([await exportToString(editor, ids, 'svg', opts)], { type: 'text/plain' })\n\t\tcase 'json':\n\t\t\treturn new Blob([await exportToString(editor, ids, 'json', opts)], { type: 'text/plain' })\n\t\tcase 'jpeg':\n\t\tcase 'png':\n\t\tcase 'webp': {\n\t\t\tconst image = await getSvgAsImage(\n\t\t\t\tawait getSvg(editor, ids, opts),\n\t\t\t\teditor.environment.isSafari,\n\t\t\t\t{\n\t\t\t\t\ttype: format,\n\t\t\t\t\tquality: 1,\n\t\t\t\t\tscale: 2,\n\t\t\t\t}\n\t\t\t)\n\t\t\tif (!image) {\n\t\t\t\tthrow new Error('Could not construct image.')\n\t\t\t}\n\t\t\treturn image\n\t\t}\n\t\tdefault: {\n\t\t\texhaustiveSwitchError(format)\n\t\t}\n\t}\n}\n\nconst mimeTypeByFormat = {\n\tjpeg: 'image/jpeg',\n\tpng: 'image/png',\n\twebp: 'image/webp',\n\tjson: 'text/plain',\n\tsvg: 'text/plain',\n}\n\nexport function exportToBlobPromise(\n\teditor: Editor,\n\tids: TLShapeId[],\n\tformat: 'svg' | 'png' | 'jpeg' | 'webp' | 'json',\n\topts = {} as Partial<TLSvgOptions>\n): { blobPromise: Promise<Blob>; mimeType: string } {\n\treturn {\n\t\tblobPromise: exportToBlob({ editor, ids, format, opts }),\n\t\tmimeType: mimeTypeByFormat[format],\n\t}\n}\n"],
  "mappings": "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",
  "names": ["resolve", "canvas", "blob"]
}
