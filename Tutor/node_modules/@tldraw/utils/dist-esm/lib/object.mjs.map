{
  "version": 3,
  "sources": ["../../src/lib/object.ts"],
  "sourcesContent": ["/** @internal */\nexport function hasOwnProperty(obj: object, key: string): boolean {\n\treturn Object.prototype.hasOwnProperty.call(obj, key)\n}\n\n/** @internal */\nexport function getOwnProperty<K extends string, V>(\n\tobj: Partial<Record<K, V>>,\n\tkey: K\n): V | undefined\n/** @internal */\nexport function getOwnProperty(obj: object, key: string): unknown\n/** @internal */\nexport function getOwnProperty(obj: object, key: string): unknown {\n\tif (!hasOwnProperty(obj, key)) {\n\t\treturn undefined\n\t}\n\t// @ts-expect-error we know the property exists\n\treturn obj[key]\n}\n\n/**\n * Deep copy function for TypeScript.\n *\n * @example\n *\n * ```ts\n * const A = deepCopy({ a: 1, b: { c: 2 } })\n * ```\n *\n * @param obj - Target value to be copied.\n * @public\n * @see Source - project, ts-deeply https://github.com/ykdr2017/ts-deepcopy\n * @see Code - pen https://codepen.io/erikvullings/pen/ejyBYg\n */\nexport function deepCopy<T = unknown>(obj: T): T {\n\tif (!obj) return obj\n\tif (Array.isArray(obj)) {\n\t\tconst arr: unknown[] = []\n\t\tconst length = obj.length\n\t\tfor (let i = 0; i < length; i++) arr.push(deepCopy(obj[i]))\n\t\treturn arr as unknown as T\n\t} else if (typeof obj === 'object') {\n\t\tconst keys = Object.keys(obj!)\n\t\tconst length = keys.length\n\t\tconst newObject: any = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst key = keys[i]\n\t\t\tnewObject[key] = deepCopy((obj as any)[key])\n\t\t}\n\t\treturn newObject\n\t}\n\treturn obj\n}\n\n/**\n * An alias for `Object.keys` that treats the object as a map and so preserves the type of the keys.\n *\n * @internal\n */\nexport function objectMapKeys<Key extends string>(object: {\n\treadonly [K in Key]: unknown\n}): Array<Key> {\n\treturn Object.keys(object) as Key[]\n}\n\n/**\n * An alias for `Object.values` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapValues<Key extends string, Value>(object: {\n\t[K in Key]: Value\n}): Array<Value> {\n\treturn Object.values(object) as Value[]\n}\n\n/**\n * An alias for `Object.entries` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapEntries<Key extends string, Value>(object: {\n\t[K in Key]: Value\n}): Array<[Key, Value]> {\n\treturn Object.entries(object) as [Key, Value][]\n}\n\n/**\n * An alias for `Object.fromEntries` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapFromEntries<Key extends string, Value>(\n\tentries: ReadonlyArray<readonly [Key, Value]>\n): { [K in Key]: Value } {\n\treturn Object.fromEntries(entries) as { [K in Key]: Value }\n}\n\n/**\n * Filters an object using a predicate function.\n * @returns a new object with only the entries that pass the predicate\n * @internal\n */\nexport function filterEntries<Key extends string, Value>(\n\tobject: { [K in Key]: Value },\n\tpredicate: (key: Key, value: Value) => boolean\n): { [K in Key]: Value } {\n\tconst result: { [K in Key]?: Value } = {}\n\tlet didChange = false\n\tfor (const [key, value] of objectMapEntries(object)) {\n\t\tif (predicate(key, value)) {\n\t\t\tresult[key] = value\n\t\t} else {\n\t\t\tdidChange = true\n\t\t}\n\t}\n\treturn didChange ? (result as { [K in Key]: Value }) : object\n}\n\n/**\n * Maps the values of one object map to another.\n * @returns a new object with the entries mapped\n * @internal\n */\nexport function mapObjectMapValues<Key extends string, ValueBefore, ValueAfter>(\n\tobject: { readonly [K in Key]: ValueBefore },\n\tmapper: (key: Key, value: ValueBefore) => ValueAfter\n): { [K in Key]: ValueAfter } {\n\tconst result = {} as { [K in Key]: ValueAfter }\n\tfor (const [key, value] of objectMapEntries(object)) {\n\t\tconst newValue = mapper(key, value)\n\t\tresult[key] = newValue\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function areObjectsShallowEqual<T extends Record<string, unknown>>(\n\tobj1: T,\n\tobj2: T\n): boolean {\n\tif (obj1 === obj2) return true\n\tconst keys1 = new Set(Object.keys(obj1))\n\tconst keys2 = new Set(Object.keys(obj2))\n\tif (keys1.size !== keys2.size) return false\n\tfor (const key of keys1) {\n\t\tif (!keys2.has(key)) return false\n\t\tif (!Object.is(obj1[key], obj2[key])) return false\n\t}\n\treturn true\n}\n"],
  "mappings": "AACO,SAAS,eAAe,KAAa,KAAsB;AACjE,SAAO,OAAO,UAAU,eAAe,KAAK,KAAK,GAAG;AACrD;AAUO,SAAS,eAAe,KAAa,KAAsB;AACjE,MAAI,CAAC,eAAe,KAAK,GAAG,GAAG;AAC9B,WAAO;AAAA,EACR;AAEA,SAAO,IAAI,GAAG;AACf;AAgBO,SAAS,SAAsB,KAAW;AAChD,MAAI,CAAC;AAAK,WAAO;AACjB,MAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,UAAM,MAAiB,CAAC;AACxB,UAAM,SAAS,IAAI;AACnB,aAAS,IAAI,GAAG,IAAI,QAAQ;AAAK,UAAI,KAAK,SAAS,IAAI,CAAC,CAAC,CAAC;AAC1D,WAAO;AAAA,EACR,WAAW,OAAO,QAAQ,UAAU;AACnC,UAAM,OAAO,OAAO,KAAK,GAAI;AAC7B,UAAM,SAAS,KAAK;AACpB,UAAM,YAAiB,CAAC;AACxB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,YAAM,MAAM,KAAK,CAAC;AAClB,gBAAU,GAAG,IAAI,SAAU,IAAY,GAAG,CAAC;AAAA,IAC5C;AACA,WAAO;AAAA,EACR;AACA,SAAO;AACR;AAOO,SAAS,cAAkC,QAEnC;AACd,SAAO,OAAO,KAAK,MAAM;AAC1B;AAQO,SAAS,gBAA2C,QAE1C;AAChB,SAAO,OAAO,OAAO,MAAM;AAC5B;AAQO,SAAS,iBAA4C,QAEpC;AACvB,SAAO,OAAO,QAAQ,MAAM;AAC7B;AAQO,SAAS,qBACf,SACwB;AACxB,SAAO,OAAO,YAAY,OAAO;AAClC;AAOO,SAAS,cACf,QACA,WACwB;AACxB,QAAM,SAAiC,CAAC;AACxC,MAAI,YAAY;AAChB,aAAW,CAAC,KAAK,KAAK,KAAK,iBAAiB,MAAM,GAAG;AACpD,QAAI,UAAU,KAAK,KAAK,GAAG;AAC1B,aAAO,GAAG,IAAI;AAAA,IACf,OAAO;AACN,kBAAY;AAAA,IACb;AAAA,EACD;AACA,SAAO,YAAa,SAAmC;AACxD;AAOO,SAAS,mBACf,QACA,QAC6B;AAC7B,QAAM,SAAS,CAAC;AAChB,aAAW,CAAC,KAAK,KAAK,KAAK,iBAAiB,MAAM,GAAG;AACpD,UAAM,WAAW,OAAO,KAAK,KAAK;AAClC,WAAO,GAAG,IAAI;AAAA,EACf;AACA,SAAO;AACR;AAGO,SAAS,uBACf,MACA,MACU;AACV,MAAI,SAAS;AAAM,WAAO;AAC1B,QAAM,QAAQ,IAAI,IAAI,OAAO,KAAK,IAAI,CAAC;AACvC,QAAM,QAAQ,IAAI,IAAI,OAAO,KAAK,IAAI,CAAC;AACvC,MAAI,MAAM,SAAS,MAAM;AAAM,WAAO;AACtC,aAAW,OAAO,OAAO;AACxB,QAAI,CAAC,MAAM,IAAI,GAAG;AAAG,aAAO;AAC5B,QAAI,CAAC,OAAO,GAAG,KAAK,GAAG,GAAG,KAAK,GAAG,CAAC;AAAG,aAAO;AAAA,EAC9C;AACA,SAAO;AACR;",
  "names": []
}
