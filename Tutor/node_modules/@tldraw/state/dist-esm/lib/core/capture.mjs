import { attach, detach, singleton } from "./helpers.mjs";
class CaptureStackFrame {
  constructor(below, child) {
    this.below = below;
    this.child = child;
  }
  offset = 0;
  numNewParents = 0;
  maybeRemoved;
}
const inst = singleton("capture", () => ({ stack: null }));
function unsafe__withoutCapture(fn) {
  const oldStack = inst.stack;
  inst.stack = null;
  try {
    return fn();
  } finally {
    inst.stack = oldStack;
  }
}
function startCapturingParents(child) {
  inst.stack = new CaptureStackFrame(inst.stack, child);
}
function stopCapturingParents() {
  const frame = inst.stack;
  inst.stack = frame.below;
  const didParentsChange = frame.numNewParents > 0 || frame.offset !== frame.child.parents.length;
  if (!didParentsChange) {
    return;
  }
  for (let i = frame.offset; i < frame.child.parents.length; i++) {
    const p = frame.child.parents[i];
    const parentWasRemoved = frame.child.parents.indexOf(p) >= frame.offset;
    if (parentWasRemoved) {
      detach(p, frame.child);
    }
  }
  frame.child.parents.length = frame.offset;
  frame.child.parentEpochs.length = frame.offset;
  if (inst.stack?.maybeRemoved) {
    for (let i = 0; i < inst.stack.maybeRemoved.length; i++) {
      const maybeRemovedParent = inst.stack.maybeRemoved[i];
      if (frame.child.parents.indexOf(maybeRemovedParent) === -1) {
        detach(maybeRemovedParent, frame.child);
      }
    }
  }
}
function maybeCaptureParent(p) {
  if (inst.stack) {
    const idx = inst.stack.child.parents.indexOf(p);
    if (idx < 0) {
      inst.stack.numNewParents++;
      if (inst.stack.child.isActivelyListening) {
        attach(p, inst.stack.child);
      }
    }
    if (idx < 0 || idx >= inst.stack.offset) {
      if (idx !== inst.stack.offset && idx > 0) {
        const maybeRemovedParent = inst.stack.child.parents[inst.stack.offset];
        if (!inst.stack.maybeRemoved) {
          inst.stack.maybeRemoved = [maybeRemovedParent];
        } else if (inst.stack.maybeRemoved.indexOf(maybeRemovedParent) === -1) {
          inst.stack.maybeRemoved.push(maybeRemovedParent);
        }
      }
      inst.stack.child.parents[inst.stack.offset] = p;
      inst.stack.child.parentEpochs[inst.stack.offset] = p.lastChangedEpoch;
      inst.stack.offset++;
    }
  }
}
function whyAmIRunning() {
  const child = inst.stack?.child;
  if (!child) {
    throw new Error("whyAmIRunning() called outside of a reactive context");
  }
  const changedParents = [];
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    if (parent.lastChangedEpoch > child.parentEpochs[i]) {
      changedParents.push(parent);
    }
  }
  if (changedParents.length === 0) {
    console.log(child.name, "is running but none of the parents changed");
  } else {
    console.log(child.name, "is running because:");
    for (const changedParent of changedParents) {
      console.log(
        "	",
        changedParent.name,
        "changed =>",
        changedParent.__unsafe__getWithoutCapture(true)
      );
    }
  }
}
export {
  maybeCaptureParent,
  startCapturingParents,
  stopCapturingParents,
  unsafe__withoutCapture,
  whyAmIRunning
};
//# sourceMappingURL=capture.mjs.map
