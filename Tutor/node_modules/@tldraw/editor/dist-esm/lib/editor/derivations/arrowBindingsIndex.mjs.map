{
  "version": 3,
  "sources": ["../../../../src/lib/editor/derivations/arrowBindingsIndex.ts"],
  "sourcesContent": ["import { Computed, RESET_VALUE, computed, isUninitialized } from '@tldraw/state'\nimport { TLArrowShape, TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { Editor } from '../Editor'\n\ntype TLArrowBindingsIndex = Record<\n\tTLShapeId,\n\tundefined | { arrowId: TLShapeId; handleId: 'start' | 'end' }[]\n>\n\nexport const arrowBindingsIndex = (editor: Editor): Computed<TLArrowBindingsIndex> => {\n\tconst { store } = editor\n\tconst shapeHistory = store.query.filterHistory('shape')\n\tconst arrowQuery = store.query.records('shape', () => ({ type: { eq: 'arrow' as const } }))\n\tfunction fromScratch() {\n\t\tconst allArrows = arrowQuery.get() as TLArrowShape[]\n\n\t\tconst bindings2Arrows: TLArrowBindingsIndex = {}\n\n\t\tfor (const arrow of allArrows) {\n\t\t\tconst { start, end } = arrow.props\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tconst arrows = bindings2Arrows[start.boundShapeId]\n\t\t\t\tif (arrows) arrows.push({ arrowId: arrow.id, handleId: 'start' })\n\t\t\t\telse bindings2Arrows[start.boundShapeId] = [{ arrowId: arrow.id, handleId: 'start' }]\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tconst arrows = bindings2Arrows[end.boundShapeId]\n\t\t\t\tif (arrows) arrows.push({ arrowId: arrow.id, handleId: 'end' })\n\t\t\t\telse bindings2Arrows[end.boundShapeId] = [{ arrowId: arrow.id, handleId: 'end' }]\n\t\t\t}\n\t\t}\n\n\t\treturn bindings2Arrows\n\t}\n\n\treturn computed<TLArrowBindingsIndex>('arrowBindingsIndex', (_lastValue, lastComputedEpoch) => {\n\t\tif (isUninitialized(_lastValue)) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tconst lastValue = _lastValue\n\n\t\tconst diff = shapeHistory.getDiffSince(lastComputedEpoch)\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tlet nextValue: TLArrowBindingsIndex | undefined = undefined\n\n\t\tfunction ensureNewArray(boundShapeId: TLShapeId) {\n\t\t\t// this will never happen\n\t\t\tif (!nextValue) {\n\t\t\t\tnextValue = { ...lastValue }\n\t\t\t}\n\t\t\tif (!nextValue[boundShapeId]) {\n\t\t\t\tnextValue[boundShapeId] = []\n\t\t\t} else if (nextValue[boundShapeId] === lastValue[boundShapeId]) {\n\t\t\t\tnextValue[boundShapeId] = [...nextValue[boundShapeId]!]\n\t\t\t}\n\t\t}\n\n\t\tfunction removingBinding(\n\t\t\tboundShapeId: TLShapeId,\n\t\t\tarrowId: TLShapeId,\n\t\t\thandleId: 'start' | 'end'\n\t\t) {\n\t\t\tensureNewArray(boundShapeId)\n\t\t\tnextValue![boundShapeId] = nextValue![boundShapeId]!.filter(\n\t\t\t\t(binding) => binding.arrowId !== arrowId || binding.handleId !== handleId\n\t\t\t)\n\t\t\tif (nextValue![boundShapeId]!.length === 0) {\n\t\t\t\tdelete nextValue![boundShapeId]\n\t\t\t}\n\t\t}\n\n\t\tfunction addBinding(boundShapeId: TLShapeId, arrowId: TLShapeId, handleId: 'start' | 'end') {\n\t\t\tensureNewArray(boundShapeId)\n\t\t\tnextValue![boundShapeId]!.push({ arrowId, handleId })\n\t\t}\n\n\t\tfor (const changes of diff) {\n\t\t\tfor (const newShape of Object.values(changes.added)) {\n\t\t\t\tif (editor.isShapeOfType<TLArrowShape>(newShape, 'arrow')) {\n\t\t\t\t\tconst { start, end } = newShape.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\taddBinding(start.boundShapeId, newShape.id, 'start')\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\taddBinding(end.boundShapeId, newShape.id, 'end')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const [prev, next] of Object.values(changes.updated) as [TLShape, TLShape][]) {\n\t\t\t\tif (\n\t\t\t\t\t!editor.isShapeOfType<TLArrowShape>(prev, 'arrow') ||\n\t\t\t\t\t!editor.isShapeOfType<TLArrowShape>(next, 'arrow')\n\t\t\t\t)\n\t\t\t\t\tcontinue\n\n\t\t\t\tfor (const handle of ['start', 'end'] as const) {\n\t\t\t\t\tconst prevTerminal = prev.props[handle]\n\t\t\t\t\tconst nextTerminal = next.props[handle]\n\n\t\t\t\t\tif (prevTerminal.type === 'binding' && nextTerminal.type === 'point') {\n\t\t\t\t\t\t// if the binding was removed\n\t\t\t\t\t\tremovingBinding(prevTerminal.boundShapeId, prev.id, handle)\n\t\t\t\t\t} else if (prevTerminal.type === 'point' && nextTerminal.type === 'binding') {\n\t\t\t\t\t\t// if the binding was added\n\t\t\t\t\t\taddBinding(nextTerminal.boundShapeId, next.id, handle)\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tprevTerminal.type === 'binding' &&\n\t\t\t\t\t\tnextTerminal.type === 'binding' &&\n\t\t\t\t\t\tprevTerminal.boundShapeId !== nextTerminal.boundShapeId\n\t\t\t\t\t) {\n\t\t\t\t\t\t// if the binding was changed\n\t\t\t\t\t\tremovingBinding(prevTerminal.boundShapeId, prev.id, handle)\n\t\t\t\t\t\taddBinding(nextTerminal.boundShapeId, next.id, handle)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const prev of Object.values(changes.removed)) {\n\t\t\t\tif (editor.isShapeOfType<TLArrowShape>(prev, 'arrow')) {\n\t\t\t\t\tconst { start, end } = prev.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\tremovingBinding(start.boundShapeId, prev.id, 'start')\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\tremovingBinding(end.boundShapeId, prev.id, 'end')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: add diff entries if we need them\n\t\treturn nextValue ?? lastValue\n\t})\n}\n"],
  "mappings": "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",
  "names": []
}
