import { Mat } from "../../../../primitives/Mat.mjs";
import { Vec } from "../../../../primitives/Vec.mjs";
import { Group2d } from "../../../../primitives/geometry/Group2d.mjs";
function getIsArrowStraight(shape) {
  return Math.abs(shape.props.bend) < 8;
}
function getBoundShapeInfoForTerminal(editor, terminal) {
  if (terminal.type === "point") {
    return;
  }
  const shape = editor.getShape(terminal.boundShapeId);
  const transform = editor.getShapePageTransform(shape);
  const geometry = editor.getShapeGeometry(shape);
  const outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices;
  return {
    shape,
    transform,
    isClosed: geometry.isClosed,
    isExact: terminal.isExact,
    didIntersect: false,
    outline
  };
}
function getArrowTerminalInArrowSpace(editor, arrowPageTransform, terminal, forceImprecise) {
  if (terminal.type === "point") {
    return Vec.From(terminal);
  }
  const boundShape = editor.getShape(terminal.boundShapeId);
  if (!boundShape) {
    return new Vec(0, 0);
  } else {
    const { point, size } = editor.getShapeGeometry(boundShape).bounds;
    const shapePoint = Vec.Add(
      point,
      Vec.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        terminal.isPrecise || forceImprecise ? terminal.normalizedAnchor : { x: 0.5, y: 0.5 },
        size
      )
    );
    const pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape), shapePoint);
    const arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint);
    return arrowPoint;
  }
}
function getArrowTerminalsInArrowSpace(editor, shape) {
  const arrowPageTransform = editor.getShapePageTransform(shape);
  let startBoundShapeId;
  let endBoundShapeId;
  if (shape.props.start.type === "binding" && shape.props.end.type === "binding") {
    startBoundShapeId = shape.props.start.boundShapeId;
    endBoundShapeId = shape.props.end.boundShapeId;
  }
  const boundShapeRelationships = getBoundShapeRelationships(
    editor,
    startBoundShapeId,
    endBoundShapeId
  );
  const start = getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    shape.props.start,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "start-contains-end"
  );
  const end = getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    shape.props.end,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "end-contains-start"
  );
  return { start, end };
}
const MIN_ARROW_LENGTH = 10;
const BOUND_ARROW_OFFSET = 10;
const LABEL_TO_ARROW_PADDING = 20;
const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
const STROKE_SIZES = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function getBoundShapeRelationships(editor, startShapeId, endShapeId) {
  if (!startShapeId || !endShapeId)
    return "safe";
  if (startShapeId === endShapeId)
    return "double-bound";
  const startBounds = editor.getShapePageBounds(startShapeId);
  const endBounds = editor.getShapePageBounds(endShapeId);
  if (startBounds && endBounds) {
    if (startBounds.contains(endBounds))
      return "start-contains-end";
    if (endBounds.contains(startBounds))
      return "end-contains-start";
  }
  return "safe";
}
export {
  BOUND_ARROW_OFFSET,
  LABEL_TO_ARROW_PADDING,
  MIN_ARROW_LENGTH,
  STROKE_SIZES,
  WAY_TOO_BIG_ARROW_BEND_FACTOR,
  getArrowTerminalsInArrowSpace,
  getBoundShapeInfoForTerminal,
  getBoundShapeRelationships,
  getIsArrowStraight
};
//# sourceMappingURL=shared.mjs.map
