{
  "version": 3,
  "sources": ["../../../../../../src/lib/editor/shapes/shared/arrow/shared.ts"],
  "sourcesContent": ["import { TLArrowShape, TLArrowShapeTerminal, TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { Mat } from '../../../../primitives/Mat'\nimport { Vec } from '../../../../primitives/Vec'\nimport { Group2d } from '../../../../primitives/geometry/Group2d'\nimport { Editor } from '../../../Editor'\n\nexport function getIsArrowStraight(shape: TLArrowShape) {\n\treturn Math.abs(shape.props.bend) < 8 // snap to +-8px\n}\n\nexport type BoundShapeInfo<T extends TLShape = TLShape> = {\n\tshape: T\n\tdidIntersect: boolean\n\tisExact: boolean\n\tisClosed: boolean\n\ttransform: Mat\n\toutline: Vec[]\n}\n\nexport function getBoundShapeInfoForTerminal(\n\teditor: Editor,\n\tterminal: TLArrowShapeTerminal\n): BoundShapeInfo | undefined {\n\tif (terminal.type === 'point') {\n\t\treturn\n\t}\n\n\tconst shape = editor.getShape(terminal.boundShapeId)!\n\tconst transform = editor.getShapePageTransform(shape)!\n\tconst geometry = editor.getShapeGeometry(shape)\n\n\t// This is hacky: we're only looking at the first child in the group. Really the arrow should\n\t// consider all items in the group which are marked as snappable as separate polygons with which\n\t// to intersect, in the case of a group that has multiple children which do not overlap; or else\n\t// flatten the geometry into a set of polygons and intersect with that.\n\tconst outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices\n\n\treturn {\n\t\tshape,\n\t\ttransform,\n\t\tisClosed: geometry.isClosed,\n\t\tisExact: terminal.isExact,\n\t\tdidIntersect: false,\n\t\toutline,\n\t}\n}\n\nfunction getArrowTerminalInArrowSpace(\n\teditor: Editor,\n\tarrowPageTransform: Mat,\n\tterminal: TLArrowShapeTerminal,\n\tforceImprecise: boolean\n) {\n\tif (terminal.type === 'point') {\n\t\treturn Vec.From(terminal)\n\t}\n\n\tconst boundShape = editor.getShape(terminal.boundShapeId)\n\n\tif (!boundShape) {\n\t\t// this can happen in multiplayer contexts where the shape is being deleted\n\t\treturn new Vec(0, 0)\n\t} else {\n\t\t// Find the actual local point of the normalized terminal on\n\t\t// the bound shape and transform it to page space, then transform\n\t\t// it to arrow space\n\t\tconst { point, size } = editor.getShapeGeometry(boundShape).bounds\n\t\tconst shapePoint = Vec.Add(\n\t\t\tpoint,\n\t\t\tVec.MulV(\n\t\t\t\t// if the parent is the bound shape, then it's ALWAYS precise\n\t\t\t\tterminal.isPrecise || forceImprecise ? terminal.normalizedAnchor : { x: 0.5, y: 0.5 },\n\t\t\t\tsize\n\t\t\t)\n\t\t)\n\t\tconst pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape)!, shapePoint)\n\t\tconst arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint)\n\t\treturn arrowPoint\n\t}\n}\n\n/** @public */\nexport function getArrowTerminalsInArrowSpace(editor: Editor, shape: TLArrowShape) {\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tlet startBoundShapeId: TLShapeId | undefined\n\tlet endBoundShapeId: TLShapeId | undefined\n\n\tif (shape.props.start.type === 'binding' && shape.props.end.type === 'binding') {\n\t\tstartBoundShapeId = shape.props.start.boundShapeId\n\t\tendBoundShapeId = shape.props.end.boundShapeId\n\t}\n\n\tconst boundShapeRelationships = getBoundShapeRelationships(\n\t\teditor,\n\t\tstartBoundShapeId,\n\t\tendBoundShapeId\n\t)\n\n\tconst start = getArrowTerminalInArrowSpace(\n\t\teditor,\n\t\tarrowPageTransform,\n\t\tshape.props.start,\n\t\tboundShapeRelationships === 'double-bound' || boundShapeRelationships === 'start-contains-end'\n\t)\n\n\tconst end = getArrowTerminalInArrowSpace(\n\t\teditor,\n\t\tarrowPageTransform,\n\t\tshape.props.end,\n\t\tboundShapeRelationships === 'double-bound' || boundShapeRelationships === 'end-contains-start'\n\t)\n\n\treturn { start, end }\n}\n\n/** @internal */\nexport const MIN_ARROW_LENGTH = 10\n/** @internal */\nexport const BOUND_ARROW_OFFSET = 10\n/** @internal */\nexport const LABEL_TO_ARROW_PADDING = 20\n/** @internal */\nexport const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10\n\n/** @public */\nexport const STROKE_SIZES: Record<string, number> = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\n/**\n * Get the relationships for an arrow that has two bound shape terminals.\n * If the arrow has only one bound shape, then it is always \"safe\" to apply\n * standard offsets and precision behavior. If the shape is bound to the same\n * shape on both ends, then that is an exception. If one of the shape's\n * terminals is bound to a shape that contains / is contained by the shape that\n * is bound to the other terminal, then that is also an exception.\n *\n * @param editor - the editor instance\n * @param startShapeId - the bound shape from the arrow's start\n * @param endShapeId - the bound shape from the arrow's end\n *\n *  @internal */\nexport function getBoundShapeRelationships(\n\teditor: Editor,\n\tstartShapeId?: TLShapeId,\n\tendShapeId?: TLShapeId\n) {\n\tif (!startShapeId || !endShapeId) return 'safe'\n\tif (startShapeId === endShapeId) return 'double-bound'\n\tconst startBounds = editor.getShapePageBounds(startShapeId)\n\tconst endBounds = editor.getShapePageBounds(endShapeId)\n\tif (startBounds && endBounds) {\n\t\tif (startBounds.contains(endBounds)) return 'start-contains-end'\n\t\tif (endBounds.contains(startBounds)) return 'end-contains-start'\n\t}\n\treturn 'safe'\n}\n"],
  "mappings": "AACA,SAAS,WAAW;AACpB,SAAS,WAAW;AACpB,SAAS,eAAe;AAGjB,SAAS,mBAAmB,OAAqB;AACvD,SAAO,KAAK,IAAI,MAAM,MAAM,IAAI,IAAI;AACrC;AAWO,SAAS,6BACf,QACA,UAC6B;AAC7B,MAAI,SAAS,SAAS,SAAS;AAC9B;AAAA,EACD;AAEA,QAAM,QAAQ,OAAO,SAAS,SAAS,YAAY;AACnD,QAAM,YAAY,OAAO,sBAAsB,KAAK;AACpD,QAAM,WAAW,OAAO,iBAAiB,KAAK;AAM9C,QAAM,UAAU,oBAAoB,UAAU,SAAS,SAAS,CAAC,EAAE,WAAW,SAAS;AAEvF,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA,UAAU,SAAS;AAAA,IACnB,SAAS,SAAS;AAAA,IAClB,cAAc;AAAA,IACd;AAAA,EACD;AACD;AAEA,SAAS,6BACR,QACA,oBACA,UACA,gBACC;AACD,MAAI,SAAS,SAAS,SAAS;AAC9B,WAAO,IAAI,KAAK,QAAQ;AAAA,EACzB;AAEA,QAAM,aAAa,OAAO,SAAS,SAAS,YAAY;AAExD,MAAI,CAAC,YAAY;AAEhB,WAAO,IAAI,IAAI,GAAG,CAAC;AAAA,EACpB,OAAO;AAIN,UAAM,EAAE,OAAO,KAAK,IAAI,OAAO,iBAAiB,UAAU,EAAE;AAC5D,UAAM,aAAa,IAAI;AAAA,MACtB;AAAA,MACA,IAAI;AAAA;AAAA,QAEH,SAAS,aAAa,iBAAiB,SAAS,mBAAmB,EAAE,GAAG,KAAK,GAAG,IAAI;AAAA,QACpF;AAAA,MACD;AAAA,IACD;AACA,UAAM,YAAY,IAAI,aAAa,OAAO,sBAAsB,UAAU,GAAI,UAAU;AACxF,UAAM,aAAa,IAAI,aAAa,IAAI,QAAQ,kBAAkB,GAAG,SAAS;AAC9E,WAAO;AAAA,EACR;AACD;AAGO,SAAS,8BAA8B,QAAgB,OAAqB;AAClF,QAAM,qBAAqB,OAAO,sBAAsB,KAAK;AAE7D,MAAI;AACJ,MAAI;AAEJ,MAAI,MAAM,MAAM,MAAM,SAAS,aAAa,MAAM,MAAM,IAAI,SAAS,WAAW;AAC/E,wBAAoB,MAAM,MAAM,MAAM;AACtC,sBAAkB,MAAM,MAAM,IAAI;AAAA,EACnC;AAEA,QAAM,0BAA0B;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,QAAM,QAAQ;AAAA,IACb;AAAA,IACA;AAAA,IACA,MAAM,MAAM;AAAA,IACZ,4BAA4B,kBAAkB,4BAA4B;AAAA,EAC3E;AAEA,QAAM,MAAM;AAAA,IACX;AAAA,IACA;AAAA,IACA,MAAM,MAAM;AAAA,IACZ,4BAA4B,kBAAkB,4BAA4B;AAAA,EAC3E;AAEA,SAAO,EAAE,OAAO,IAAI;AACrB;AAGO,MAAM,mBAAmB;AAEzB,MAAM,qBAAqB;AAE3B,MAAM,yBAAyB;AAE/B,MAAM,gCAAgC;AAGtC,MAAM,eAAuC;AAAA,EACnD,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,IAAI;AACL;AAeO,SAAS,2BACf,QACA,cACA,YACC;AACD,MAAI,CAAC,gBAAgB,CAAC;AAAY,WAAO;AACzC,MAAI,iBAAiB;AAAY,WAAO;AACxC,QAAM,cAAc,OAAO,mBAAmB,YAAY;AAC1D,QAAM,YAAY,OAAO,mBAAmB,UAAU;AACtD,MAAI,eAAe,WAAW;AAC7B,QAAI,YAAY,SAAS,SAAS;AAAG,aAAO;AAC5C,QAAI,UAAU,SAAS,WAAW;AAAG,aAAO;AAAA,EAC7C;AACA,SAAO;AACR;",
  "names": []
}
