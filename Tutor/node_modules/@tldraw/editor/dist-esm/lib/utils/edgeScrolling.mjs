import { COARSE_POINTER_WIDTH, EDGE_SCROLL_DISTANCE, EDGE_SCROLL_SPEED } from "../constants.mjs";
function getEdgeProximityFactor(position, dimension, isCoarse, insetStart, insetEnd) {
  const dist = EDGE_SCROLL_DISTANCE;
  const pw = isCoarse ? COARSE_POINTER_WIDTH : 0;
  const pMin = position - pw;
  const pMax = position + pw;
  const min = insetStart ? 0 : dist;
  const max = insetEnd ? dimension : dimension - dist;
  if (pMin < min) {
    return Math.min(1, (min - pMin) / dist);
  } else if (pMax > max) {
    return -Math.min(1, (pMax - max) / dist);
  }
  return 0;
}
function moveCameraWhenCloseToEdge(editor) {
  if (!editor.inputs.isDragging || editor.inputs.isPanning || !editor.getInstanceState().canMoveCamera)
    return;
  const {
    inputs: {
      currentScreenPoint: { x, y }
    }
  } = editor;
  const zoomLevel = editor.getZoomLevel();
  const screenBounds = editor.getViewportScreenBounds();
  const screenSizeFactorX = screenBounds.w < 1e3 ? 0.612 : 1;
  const screenSizeFactorY = screenBounds.h < 1e3 ? 0.612 : 1;
  const {
    isCoarsePointer,
    insets: [t, r, b, l]
  } = editor.getInstanceState();
  const proximityFactorX = getEdgeProximityFactor(x, screenBounds.w, isCoarsePointer, l, r);
  const proximityFactorY = getEdgeProximityFactor(y, screenBounds.h, isCoarsePointer, t, b);
  if (proximityFactorX === 0 && proximityFactorY === 0)
    return;
  const pxSpeed = editor.user.getEdgeScrollSpeed() * EDGE_SCROLL_SPEED;
  const scrollDeltaX = pxSpeed * proximityFactorX * screenSizeFactorX / zoomLevel;
  const scrollDeltaY = pxSpeed * proximityFactorY * screenSizeFactorY / zoomLevel;
  const camera = editor.getCamera();
  editor.setCamera({
    x: camera.x + scrollDeltaX,
    y: camera.y + scrollDeltaY
  });
}
export {
  moveCameraWhenCloseToEdge
};
//# sourceMappingURL=edgeScrolling.mjs.map
