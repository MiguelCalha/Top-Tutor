{
  "version": 3,
  "sources": ["../../../src/lib/editor/Editor.ts"],
  "sourcesContent": ["import { EMPTY_ARRAY, atom, computed, transact } from '@tldraw/state'\nimport { ComputedCache, RecordType, StoreSnapshot } from '@tldraw/store'\nimport {\n\tCameraRecordType,\n\tInstancePageStateRecordType,\n\tPageRecordType,\n\tStyleProp,\n\tStylePropValue,\n\tTLArrowShape,\n\tTLAsset,\n\tTLAssetId,\n\tTLAssetPartial,\n\tTLCursor,\n\tTLCursorType,\n\tTLDOCUMENT_ID,\n\tTLDocument,\n\tTLFrameShape,\n\tTLGeoShape,\n\tTLGroupShape,\n\tTLHandle,\n\tTLINSTANCE_ID,\n\tTLImageAsset,\n\tTLInstance,\n\tTLInstancePageState,\n\tTLPOINTER_ID,\n\tTLPage,\n\tTLPageId,\n\tTLParentId,\n\tTLRecord,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLStore,\n\tTLUnknownShape,\n\tTLVideoAsset,\n\tcreateShapeId,\n\tgetDefaultColorTheme,\n\tgetShapePropKeysByStyle,\n\tisPageId,\n\tisShape,\n\tisShapeId,\n} from '@tldraw/tlschema'\nimport {\n\tIndexKey,\n\tJsonObject,\n\tannotateError,\n\tassert,\n\tcompact,\n\tdedupe,\n\tdeepCopy,\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBetween,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tobjectMapValues,\n\tsortById,\n\tsortByIndex,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport { EventEmitter } from 'eventemitter3'\nimport { TLUser, createTLUser } from '../config/createTLUser'\nimport { checkShapesAndAddCore } from '../config/defaultShapes'\nimport {\n\tANIMATION_MEDIUM_MS,\n\tCAMERA_MAX_RENDERING_INTERVAL,\n\tCAMERA_MOVING_TIMEOUT,\n\tCAMERA_SLIDE_FRICTION,\n\tCOARSE_DRAG_DISTANCE,\n\tCOLLABORATOR_IDLE_TIMEOUT,\n\tDEFAULT_ANIMATION_OPTIONS,\n\tDRAG_DISTANCE,\n\tFOLLOW_CHASE_PAN_SNAP,\n\tFOLLOW_CHASE_PAN_UNSNAP,\n\tFOLLOW_CHASE_PROPORTION,\n\tFOLLOW_CHASE_ZOOM_SNAP,\n\tFOLLOW_CHASE_ZOOM_UNSNAP,\n\tHIT_TEST_MARGIN,\n\tINTERNAL_POINTER_IDS,\n\tMAX_PAGES,\n\tMAX_SHAPES_PER_PAGE,\n\tMAX_ZOOM,\n\tMIN_ZOOM,\n\tSVG_PADDING,\n\tZOOMS,\n} from '../constants'\nimport { Box } from '../primitives/Box'\nimport { Mat, MatLike, MatModel } from '../primitives/Mat'\nimport { Vec, VecLike } from '../primitives/Vec'\nimport { EASINGS } from '../primitives/easings'\nimport { Geometry2d } from '../primitives/geometry/Geometry2d'\nimport { Group2d } from '../primitives/geometry/Group2d'\nimport { intersectPolygonPolygon } from '../primitives/intersect'\nimport { PI2, approximately, areAnglesCompatible, clamp, pointInPolygon } from '../primitives/utils'\nimport { ReadonlySharedStyleMap, SharedStyle, SharedStyleMap } from '../utils/SharedStylesMap'\nimport { WeakMapCache } from '../utils/WeakMapCache'\nimport { dataUrlToFile } from '../utils/assets'\nimport { getIncrementedName } from '../utils/getIncrementedName'\nimport { getReorderingShapesChanges } from '../utils/reorderShapes'\nimport { applyRotationToSnapshotShapes, getRotationSnapshot } from '../utils/rotation'\nimport { uniqueId } from '../utils/uniqueId'\nimport { arrowBindingsIndex } from './derivations/arrowBindingsIndex'\nimport { parentsToChildren } from './derivations/parentsToChildren'\nimport { deriveShapeIdsInCurrentPage } from './derivations/shapeIdsInCurrentPage'\nimport { ClickManager } from './managers/ClickManager'\nimport { EnvironmentManager } from './managers/EnvironmentManager'\nimport { HistoryManager } from './managers/HistoryManager'\nimport { ScribbleManager } from './managers/ScribbleManager'\nimport { SideEffectManager } from './managers/SideEffectManager'\nimport { SnapManager } from './managers/SnapManager/SnapManager'\nimport { TextManager } from './managers/TextManager'\nimport { TickManager } from './managers/TickManager'\nimport { UserPreferencesManager } from './managers/UserPreferencesManager'\nimport { ShapeUtil, TLResizeMode, TLShapeUtilConstructor } from './shapes/ShapeUtil'\nimport { TLArrowInfo } from './shapes/shared/arrow/arrow-types'\nimport { getCurvedArrowInfo } from './shapes/shared/arrow/curved-arrow'\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from './shapes/shared/arrow/shared'\nimport { getStraightArrowInfo } from './shapes/shared/arrow/straight-arrow'\nimport { RootState } from './tools/RootState'\nimport { StateNode, TLStateNodeConstructor } from './tools/StateNode'\nimport { SvgExportContext, SvgExportDef } from './types/SvgExportContext'\nimport { TLContent } from './types/clipboard-types'\nimport { TLEventMap } from './types/emit-types'\nimport {\n\tTLEventInfo,\n\tTLPinchEventInfo,\n\tTLPointerEventInfo,\n\tTLWheelEventInfo,\n} from './types/event-types'\nimport { TLExternalAssetContent, TLExternalContent } from './types/external-content'\nimport { TLCommandHistoryOptions } from './types/history-types'\nimport { OptionalKeys, RequiredKeys, TLSvgOptions } from './types/misc-types'\nimport { TLResizeHandle } from './types/selection-types'\n\n/** @public */\nexport type TLAnimationOptions = Partial<{\n\tduration: number\n\teasing: (t: number) => number\n}>\n\n/** @public */\nexport type TLResizeShapeOptions = Partial<{\n\tinitialBounds: Box\n\tscaleOrigin: VecLike\n\tscaleAxisRotation: number\n\tinitialShape: TLShape\n\tinitialPageTransform: MatLike\n\tdragHandle: TLResizeHandle\n\tmode: TLResizeMode\n}>\n\n/** @public */\nexport interface TLEditorOptions {\n\t/**\n\t * The Store instance to use for keeping the app's data. This may be prepopulated, e.g. by loading\n\t * from a server or database.\n\t */\n\tstore: TLStore\n\t/**\n\t * An array of shapes to use in the editor. These will be used to create and manage shapes in the editor.\n\t */\n\tshapeUtils: readonly TLShapeUtilConstructor<TLUnknownShape>[]\n\t/**\n\t * An array of tools to use in the editor. These will be used to handle events and manage user interactions in the editor.\n\t */\n\ttools: readonly TLStateNodeConstructor[]\n\t/**\n\t * Should return a containing html element which has all the styles applied to the editor. If not\n\t * given, the body element will be used.\n\t */\n\tgetContainer: () => HTMLElement\n\t/**\n\t * A user defined externally to replace the default user.\n\t */\n\tuser?: TLUser\n\t/**\n\t * The editor's initial active tool (or other state node id).\n\t */\n\tinitialState?: string\n\t/**\n\t * Whether to infer dark mode from the user's system preferences. Defaults to false.\n\t */\n\tinferDarkMode?: boolean\n}\n\n/** @public */\nexport class Editor extends EventEmitter<TLEventMap> {\n\tconstructor({\n\t\tstore,\n\t\tuser,\n\t\tshapeUtils,\n\t\ttools,\n\t\tgetContainer,\n\t\tinitialState,\n\t\tinferDarkMode,\n\t}: TLEditorOptions) {\n\t\tsuper()\n\n\t\tthis.store = store\n\n\t\tthis.snaps = new SnapManager(this)\n\n\t\tthis.user = new UserPreferencesManager(user ?? createTLUser(), inferDarkMode ?? false)\n\n\t\tthis.getContainer = getContainer ?? (() => document.body)\n\n\t\tthis.textMeasure = new TextManager(this)\n\n\t\tclass NewRoot extends RootState {\n\t\t\tstatic override initial = initialState ?? ''\n\t\t}\n\n\t\tthis.root = new NewRoot(this)\n\t\tthis.root.children = {}\n\n\t\tconst allShapeUtils = checkShapesAndAddCore(shapeUtils)\n\n\t\tconst shapeTypesInSchema = new Set(\n\t\t\tObject.keys(store.schema.types.shape.migrations.subTypeMigrations!)\n\t\t)\n\t\tfor (const shapeUtil of allShapeUtils) {\n\t\t\tif (!shapeTypesInSchema.has(shapeUtil.type)) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Editor and store have different shapes: \"${shapeUtil.type}\" was passed into the editor but not the schema`\n\t\t\t\t)\n\t\t\t}\n\t\t\tshapeTypesInSchema.delete(shapeUtil.type)\n\t\t}\n\t\tif (shapeTypesInSchema.size > 0) {\n\t\t\tthrow Error(\n\t\t\t\t`Editor and store have different shapes: \"${\n\t\t\t\t\t[...shapeTypesInSchema][0]\n\t\t\t\t}\" is present in the store schema but not provided to the editor`\n\t\t\t)\n\t\t}\n\t\tconst _shapeUtils = {} as Record<string, ShapeUtil<any>>\n\t\tconst _styleProps = {} as Record<string, Map<StyleProp<unknown>, string>>\n\t\tconst allStylesById = new Map<string, StyleProp<unknown>>()\n\n\t\tfor (const Util of allShapeUtils) {\n\t\t\tconst util = new Util(this)\n\t\t\t_shapeUtils[Util.type] = util\n\n\t\t\tconst propKeysByStyle = getShapePropKeysByStyle(Util.props ?? {})\n\t\t\t_styleProps[Util.type] = propKeysByStyle\n\n\t\t\tfor (const style of propKeysByStyle.keys()) {\n\t\t\t\tif (!allStylesById.has(style.id)) {\n\t\t\t\t\tallStylesById.set(style.id, style)\n\t\t\t\t} else if (allStylesById.get(style.id) !== style) {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Multiple style props with id \"${style.id}\" in use. Style prop IDs must be unique.`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.shapeUtils = _shapeUtils\n\t\tthis.styleProps = _styleProps\n\n\t\t// Tools.\n\t\t// Accept tools from constructor parameters which may not conflict with the root note's default or\n\t\t// \"baked in\" tools, select and zoom.\n\t\tfor (const Tool of [...tools]) {\n\t\t\tif (hasOwnProperty(this.root.children!, Tool.id)) {\n\t\t\t\tthrow Error(`Can't override tool with id \"${Tool.id}\"`)\n\t\t\t}\n\t\t\tthis.root.children![Tool.id] = new Tool(this, this.root)\n\t\t}\n\n\t\tthis.environment = new EnvironmentManager(this)\n\t\tthis.scribbles = new ScribbleManager(this)\n\n\t\t// Cleanup\n\n\t\tconst invalidParents = new Set<TLShapeId>()\n\n\t\tconst reparentArrow = (arrowId: TLArrowShape['id']) => {\n\t\t\tconst arrow = this.getShape<TLArrowShape>(arrowId)\n\t\t\tif (!arrow) return\n\t\t\tconst { start, end } = arrow.props\n\t\t\tconst startShape = start.type === 'binding' ? this.getShape(start.boundShapeId) : undefined\n\t\t\tconst endShape = end.type === 'binding' ? this.getShape(end.boundShapeId) : undefined\n\n\t\t\tconst parentPageId = this.getAncestorPageId(arrow)\n\t\t\tif (!parentPageId) return\n\n\t\t\tlet nextParentId: TLParentId\n\t\t\tif (startShape && endShape) {\n\t\t\t\t// if arrow has two bindings, always parent arrow to closest common ancestor of the bindings\n\t\t\t\tnextParentId = this.findCommonAncestor([startShape, endShape]) ?? parentPageId\n\t\t\t} else if (startShape || endShape) {\n\t\t\t\tconst bindingParentId = (startShape || endShape)?.parentId\n\t\t\t\t// If the arrow and the shape that it is bound to have the same parent, then keep that parent\n\t\t\t\tif (bindingParentId && bindingParentId === arrow.parentId) {\n\t\t\t\t\tnextParentId = arrow.parentId\n\t\t\t\t} else {\n\t\t\t\t\t// if arrow has one binding, keep arrow on its own page\n\t\t\t\t\tnextParentId = parentPageId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (nextParentId && nextParentId !== arrow.parentId) {\n\t\t\t\tthis.reparentShapes([arrowId], nextParentId)\n\t\t\t}\n\n\t\t\tconst reparentedArrow = this.getShape<TLArrowShape>(arrowId)\n\t\t\tif (!reparentedArrow) throw Error('no reparented arrow')\n\n\t\t\tconst startSibling = this.getShapeNearestSibling(reparentedArrow, startShape)\n\t\t\tconst endSibling = this.getShapeNearestSibling(reparentedArrow, endShape)\n\n\t\t\tlet highestSibling: TLShape | undefined\n\n\t\t\tif (startSibling && endSibling) {\n\t\t\t\thighestSibling = startSibling.index > endSibling.index ? startSibling : endSibling\n\t\t\t} else if (startSibling && !endSibling) {\n\t\t\t\thighestSibling = startSibling\n\t\t\t} else if (endSibling && !startSibling) {\n\t\t\t\thighestSibling = endSibling\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet finalIndex: IndexKey\n\n\t\t\tconst higherSiblings = this.getSortedChildIdsForParent(highestSibling.parentId)\n\t\t\t\t.map((id) => this.getShape(id)!)\n\t\t\t\t.filter((sibling) => sibling.index > highestSibling!.index)\n\n\t\t\tif (higherSiblings.length) {\n\t\t\t\t// there are siblings above the highest bound sibling, we need to\n\t\t\t\t// insert between them.\n\n\t\t\t\t// if the next sibling is also a bound arrow though, we can end up\n\t\t\t\t// all fighting for the same indexes. so lets find the next\n\t\t\t\t// non-arrow sibling...\n\t\t\t\tconst nextHighestNonArrowSibling = higherSiblings.find(\n\t\t\t\t\t(sibling) => sibling.type !== 'arrow'\n\t\t\t\t)\n\n\t\t\t\tif (\n\t\t\t\t\t// ...then, if we're above the last shape we want to be above...\n\t\t\t\t\treparentedArrow.index > highestSibling.index &&\n\t\t\t\t\t// ...but below the next non-arrow sibling...\n\t\t\t\t\t(!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)\n\t\t\t\t) {\n\t\t\t\t\t// ...then we're already in the right place. no need to update!\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// otherwise, we need to find the index between the highest sibling\n\t\t\t\t// we want to be above, and the next highest sibling we want to be\n\t\t\t\t// below:\n\t\t\t\tfinalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index)\n\t\t\t} else {\n\t\t\t\t// if there are no siblings above us, we can just get the next index:\n\t\t\t\tfinalIndex = getIndexAbove(highestSibling.index)\n\t\t\t}\n\n\t\t\tif (finalIndex !== reparentedArrow.index) {\n\t\t\t\tthis.updateShapes<TLArrowShape>([{ id: arrowId, type: 'arrow', index: finalIndex }])\n\t\t\t}\n\t\t}\n\n\t\tconst unbindArrowTerminal = (arrow: TLArrowShape, handleId: 'start' | 'end') => {\n\t\t\tconst { x, y } = getArrowTerminalsInArrowSpace(this, arrow)[handleId]\n\t\t\tthis.store.put([{ ...arrow, props: { ...arrow.props, [handleId]: { type: 'point', x, y } } }])\n\t\t}\n\n\t\tconst arrowDidUpdate = (arrow: TLArrowShape) => {\n\t\t\t// if the shape is an arrow and its bound shape is on another page\n\t\t\t// or was deleted, unbind it\n\t\t\tfor (const handle of ['start', 'end'] as const) {\n\t\t\t\tconst terminal = arrow.props[handle]\n\t\t\t\tif (terminal.type !== 'binding') continue\n\t\t\t\tconst boundShape = this.getShape(terminal.boundShapeId)\n\t\t\t\tconst isShapeInSamePageAsArrow =\n\t\t\t\t\tthis.getAncestorPageId(arrow) === this.getAncestorPageId(boundShape)\n\t\t\t\tif (!boundShape || !isShapeInSamePageAsArrow) {\n\t\t\t\t\tunbindArrowTerminal(arrow, handle)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// always check the arrow parents\n\t\t\treparentArrow(arrow.id)\n\t\t}\n\n\t\tconst cleanupInstancePageState = (\n\t\t\tprevPageState: TLInstancePageState,\n\t\t\tshapesNoLongerInPage: Set<TLShapeId>\n\t\t) => {\n\t\t\tlet nextPageState = null as null | TLInstancePageState\n\n\t\t\tconst selectedShapeIds = prevPageState.selectedShapeIds.filter(\n\t\t\t\t(id) => !shapesNoLongerInPage.has(id)\n\t\t\t)\n\t\t\tif (selectedShapeIds.length !== prevPageState.selectedShapeIds.length) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.selectedShapeIds = selectedShapeIds\n\t\t\t}\n\n\t\t\tconst erasingShapeIds = prevPageState.erasingShapeIds.filter(\n\t\t\t\t(id) => !shapesNoLongerInPage.has(id)\n\t\t\t)\n\t\t\tif (erasingShapeIds.length !== prevPageState.erasingShapeIds.length) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.erasingShapeIds = erasingShapeIds\n\t\t\t}\n\n\t\t\tif (prevPageState.hoveredShapeId && shapesNoLongerInPage.has(prevPageState.hoveredShapeId)) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.hoveredShapeId = null\n\t\t\t}\n\n\t\t\tif (prevPageState.editingShapeId && shapesNoLongerInPage.has(prevPageState.editingShapeId)) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.editingShapeId = null\n\t\t\t}\n\n\t\t\tconst hintingShapeIds = prevPageState.hintingShapeIds.filter(\n\t\t\t\t(id) => !shapesNoLongerInPage.has(id)\n\t\t\t)\n\t\t\tif (hintingShapeIds.length !== prevPageState.hintingShapeIds.length) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.hintingShapeIds = hintingShapeIds\n\t\t\t}\n\n\t\t\tif (prevPageState.focusedGroupId && shapesNoLongerInPage.has(prevPageState.focusedGroupId)) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.focusedGroupId = null\n\t\t\t}\n\t\t\treturn nextPageState\n\t\t}\n\n\t\tthis.sideEffects = new SideEffectManager(this)\n\n\t\tthis.sideEffects.registerBatchCompleteHandler(() => {\n\t\t\tfor (const parentId of invalidParents) {\n\t\t\t\tinvalidParents.delete(parentId)\n\t\t\t\tconst parent = this.getShape(parentId)\n\t\t\t\tif (!parent) continue\n\n\t\t\t\tconst util = this.getShapeUtil(parent)\n\t\t\t\tconst changes = util.onChildrenChange?.(parent)\n\n\t\t\t\tif (changes?.length) {\n\t\t\t\t\tthis.updateShapes(changes, { squashing: true })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.emit('update')\n\t\t})\n\n\t\tthis.sideEffects.registerBeforeDeleteHandler('shape', (record) => {\n\t\t\t// if the deleted shape has a parent shape make sure we call it's onChildrenChange callback\n\t\t\tif (record.parentId && isShapeId(record.parentId)) {\n\t\t\t\tinvalidParents.add(record.parentId)\n\t\t\t}\n\t\t\t// clean up any arrows bound to this shape\n\t\t\tconst bindings = this._getArrowBindingsIndex().get()[record.id]\n\t\t\tif (bindings?.length) {\n\t\t\t\tfor (const { arrowId, handleId } of bindings) {\n\t\t\t\t\tconst arrow = this.getShape<TLArrowShape>(arrowId)\n\t\t\t\t\tif (!arrow) continue\n\t\t\t\t\tunbindArrowTerminal(arrow, handleId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst deletedIds = new Set([record.id])\n\t\t\tconst updates = compact(\n\t\t\t\tthis.getPageStates().map((pageState) => {\n\t\t\t\t\treturn cleanupInstancePageState(pageState, deletedIds)\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tif (updates.length) {\n\t\t\t\tthis.store.put(updates)\n\t\t\t}\n\t\t})\n\n\t\tthis.sideEffects.registerBeforeDeleteHandler('page', (record) => {\n\t\t\t// page was deleted, need to check whether it's the current page and select another one if so\n\t\t\tif (this.getInstanceState().currentPageId !== record.id) return\n\n\t\t\tconst backupPageId = this.getPages().find((p) => p.id !== record.id)?.id\n\t\t\tif (!backupPageId) return\n\t\t\tthis.store.put([{ ...this.getInstanceState(), currentPageId: backupPageId }])\n\n\t\t\t// delete the camera and state for the page if necessary\n\t\t\tconst cameraId = CameraRecordType.createId(record.id)\n\t\t\tconst instance_PageStateId = InstancePageStateRecordType.createId(record.id)\n\t\t\tthis.store.remove([cameraId, instance_PageStateId])\n\t\t})\n\n\t\tthis.sideEffects.registerAfterChangeHandler('shape', (prev, next) => {\n\t\t\tif (this.isShapeOfType<TLArrowShape>(next, 'arrow')) {\n\t\t\t\tarrowDidUpdate(next)\n\t\t\t}\n\n\t\t\t// if the shape's parent changed and it is bound to an arrow, update the arrow's parent\n\t\t\tif (prev.parentId !== next.parentId) {\n\t\t\t\tconst reparentBoundArrows = (id: TLShapeId) => {\n\t\t\t\t\tconst boundArrows = this._getArrowBindingsIndex().get()[id]\n\t\t\t\t\tif (boundArrows?.length) {\n\t\t\t\t\t\tfor (const arrow of boundArrows) {\n\t\t\t\t\t\t\treparentArrow(arrow.arrowId)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treparentBoundArrows(next.id)\n\t\t\t\tthis.visitDescendants(next.id, reparentBoundArrows)\n\t\t\t}\n\n\t\t\t// if this shape moved to a new page, clean up any previous page's instance state\n\t\t\tif (prev.parentId !== next.parentId && isPageId(next.parentId)) {\n\t\t\t\tconst allMovingIds = new Set([prev.id])\n\t\t\t\tthis.visitDescendants(prev.id, (id) => {\n\t\t\t\t\tallMovingIds.add(id)\n\t\t\t\t})\n\n\t\t\t\tfor (const instancePageState of this.getPageStates()) {\n\t\t\t\t\tif (instancePageState.pageId === next.parentId) continue\n\t\t\t\t\tconst nextPageState = cleanupInstancePageState(instancePageState, allMovingIds)\n\n\t\t\t\t\tif (nextPageState) {\n\t\t\t\t\t\tthis.store.put([nextPageState])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prev.parentId && isShapeId(prev.parentId)) {\n\t\t\t\tinvalidParents.add(prev.parentId)\n\t\t\t}\n\n\t\t\tif (next.parentId !== prev.parentId && isShapeId(next.parentId)) {\n\t\t\t\tinvalidParents.add(next.parentId)\n\t\t\t}\n\t\t})\n\n\t\tthis.sideEffects.registerAfterChangeHandler('instance_page_state', (prev, next) => {\n\t\t\tif (prev?.selectedShapeIds !== next?.selectedShapeIds) {\n\t\t\t\t// ensure that descendants and ancestors are not selected at the same time\n\t\t\t\tconst filtered = next.selectedShapeIds.filter((id) => {\n\t\t\t\t\tlet parentId = this.getShape(id)?.parentId\n\t\t\t\t\twhile (isShapeId(parentId)) {\n\t\t\t\t\t\tif (next.selectedShapeIds.includes(parentId)) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparentId = this.getShape(parentId)?.parentId\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t})\n\n\t\t\t\tlet nextFocusedGroupId: null | TLShapeId = null\n\n\t\t\t\tif (filtered.length > 0) {\n\t\t\t\t\tconst commonGroupAncestor = this.findCommonAncestor(\n\t\t\t\t\t\tcompact(filtered.map((id) => this.getShape(id))),\n\t\t\t\t\t\t(shape) => this.isShapeOfType<TLGroupShape>(shape, 'group')\n\t\t\t\t\t)\n\n\t\t\t\t\tif (commonGroupAncestor) {\n\t\t\t\t\t\tnextFocusedGroupId = commonGroupAncestor\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (next?.focusedGroupId) {\n\t\t\t\t\t\tnextFocusedGroupId = next.focusedGroupId\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfiltered.length !== next.selectedShapeIds.length ||\n\t\t\t\t\tnextFocusedGroupId !== next.focusedGroupId\n\t\t\t\t) {\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\t{ ...next, selectedShapeIds: filtered, focusedGroupId: nextFocusedGroupId ?? null },\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.sideEffects.registerAfterCreateHandler('shape', (record) => {\n\t\t\tif (this.isShapeOfType<TLArrowShape>(record, 'arrow')) {\n\t\t\t\tarrowDidUpdate(record)\n\t\t\t}\n\t\t})\n\n\t\tthis.sideEffects.registerAfterCreateHandler('page', (record) => {\n\t\t\tconst cameraId = CameraRecordType.createId(record.id)\n\t\t\tconst _pageStateId = InstancePageStateRecordType.createId(record.id)\n\t\t\tif (!this.store.has(cameraId)) {\n\t\t\t\tthis.store.put([CameraRecordType.create({ id: cameraId })])\n\t\t\t}\n\t\t\tif (!this.store.has(_pageStateId)) {\n\t\t\t\tthis.store.put([\n\t\t\t\t\tInstancePageStateRecordType.create({ id: _pageStateId, pageId: record.id }),\n\t\t\t\t])\n\t\t\t}\n\t\t})\n\n\t\tthis._currentPageShapeIds = deriveShapeIdsInCurrentPage(this.store, () =>\n\t\t\tthis.getCurrentPageId()\n\t\t)\n\t\tthis._parentIdsToChildIds = parentsToChildren(this.store)\n\n\t\tthis.disposables.add(\n\t\t\tthis.store.listen((changes) => {\n\t\t\t\tthis.emit('change', changes)\n\t\t\t})\n\t\t)\n\n\t\tthis.store.ensureStoreIsUsable()\n\n\t\t// clear ephemeral state\n\t\tthis._setInstancePageState(\n\t\t\t{\n\t\t\t\teditingShapeId: null,\n\t\t\t\thoveredShapeId: null,\n\t\t\t\terasingShapeIds: [],\n\t\t\t},\n\t\t\t{ ephemeral: true }\n\t\t)\n\n\t\tif (initialState && this.root.children[initialState] === undefined) {\n\t\t\tthrow Error(`No state found for initialState \"${initialState}\".`)\n\t\t}\n\n\t\tthis.root.enter(undefined, 'initial')\n\n\t\tif (this.getInstanceState().followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tthis.updateRenderingBounds()\n\n\t\trequestAnimationFrame(() => {\n\t\t\tthis._tickManager.start()\n\t\t})\n\t}\n\n\t/**\n\t * The editor's store\n\t *\n\t * @public\n\t */\n\treadonly store: TLStore\n\n\t/**\n\t * The root state of the statechart.\n\t *\n\t * @public\n\t */\n\treadonly root: RootState\n\n\t/**\n\t * A set of functions to call when the app is disposed.\n\t *\n\t * @public\n\t */\n\treadonly disposables = new Set<() => void>()\n\n\t/** @internal */\n\tprivate _tickManager = new TickManager(this)\n\n\t/**\n\t * A manager for the app's snapping feature.\n\t *\n\t * @public\n\t */\n\treadonly snaps: SnapManager\n\n\t/**\n\t * A manager for the user and their preferences.\n\t *\n\t * @public\n\t */\n\treadonly user: UserPreferencesManager\n\n\t/**\n\t * A helper for measuring text.\n\t *\n\t * @public\n\t */\n\treadonly textMeasure: TextManager\n\n\t/**\n\t * A manager for the editor's environment.\n\t *\n\t * @public\n\t */\n\treadonly environment: EnvironmentManager\n\n\t/**\n\t * A manager for the editor's scribbles.\n\t *\n\t * @public\n\t */\n\treadonly scribbles: ScribbleManager\n\n\t/**\n\t * The current HTML element containing the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * const container = editor.getContainer()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetContainer: () => HTMLElement\n\n\t/**\n\t * A manager for side effects and correct state enforcement.\n\t *\n\t * @public\n\t */\n\treadonly sideEffects: SideEffectManager<this>\n\n\t/**\n\t * Dispose the editor.\n\t *\n\t * @public\n\t */\n\tdispose() {\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.disposables.clear()\n\t}\n\n\t/* ------------------- Shape Utils ------------------ */\n\n\t/**\n\t * A map of shape utility classes (TLShapeUtils) by shape type.\n\t *\n\t * @public\n\t */\n\tshapeUtils: { readonly [K in string]?: ShapeUtil<TLUnknownShape> }\n\n\tstyleProps: { [key: string]: Map<StyleProp<any>, string> }\n\n\t/**\n\t * Get a shape util from a shape itself.\n\t *\n\t * @example\n\t * ```ts\n\t * const util = editor.getShapeUtil(myArrowShape)\n\t * const util = editor.getShapeUtil('arrow')\n\t * const util = editor.getShapeUtil<TLArrowShape>(myArrowShape)\n\t * const util = editor.getShapeUtil(TLArrowShape)('arrow')\n\t * ```\n\t *\n\t * @param shape - A shape, shape partial, or shape type.\n\t *\n\t * @public\n\t */\n\tgetShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): ShapeUtil<S>\n\tgetShapeUtil<S extends TLUnknownShape>(type: S['type']): ShapeUtil<S>\n\tgetShapeUtil<T extends ShapeUtil>(type: T extends ShapeUtil<infer R> ? R['type'] : string): T\n\tgetShapeUtil(arg: string | { type: string }) {\n\t\tconst type = typeof arg === 'string' ? arg : arg.type\n\t\tconst shapeUtil = getOwnProperty(this.shapeUtils, type)\n\t\tassert(shapeUtil, `No shape util found for type \"${type}\"`)\n\t\treturn shapeUtil\n\t}\n\n\t/* --------------------- History -------------------- */\n\n\t/**\n\t * A manager for the app's history.\n\t *\n\t * @readonly\n\t */\n\treadonly history = new HistoryManager(\n\t\tthis,\n\t\t// () => this._complete(),\n\t\t(error) => {\n\t\t\tthis.annotateError(error, { origin: 'history.batch', willCrashApp: true })\n\t\t\tthis.crash(error)\n\t\t}\n\t)\n\n\t/**\n\t * Undo to the last mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.undo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tundo(): this {\n\t\tthis.history.undo()\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the app can undo.\n\t *\n\t * @public\n\t */\n\t@computed getCanUndo(): boolean {\n\t\treturn this.history.getNumUndos() > 0\n\t}\n\n\t/**\n\t * Redo to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.redo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tredo(): this {\n\t\tthis.history.redo()\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the app can redo.\n\t *\n\t * @public\n\t */\n\t@computed getCanRedo(): boolean {\n\t\treturn this.history.getNumRedos() > 0\n\t}\n\n\t/**\n\t * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n\t * any redos.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.mark()\n\t * editor.mark('flip shapes')\n\t * ```\n\t *\n\t * @param markId - The mark's id, usually the reason for adding the mark.\n\t * @param onUndo - Whether to stop at the mark when undoing.\n\t * @param onRedo - Whether to stop at the mark when redoing.\n\t *\n\t * @public\n\t */\n\tmark(markId?: string, onUndo?: boolean, onRedo?: boolean): this {\n\t\tthis.history.mark(markId, onUndo, onRedo)\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear all marks in the undo stack back to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bail()\n\t * ```\n\t *\n\t * @public\n\t */\n\tbail() {\n\t\tthis.history.bail()\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear all marks in the undo stack back to the mark with the provided mark id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bailToMark('dragging')\n\t * ```\n\t *\n\t * @public\n\t */\n\tbailToMark(id: string): this {\n\t\tthis.history.bailToMark(id)\n\t\treturn this\n\t}\n\n\t/**\n\t * Run a function in a batch, which will be undone/redone as a single action.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.batch(() => {\n\t * \teditor.selectAll()\n\t * \teditor.deleteShapes(editor.getSelectedShapeIds())\n\t * \teditor.createShapes(myShapes)\n\t * \teditor.selectNone()\n\t * })\n\t *\n\t * editor.undo() // will undo all of the above\n\t * ```\n\t *\n\t * @public\n\t */\n\tbatch(fn: () => void): this {\n\t\tthis.history.batch(fn)\n\t\treturn this\n\t}\n\n\t/* --------------------- Arrows --------------------- */\n\t// todo: move these to tldraw or replace with a bindings API\n\n\t/** @internal */\n\t@computed\n\tprivate _getArrowBindingsIndex() {\n\t\treturn arrowBindingsIndex(this)\n\t}\n\n\t/**\n\t * Get all arrows bound to a shape.\n\t *\n\t * @param shapeId - The id of the shape.\n\t *\n\t * @public\n\t */\n\tgetArrowsBoundTo(shapeId: TLShapeId) {\n\t\treturn this._getArrowBindingsIndex().get()[shapeId] || EMPTY_ARRAY\n\t}\n\n\t@computed\n\tprivate getArrowInfoCache() {\n\t\treturn this.store.createComputedCache<TLArrowInfo, TLArrowShape>('arrow infoCache', (shape) => {\n\t\t\treturn getIsArrowStraight(shape)\n\t\t\t\t? getStraightArrowInfo(this, shape)\n\t\t\t\t: getCurvedArrowInfo(this, shape)\n\t\t})\n\t}\n\n\t/**\n\t * Get cached info about an arrow.\n\t *\n\t * @example\n\t * ```ts\n\t * const arrowInfo = editor.getArrowInfo(myArrow)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) of the arrow to get the info for.\n\t *\n\t * @public\n\t */\n\tgetArrowInfo(shape: TLArrowShape | TLShapeId): TLArrowInfo | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\treturn this.getArrowInfoCache().get(id)\n\t}\n\n\t/* --------------------- Errors --------------------- */\n\n\t/** @internal */\n\tannotateError(\n\t\terror: unknown,\n\t\t{\n\t\t\torigin,\n\t\t\twillCrashApp,\n\t\t\ttags,\n\t\t\textras,\n\t\t}: {\n\t\t\torigin: string\n\t\t\twillCrashApp: boolean\n\t\t\ttags?: Record<string, string | boolean | number>\n\t\t\textras?: Record<string, unknown>\n\t\t}\n\t): this {\n\t\tconst defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp)\n\t\tannotateError(error, {\n\t\t\ttags: { ...defaultAnnotations.tags, ...tags },\n\t\t\textras: { ...defaultAnnotations.extras, ...extras },\n\t\t})\n\t\tif (willCrashApp) {\n\t\t\tthis.store.markAsPossiblyCorrupted()\n\t\t}\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tcreateErrorAnnotations(\n\t\torigin: string,\n\t\twillCrashApp: boolean | 'unknown'\n\t): {\n\t\ttags: { origin: string; willCrashApp: boolean | 'unknown' }\n\t\textras: {\n\t\t\tactiveStateNode?: string\n\t\t\tselectedShapes?: TLUnknownShape[]\n\t\t\teditingShape?: TLUnknownShape\n\t\t\tinputs?: Record<string, unknown>\n\t\t}\n\t} {\n\t\ttry {\n\t\t\tconst editingShapeId = this.getEditingShapeId()\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {\n\t\t\t\t\tactiveStateNode: this.root.getPath(),\n\t\t\t\t\tselectedShapes: this.getSelectedShapes(),\n\t\t\t\t\teditingShape: editingShapeId ? this.getShape(editingShapeId) : undefined,\n\t\t\t\t\tinputs: this.inputs,\n\t\t\t\t},\n\t\t\t}\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {},\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _crashingError: unknown | null = null\n\n\t/**\n\t * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,\n\t * we're in a transaction that's about to be rolled back due to the same error we're currently\n\t * reporting.\n\t *\n\t * Instead, to listen to changes to this value, you need to listen to app's `crash` event.\n\t *\n\t * @internal\n\t */\n\tgetCrashingError() {\n\t\treturn this._crashingError\n\t}\n\n\t/** @internal */\n\tcrash(error: unknown): this {\n\t\tthis._crashingError = error\n\t\tthis.store.markAsPossiblyCorrupted()\n\t\tthis.emit('crash', { error })\n\t\treturn this\n\t}\n\n\t/* ------------------- Statechart ------------------- */\n\n\t/**\n\t * The editor's current path of active states.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPath() // \"select.idle\"\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed getPath() {\n\t\treturn this.root.getPath().split('root.')[1]\n\t}\n\n\t/**\n\t * Get whether a certain tool (or other state node) is currently active.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isIn('select')\n\t * editor.isIn('select.brushing')\n\t * ```\n\t *\n\t * @param path - The path of active states, separated by periods.\n\t *\n\t * @public\n\t */\n\tisIn(path: string): boolean {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return true\n\t\t\tconst current = state.getCurrent()\n\t\t\tif (current?.id === id) {\n\t\t\t\tif (ids.length === 0) return true\n\t\t\t\tstate = current\n\t\t\t\tcontinue\n\t\t\t} else return false\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the state node is in any of the given active paths.\n\t *\n\t * @example\n\t * ```ts\n\t * state.isInAny('select', 'erase')\n\t * state.isInAny('select.brushing', 'erase.idle')\n\t * ```\n\t *\n\t * @public\n\t */\n\tisInAny(...paths: string[]): boolean {\n\t\treturn paths.some((path) => this.isIn(path))\n\t}\n\n\t/**\n\t * Set the selected tool.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCurrentTool('hand')\n\t * editor.setCurrentTool('hand', { date: Date.now() })\n\t * ```\n\t *\n\t * @param id - The id of the tool to select.\n\t * @param info - Arbitrary data to pass along into the transition.\n\t *\n\t * @public\n\t */\n\tsetCurrentTool(id: string, info = {}): this {\n\t\tthis.root.transition(id, info)\n\t\treturn this\n\t}\n\n\t/**\n\t * The current selected tool.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentTool(): StateNode {\n\t\treturn this.root.getCurrent()!\n\t}\n\n\t/**\n\t * The id of the current selected tool.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentToolId(): string {\n\t\tconst currentTool = this.getCurrentTool()\n\t\tif (!currentTool) return ''\n\t\treturn currentTool.getCurrentToolIdMask() ?? currentTool.id\n\t}\n\n\t/**\n\t * Get a descendant by its path.\n\t *\n\t * @example\n\t * ```ts\n\t * state.getStateDescendant('select')\n\t * state.getStateDescendant('select.brushing')\n\t * ```\n\t *\n\t * @param path - The descendant's path of state ids, separated by periods.\n\t *\n\t * @public\n\t */\n\tgetStateDescendant<T extends StateNode>(path: string): T | undefined {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return state as T\n\t\t\tconst childState = state.children?.[id]\n\t\t\tif (!childState) return undefined\n\t\t\tstate = childState\n\t\t}\n\t\treturn state as T\n\t}\n\n\t/* ---------------- Document Settings --------------- */\n\n\t/**\n\t * The global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\t@computed getDocumentSettings() {\n\t\treturn this.store.get(TLDOCUMENT_ID)!\n\t}\n\n\t/**\n\t * Update the global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\tupdateDocumentSettings(settings: Partial<TLDocument>): this {\n\t\tthis.store.put([{ ...this.getDocumentSettings(), ...settings }])\n\t\treturn this\n\t}\n\n\t/* ----------------- Instance State ----------------- */\n\n\t/**\n\t * The current instance's state.\n\t *\n\t * @public\n\t */\n\t@computed getInstanceState(): TLInstance {\n\t\treturn this.store.get(TLINSTANCE_ID)!\n\t}\n\n\t/**\n\t * Update the instance's state.\n\t *\n\t * @param partial - A partial object to update the instance state with.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tupdateInstanceState(\n\t\tpartial: Partial<Omit<TLInstance, 'currentPageId'>>,\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t): this {\n\t\tthis._updateInstanceState(partial, { ephemeral: true, squashing: true, ...historyOptions })\n\n\t\tif (partial.isChangingStyle !== undefined) {\n\t\t\tclearTimeout(this._isChangingStyleTimeout)\n\t\t\tif (partial.isChangingStyle === true) {\n\t\t\t\t// If we've set to true, set a new reset timeout to change the value back to false after 2 seconds\n\t\t\t\tthis._isChangingStyleTimeout = setTimeout(() => {\n\t\t\t\t\tthis.updateInstanceState({ isChangingStyle: false }, { ephemeral: true })\n\t\t\t\t}, 2000)\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateInstanceState = this.history.createCommand(\n\t\t'updateInstanceState',\n\t\t(\n\t\t\tpartial: Partial<Omit<TLInstance, 'currentPageId'>>,\n\t\t\thistoryOptions?: TLCommandHistoryOptions\n\t\t) => {\n\t\t\tconst prev = this.store.get(this.getInstanceState().id)!\n\t\t\tconst next = { ...prev, ...partial }\n\n\t\t\treturn {\n\t\t\t\tdata: { prev, next },\n\t\t\t\tephemeral: false,\n\t\t\t\tsquashing: false,\n\t\t\t\t...historyOptions,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.put([next])\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put([prev])\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t/** @internal */\n\tprivate _isChangingStyleTimeout = -1 as any\n\n\t// Menus\n\n\t/**\n\t * A set of strings representing any open menus. When menus are open,\n\t * certain interactions will behave differently; for example, when a\n\t * draw tool is selected and a menu is open, a pointer-down will not\n\t * create a dot (because the user is probably trying to close the menu)\n\t * however a pointer-down event followed by a drag will begin drawing\n\t * a line (because the user is BOTH trying to close the menu AND start\n\t * drawing a line).\n\t *\n\t * @public\n\t */\n\t@computed getOpenMenus(): string[] {\n\t\treturn this.getInstanceState().openMenus\n\t}\n\n\t/**\n\t * Add an open menu.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.addOpenMenu('menu-id')\n\t * ```\n\t *\n\t * @public\n\t */\n\taddOpenMenu(id: string): this {\n\t\tconst menus = new Set(this.getOpenMenus())\n\t\tif (!menus.has(id)) {\n\t\t\tmenus.add(id)\n\t\t\tthis.updateInstanceState({ openMenus: [...menus] })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete an open menu.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteOpenMenu('menu-id')\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeleteOpenMenu(id: string): this {\n\t\tconst menus = new Set(this.getOpenMenus())\n\t\tif (menus.has(id)) {\n\t\t\tmenus.delete(id)\n\t\t\tthis.updateInstanceState({ openMenus: [...menus] })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear all open menus.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.clearOpenMenus()\n\t * ```\n\t *\n\t * @public\n\t */\n\tclearOpenMenus(): this {\n\t\tif (this.getOpenMenus().length) {\n\t\t\tthis.updateInstanceState({ openMenus: [] })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Get whether any menus are open.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isMenuOpen()\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed getIsMenuOpen(): boolean {\n\t\treturn this.getOpenMenus().length > 0\n\t}\n\n\t/* --------------------- Cursor --------------------- */\n\n\t/**\n\t * Set the cursor.\n\t *\n\t * @param type - The cursor type.\n\t * @param rotation - The cursor rotation.\n\t *\n\t * @public\n\t */\n\tsetCursor = (cursor: Partial<TLCursor>): this => {\n\t\tthis.updateInstanceState(\n\t\t\t{ cursor: { ...this.getInstanceState().cursor, ...cursor } },\n\t\t\t{ ephemeral: true }\n\t\t)\n\t\treturn this\n\t}\n\n\t/* ------------------- Page State ------------------- */\n\n\t/**\n\t * Page states.\n\t *\n\t * @public\n\t */\n\t@computed getPageStates(): TLInstancePageState[] {\n\t\treturn this._getPageStatesQuery().get()\n\t}\n\n\t/** @internal */\n\t@computed private _getPageStatesQuery() {\n\t\treturn this.store.query.records('instance_page_state')\n\t}\n\n\t/**\n\t * The current page state.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageState(): TLInstancePageState {\n\t\treturn this.store.get(this._getCurrentPageStateId())!\n\t}\n\n\t/** @internal */\n\t@computed private _getCurrentPageStateId() {\n\t\treturn InstancePageStateRecordType.createId(this.getCurrentPageId())\n\t}\n\n\t/**\n\t * Update this instance's page state.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })\n\t * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' }, { ephemeral: true })\n\t * ```\n\t *\n\t * @param partial - The partial of the page state object containing the changes.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tupdateCurrentPageState(\n\t\tpartial: Partial<\n\t\t\tOmit<TLInstancePageState, 'selectedShapeIds' | 'editingShapeId' | 'pageId' | 'focusedGroupId'>\n\t\t>,\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t): this {\n\t\tthis._setInstancePageState(partial, historyOptions)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setInstancePageState = this.history.createCommand(\n\t\t'setInstancePageState',\n\t\t(\n\t\t\tpartial: Partial<Omit<TLInstancePageState, 'selectedShapeIds'>>,\n\t\t\thistoryOptions?: TLCommandHistoryOptions\n\t\t) => {\n\t\t\tconst prev = this.store.get(partial.id ?? this.getCurrentPageState().id)!\n\t\t\treturn { data: { prev, partial }, ...historyOptions }\n\t\t},\n\t\t{\n\t\t\tdo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(prev.id, (state) => ({ ...state, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(prev.id, () => prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * The current selected ids.\n\t *\n\t * @public\n\t */\n\t@computed getSelectedShapeIds() {\n\t\treturn this.getCurrentPageState().selectedShapeIds\n\t}\n\n\t/**\n\t * An array containing all of the currently selected shapes.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed getSelectedShapes(): TLShape[] {\n\t\tconst { selectedShapeIds } = this.getCurrentPageState()\n\t\treturn compact(selectedShapeIds.map((id) => this.store.get(id)))\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setSelectedShapes(['id1'])\n\t * editor.setSelectedShapes(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tsetSelectedShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t): this {\n\t\tconst ids = shapes.map((shape) => (typeof shape === 'string' ? shape : shape.id))\n\t\tthis._setSelectedShapes(ids, historyOptions)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setSelectedShapes = this.history.createCommand(\n\t\t'setSelectedShapes',\n\t\t(ids: TLShapeId[], historyOptions?: TLCommandHistoryOptions) => {\n\t\t\tconst { selectedShapeIds: prevSelectedShapeIds } = this.getCurrentPageState()\n\t\t\tconst prevSet = new Set(prevSelectedShapeIds)\n\n\t\t\tif (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null\n\n\t\t\treturn {\n\t\t\t\tdata: { selectedShapeIds: ids, prevSelectedShapeIds },\n\t\t\t\tpreservesRedoStack: true,\n\t\t\t\t...historyOptions,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ selectedShapeIds }) => {\n\t\t\t\tthis.store.put([{ ...this.getCurrentPageState(), selectedShapeIds }])\n\t\t\t},\n\t\t\tundo: ({ prevSelectedShapeIds }) => {\n\t\t\t\tthis.store.put([\n\t\t\t\t\t{\n\t\t\t\t\t\t...this.getCurrentPageState(),\n\t\t\t\t\t\tselectedShapeIds: prevSelectedShapeIds,\n\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t},\n\t\t\tsquash({ prevSelectedShapeIds }, { selectedShapeIds }) {\n\t\t\t\treturn {\n\t\t\t\t\tselectedShapeIds,\n\t\t\t\t\tprevSelectedShapeIds,\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Determine whether or not any of a shape's ancestors are selected.\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisAncestorSelected(shape: TLShape | TLShapeId): boolean {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id ?? null\n\t\tconst _shape = this.getShape(id)\n\t\tif (!_shape) return false\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\treturn !!this.findShapeAncestor(_shape, (parent) => selectedShapeIds.includes(parent.id))\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.select('id1')\n\t * editor.select('id1', 'id2')\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t *\n\t * @public\n\t */\n\tselect(...shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\tthis.setSelectedShapes(ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Remove a shape from the existing set of selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deselect(shape.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeselect(...shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\tif (selectedShapeIds.length > 0 && ids.length > 0) {\n\t\t\tthis.setSelectedShapes(selectedShapeIds.filter((id) => !ids.includes(id)))\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Select all direct children of the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectAll()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectAll(): this {\n\t\tconst ids = this.getSortedChildIdsForParent(this.getCurrentPageId())\n\t\t// page might have no shapes\n\t\tif (ids.length <= 0) return this\n\t\tthis.setSelectedShapes(this._getUnlockedShapeIds(ids))\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear the selection.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectNone()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectNone(): this {\n\t\tif (this.getSelectedShapeIds().length > 0) {\n\t\t\tthis.setSelectedShapes([])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The app's only selected shape.\n\t *\n\t * @returns Null if there is no shape or more than one selected shape, otherwise the selected\n\t *   shape.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed getOnlySelectedShape(): TLShape | null {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\t\treturn selectedShapes.length === 1 ? selectedShapes[0] : null\n\t}\n\n\t/**\n\t * The current page bounds of all the selected shapes. If the\n\t * selection is rotated, then these bounds are the axis-aligned\n\t * box that the rotated bounds would fit inside of.\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed getSelectionPageBounds(): Box | null {\n\t\tconst selectedShapeIds = this.getCurrentPageState().selectedShapeIds\n\t\tif (selectedShapeIds.length === 0) return null\n\n\t\treturn Box.Common(compact(selectedShapeIds.map((id) => this.getShapePageBounds(id))))\n\t}\n\n\t/**\n\t * The rotation of the selection bounding box in the current page space.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getSelectionRotation(): number {\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\tif (selectedShapeIds.length === 0) {\n\t\t\treturn 0\n\t\t}\n\t\tif (selectedShapeIds.length === 1) {\n\t\t\treturn this.getShapePageTransform(this.getSelectedShapeIds()[0])!.rotation()\n\t\t}\n\n\t\tconst allRotations = selectedShapeIds.map((id) => this.getShapePageTransform(id)!.rotation())\n\t\t// if the rotations are all compatible with each other, return the rotation of any one of them\n\t\tif (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {\n\t\t\treturn this.getShapePageTransform(selectedShapeIds[0])!.rotation()\n\t\t}\n\t\treturn 0\n\t}\n\t/**\n\t * The bounds of the selection bounding box in the current page space.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getSelectionRotatedPageBounds(): Box | undefined {\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\n\t\tif (selectedShapeIds.length === 0) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst selectionRotation = this.getSelectionRotation()\n\t\tif (selectionRotation === 0) {\n\t\t\treturn this.getSelectionPageBounds()!\n\t\t}\n\n\t\tif (selectedShapeIds.length === 1) {\n\t\t\tconst bounds = this.getShapeGeometry(selectedShapeIds[0]).bounds.clone()\n\t\t\tconst pageTransform = this.getShapePageTransform(selectedShapeIds[0])!\n\t\t\tbounds.point = pageTransform.applyToPoint(bounds.point)\n\t\t\treturn bounds\n\t\t}\n\n\t\t// need to 'un-rotate' all the outlines of the existing nodes so we can fit them inside a box\n\t\tconst boxFromRotatedVertices = Box.FromPoints(\n\t\t\tthis.getSelectedShapeIds()\n\t\t\t\t.flatMap((id) => {\n\t\t\t\t\tconst pageTransform = this.getShapePageTransform(id)\n\t\t\t\t\tif (!pageTransform) return []\n\t\t\t\t\treturn pageTransform.applyToPoints(this.getShapeGeometry(id).vertices)\n\t\t\t\t})\n\t\t\t\t.map((p) => Vec.Rot(p, -selectionRotation))\n\t\t)\n\t\t// now position box so that it's top-left corner is in the right place\n\t\tboxFromRotatedVertices.point = boxFromRotatedVertices.point.rot(selectionRotation)\n\t\treturn boxFromRotatedVertices\n\t}\n\n\t// Focus Group\n\n\t/**\n\t * The current focused group id.\n\t *\n\t * @public\n\t */\n\t@computed getFocusedGroupId(): TLShapeId | TLPageId {\n\t\treturn this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId()\n\t}\n\n\t/**\n\t * The current focused group.\n\t *\n\t * @public\n\t */\n\t@computed getFocusedGroup(): TLShape | undefined {\n\t\tconst focusedGroupId = this.getFocusedGroupId()\n\t\treturn focusedGroupId ? this.getShape(focusedGroupId) : undefined\n\t}\n\n\t/**\n\t * Set the current focused group shape.\n\t *\n\t * @param shape - The group shape id (or group shape's id) to set as the focused group shape.\n\t *\n\t * @public\n\t */\n\tsetFocusedGroup(shape: TLShapeId | TLGroupShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id ?? null\n\n\t\tif (id !== null) {\n\t\t\tconst shape = this.getShape(id)\n\t\t\tif (!shape) {\n\t\t\t\tthrow Error(`Editor.setFocusedGroup: Shape with id ${id} does not exist`)\n\t\t\t}\n\n\t\t\tif (!this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Editor.setFocusedGroup: Cannot set focused group to shape of type ${shape.type}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tif (id === this.getFocusedGroupId()) return this\n\t\tthis._setFocusedGroupId(id)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setFocusedGroupId = this.history.createCommand(\n\t\t'setFocusedGroupId',\n\t\t(next: TLShapeId | null) => {\n\t\t\tconst prev = this.getCurrentPageState().focusedGroupId\n\t\t\tif (prev === next) return\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tprev,\n\t\t\t\t\tnext,\n\t\t\t\t},\n\t\t\t\tpreservesRedoStack: true,\n\t\t\t\tsquashing: true,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.update(this.getCurrentPageState().id, (s) => ({ ...s, focusedGroupId: next }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(this.getCurrentPageState().id, (s) => ({ ...s, focusedGroupId: prev }))\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Exit the current focused group, moving up to the next parent group if there is one.\n\t *\n\t * @public\n\t */\n\tpopFocusedGroupId(): this {\n\t\tconst focusedGroup = this.getFocusedGroup()\n\n\t\tif (focusedGroup) {\n\t\t\t// If we have a focused layer, look for an ancestor of the focused shape that is a group\n\t\t\tconst match = this.findShapeAncestor(focusedGroup, (shape) =>\n\t\t\t\tthis.isShapeOfType<TLGroupShape>(shape, 'group')\n\t\t\t)\n\t\t\t// If we have an ancestor that can become a focused layer, set it as the focused layer\n\t\t\tthis.setFocusedGroup(match?.id ?? null)\n\t\t\tthis.select(focusedGroup.id)\n\t\t} else {\n\t\t\t// If there's no parent focused group, then clear the focus layer and clear selection\n\t\t\tthis.setFocusedGroup(null)\n\t\t\tthis.selectNone()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The current editing shape's id.\n\t *\n\t * @public\n\t */\n\t@computed getEditingShapeId(): TLShapeId | null {\n\t\treturn this.getCurrentPageState().editingShapeId\n\t}\n\n\t/**\n\t * The current editing shape.\n\t *\n\t * @public\n\t */\n\t@computed getEditingShape(): TLShape | undefined {\n\t\tconst editingShapeId = this.getEditingShapeId()\n\t\treturn editingShapeId ? this.getShape(editingShapeId) : undefined\n\t}\n\n\t/**\n\t * Set the current editing shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setEditingShape(myShape)\n\t * editor.setEditingShape(myShape.id)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to set as editing.\n\t *\n\t * @public\n\t */\n\tsetEditingShape(shape: TLShapeId | TLShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id ?? null\n\t\tif (id !== this.getEditingShapeId()) {\n\t\t\tif (id) {\n\t\t\t\tconst shape = this.getShape(id)\n\t\t\t\tif (shape && this.getShapeUtil(shape).canEdit(shape)) {\n\t\t\t\t\tthis._setInstancePageState({ editingShapeId: id })\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Either we just set the editing id to null, or the shape was missing or not editable\n\t\t\tthis._setInstancePageState({ editingShapeId: null })\n\t\t}\n\t\treturn this\n\t}\n\n\t// Hovered\n\n\t/**\n\t * The current hovered shape id.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getHoveredShapeId(): TLShapeId | null {\n\t\treturn this.getCurrentPageState().hoveredShapeId\n\t}\n\n\t/**\n\t * The current hovered shape.\n\t *\n\t * @public\n\t */\n\t@computed getHoveredShape(): TLShape | undefined {\n\t\tconst hoveredShapeId = this.getHoveredShapeId()\n\t\treturn hoveredShapeId ? this.getShape(hoveredShapeId) : undefined\n\t}\n\t/**\n\t * Set the editor's current hovered shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setHoveredShape(myShape)\n\t * editor.setHoveredShape(myShape.id)\n\t * ```\n\t *\n\t * @param shapes - The shape (or shape id) to set as hovered.\n\t *\n\t * @public\n\t */\n\tsetHoveredShape(shape: TLShapeId | TLShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id ?? null\n\t\tif (id === this.getHoveredShapeId()) return this\n\t\tthis.updateCurrentPageState({ hoveredShapeId: id }, { ephemeral: true })\n\t\treturn this\n\t}\n\n\t// Hinting\n\n\t/**\n\t * The editor's current hinting shape ids.\n\t *\n\t * @public\n\t */\n\t@computed getHintingShapeIds() {\n\t\treturn this.getCurrentPageState().hintingShapeIds\n\t}\n\t/**\n\t * The editor's current hinting shapes.\n\t *\n\t * @public\n\t */\n\t@computed getHintingShape() {\n\t\tconst hintingShapeIds = this.getHintingShapeIds()\n\t\treturn compact(hintingShapeIds.map((id) => this.getShape(id)))\n\t}\n\n\t/**\n\t * Set the editor's current hinting shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setHintingShapes([myShape])\n\t * editor.setHintingShapes([myShape.id])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to set as hinting.\n\t *\n\t * @public\n\t */\n\tsetHintingShapes(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\t// always ephemeral\n\t\tthis.updateCurrentPageState({ hintingShapeIds: dedupe(ids) }, { ephemeral: true })\n\t\treturn this\n\t}\n\n\t// Erasing\n\n\t/**\n\t * The editor's current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed getErasingShapeIds() {\n\t\treturn this.getCurrentPageState().erasingShapeIds\n\t}\n\n\t/**\n\t * The editor's current erasing shapes.\n\t *\n\t * @public\n\t */\n\t@computed getErasingShapes() {\n\t\tconst erasingShapeIds = this.getErasingShapeIds()\n\t\treturn compact(erasingShapeIds.map((id) => this.getShape(id)))\n\t}\n\n\t/**\n\t * Set the editor's current erasing shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setErasingShapes([myShape])\n\t * editor.setErasingShapes([myShape.id])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to set as hinting.\n\t *\n\t * @public\n\t */\n\tsetErasingShapes(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\tids.sort() // sort the incoming ids\n\t\tconst erasingShapeIds = this.getErasingShapeIds()\n\t\tif (ids.length === erasingShapeIds.length) {\n\t\t\t// if the new ids are the same length as the current ids, they might be the same.\n\t\t\t// presuming the current ids are also sorted, check each item to see if it's the same;\n\t\t\t// if we find any unequal, then we know the new ids are different.\n\t\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\t\tif (ids[i] !== erasingShapeIds[i]) {\n\t\t\t\t\tthis._setInstancePageState({ erasingShapeIds: ids }, { ephemeral: true })\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// if the ids are a different length, then we know they're different.\n\t\t\tthis._setInstancePageState({ erasingShapeIds: ids }, { ephemeral: true })\n\t\t}\n\n\t\treturn this\n\t}\n\n\t// Cropping\n\n\t/**\n\t * The current cropping shape's id.\n\t *\n\t * @public\n\t */\n\tgetCroppingShapeId() {\n\t\treturn this.getCurrentPageState().croppingShapeId\n\t}\n\n\t/**\n\t * Set the current cropping shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCroppingShape(myShape)\n\t * editor.setCroppingShape(myShape.id)\n\t * ```\n\t *\n\t *\n\t * @param shape - The shape (or shape id) to set as cropping.\n\t *\n\t * @public\n\t */\n\tsetCroppingShape(shape: TLShapeId | TLShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id ?? null\n\t\tif (id !== this.getCroppingShapeId()) {\n\t\t\tif (!id) {\n\t\t\t\tthis.updateCurrentPageState({ croppingShapeId: null })\n\t\t\t} else {\n\t\t\t\tconst shape = this.getShape(id)!\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tif (shape && util.canCrop(shape)) {\n\t\t\t\t\tthis.updateCurrentPageState({ croppingShapeId: id })\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this\n\t}\n\n\t/* --------------------- Camera --------------------- */\n\n\t/** @internal */\n\t@computed\n\tprivate getCameraId() {\n\t\treturn CameraRecordType.createId(this.getCurrentPageId())\n\t}\n\n\t/**\n\t * The current camera.\n\t *\n\t * @public\n\t */\n\t@computed getCamera() {\n\t\treturn this.store.get(this.getCameraId())!\n\t}\n\n\t/**\n\t * The current camera zoom level.\n\t *\n\t * @public\n\t */\n\t@computed getZoomLevel() {\n\t\treturn this.getCamera().z\n\t}\n\n\t/** @internal */\n\tprivate _setCamera(point: VecLike): this {\n\t\tconst currentCamera = this.getCamera()\n\n\t\tif (currentCamera.x === point.x && currentCamera.y === point.y && currentCamera.z === point.z) {\n\t\t\treturn this\n\t\t}\n\n\t\tthis.batch(() => {\n\t\t\tthis.store.put([{ ...currentCamera, ...point }]) // include id and meta here\n\n\t\t\t// Dispatch a new pointer move because the pointer's page will have changed\n\t\t\t// (its screen position will compute to a new page position given the new camera position)\n\t\t\tconst { currentScreenPoint } = this.inputs\n\t\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\n\t\t\tthis.dispatch({\n\t\t\t\ttype: 'pointer',\n\t\t\t\ttarget: 'canvas',\n\t\t\t\tname: 'pointer_move',\n\t\t\t\t// weird but true: we need to put the screen point back into client space\n\t\t\t\tpoint: Vec.AddXY(currentScreenPoint, screenBounds.x, screenBounds.y),\n\t\t\t\tpointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,\n\t\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\t\taltKey: this.inputs.altKey,\n\t\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: this.getInstanceState().isPenMode ?? false,\n\t\t\t})\n\n\t\t\tthis._tickCameraState()\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCamera({ x: 0, y: 0})\n\t * editor.setCamera({ x: 0, y: 0, z: 1.5})\n\t * editor.setCamera({ x: 0, y: 0, z: 1.5}, { duration: 1000, easing: (t) => t * t })\n\t * ```\n\t *\n\t * @param point - The new camera position.\n\t * @param animation - Options for an animation.\n\t *\n\t * @public\n\t */\n\tsetCamera(point: VecLike, animation?: TLAnimationOptions): this {\n\t\tconst x = Number.isFinite(point.x) ? point.x : 0\n\t\tconst y = Number.isFinite(point.y) ? point.y : 0\n\t\tconst z = Number.isFinite(point.z) ? point.z! : this.getZoomLevel()\n\n\t\t// Stop any camera animations\n\t\tthis.stopCameraAnimation()\n\n\t\t// Stop following any user\n\t\tif (this.getInstanceState().followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tif (animation) {\n\t\t\tconst { width, height } = this.getViewportScreenBounds()\n\t\t\treturn this._animateToViewport(new Box(-x, -y, width / z, height / z), animation)\n\t\t} else {\n\t\t\tthis._setCamera({ x, y, z })\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Center the camera on a point (in the current page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.centerOnPoint({ x: 100, y: 100 })\n\t * editor.centerOnPoint({ x: 100, y: 100 }, { duration: 200 })\n\t * ```\n\t *\n\t * @param point - The point in the current page space to center on.\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tcenterOnPoint(point: VecLike, animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst { width: pw, height: ph } = this.getViewportPageBounds()\n\n\t\tthis.setCamera(\n\t\t\t{ x: -(point.x - pw / 2), y: -(point.y - ph / 2), z: this.getCamera().z },\n\t\t\tanimation\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Move the camera to the nearest content.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToContent()\n\t * editor.zoomToContent({ duration: 200 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomToContent(): this {\n\t\tconst bounds = this.getSelectionPageBounds() ?? this.getCurrentPageBounds()\n\n\t\tif (bounds) {\n\t\t\tthis.zoomToBounds(bounds, { targetZoom: Math.min(1, this.getZoomLevel()), duration: 220 })\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current page's content in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToFit()\n\t * editor.zoomToFit({ duration: 200 })\n\t * ```\n\t *\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomToFit(animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst ids = [...this.getCurrentPageShapeIds()]\n\t\tif (ids.length <= 0) return this\n\n\t\tconst pageBounds = Box.Common(compact(ids.map((id) => this.getShapePageBounds(id))))\n\t\tthis.zoomToBounds(pageBounds, animation)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the zoom back to 100%.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.resetZoom()\n\t * editor.resetZoom(editor.getViewportScreenCenter(), { duration: 200 })\n\t * editor.resetZoom(editor.getViewportScreenCenter(), { duration: 200 })\n\t * ```\n\t *\n\t * @param point - The screen point to zoom out on. Defaults to the viewport screen center.\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tresetZoom(point = this.getViewportScreenCenter(), animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\tconst { x, y } = point\n\t\tthis.setCamera(\n\t\t\t{ x: cx + (x / 1 - x) - (x / cz - x), y: cy + (y / 1 - y) - (y / cz - y), z: 1 },\n\t\t\tanimation\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera in.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomIn()\n\t * editor.zoomIn(editor.getViewportScreenCenter(), { duration: 120 })\n\t * editor.zoomIn(editor.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomIn(point = this.getViewportScreenCenter(), animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\n\t\tlet zoom = MAX_ZOOM\n\n\t\tfor (let i = 1; i < ZOOMS.length; i++) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz <= (z2 - z1) / 2) continue\n\t\t\tzoom = z2\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\t\tthis.setCamera(\n\t\t\t{ x: cx + (x / zoom - x) - (x / cz - x), y: cy + (y / zoom - y) - (y / cz - y), z: zoom },\n\t\t\tanimation\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera out.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomOut()\n\t * editor.zoomOut(editor.getViewportScreenCenter(), { duration: 120 })\n\t * editor.zoomOut(editor.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomOut(point = this.getViewportScreenCenter(), animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\n\t\tlet zoom = MIN_ZOOM\n\n\t\tfor (let i = ZOOMS.length - 1; i > 0; i--) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz >= (z2 - z1) / 2) continue\n\t\t\tzoom = z1\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\n\t\tthis.setCamera(\n\t\t\t{\n\t\t\t\tx: cx + (x / zoom - x) - (x / cz - x),\n\t\t\t\ty: cy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tz: zoom,\n\t\t\t},\n\t\t\tanimation\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current selection in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToSelection()\n\t * ```\n\t *\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomToSelection(animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst selectionPageBounds = this.getSelectionPageBounds()\n\t\tif (!selectionPageBounds) return this\n\n\t\tthis.zoomToBounds(selectionPageBounds, {\n\t\t\ttargetZoom: Math.max(1, this.getZoomLevel()),\n\t\t\t...animation,\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if possible.\n\t *\n\t * @param ids - The ids of the shapes to pan and zoom into view.\n\t * @param animation - The options for an animation.\n\t *\n\t * @public\n\t */\n\tpanZoomIntoView(ids: TLShapeId[], animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tif (ids.length <= 0) return this\n\t\tconst selectionBounds = Box.Common(compact(ids.map((id) => this.getShapePageBounds(id))))\n\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\n\t\tif (viewportPageBounds.h < selectionBounds.h || viewportPageBounds.w < selectionBounds.w) {\n\t\t\tthis.zoomToBounds(selectionBounds, { targetZoom: this.getCamera().z, ...animation })\n\n\t\t\treturn this\n\t\t} else {\n\t\t\tconst insetViewport = this.getViewportPageBounds()\n\t\t\t\t.clone()\n\t\t\t\t.expandBy(-32 / this.getZoomLevel())\n\n\t\t\tlet offsetX = 0\n\t\t\tlet offsetY = 0\n\t\t\tif (insetViewport.maxY < selectionBounds.maxY) {\n\t\t\t\t// off bottom\n\t\t\t\toffsetY = insetViewport.maxY - selectionBounds.maxY\n\t\t\t} else if (insetViewport.minY > selectionBounds.minY) {\n\t\t\t\t// off top\n\t\t\t\toffsetY = insetViewport.minY - selectionBounds.minY\n\t\t\t} else {\n\t\t\t\t// inside y-bounds\n\t\t\t}\n\n\t\t\tif (insetViewport.maxX < selectionBounds.maxX) {\n\t\t\t\t// off right\n\t\t\t\toffsetX = insetViewport.maxX - selectionBounds.maxX\n\t\t\t} else if (insetViewport.minX > selectionBounds.minX) {\n\t\t\t\t// off left\n\t\t\t\toffsetX = insetViewport.minX - selectionBounds.minX\n\t\t\t} else {\n\t\t\t\t// inside x-bounds\n\t\t\t}\n\n\t\t\tconst camera = this.getCamera()\n\t\t\tthis.setCamera({ x: camera.x + offsetX, y: camera.y + offsetY, z: camera.z }, animation)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit a bounding box (in the current page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToBounds(myBounds)\n\t * editor.zoomToBounds(myBounds)\n\t * editor.zoomToBounds(myBounds, { duration: 100 })\n\t * editor.zoomToBounds(myBounds, { inset: 0, targetZoom: 1 })\n\t * ```\n\t *\n\t * @param bounds - The bounding box.\n\t * @param options - The options for an animation, target zoom, or custom inset amount.\n\t *\n\t * @public\n\t */\n\tzoomToBounds(\n\t\tbounds: Box,\n\t\topts?: { targetZoom?: number; inset?: number } & TLAnimationOptions\n\t): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst viewportScreenBounds = this.getViewportScreenBounds()\n\n\t\tconst inset = opts?.inset ?? Math.min(256, viewportScreenBounds.width * 0.28)\n\n\t\tlet zoom = clamp(\n\t\t\tMath.min(\n\t\t\t\t(viewportScreenBounds.width - inset) / bounds.width,\n\t\t\t\t(viewportScreenBounds.height - inset) / bounds.height\n\t\t\t),\n\t\t\tMIN_ZOOM,\n\t\t\tMAX_ZOOM\n\t\t)\n\n\t\tif (opts?.targetZoom !== undefined) {\n\t\t\tzoom = Math.min(opts.targetZoom, zoom)\n\t\t}\n\n\t\tthis.setCamera(\n\t\t\t{\n\t\t\t\tx: -bounds.minX + (viewportScreenBounds.width - bounds.width * zoom) / 2 / zoom,\n\t\t\t\ty: -bounds.minY + (viewportScreenBounds.height - bounds.height * zoom) / 2 / zoom,\n\t\t\t\tz: zoom,\n\t\t\t},\n\t\t\topts\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pan({ x: 100, y: 100 })\n\t * editor.pan({ x: 100, y: 100 }, { duration: 1000 })\n\t * ```\n\t *\n\t * @param offset - The offset in the current page space.\n\t * @param animation - The animation options.\n\t */\n\tpan(offset: VecLike, animation?: TLAnimationOptions): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\tthis.setCamera({ x: cx + offset.x / cz, y: cy + offset.y / cz, z: cz }, animation)\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop the current camera animation, if any.\n\t *\n\t * @public\n\t */\n\tstopCameraAnimation(): this {\n\t\tthis.emit('stop-camera-animation')\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _viewportAnimation = null as null | {\n\t\telapsed: number\n\t\tduration: number\n\t\teasing: (t: number) => number\n\t\tstart: Box\n\t\tend: Box\n\t}\n\n\t/** @internal */\n\tprivate _animateViewport(ms: number) {\n\t\tif (!this._viewportAnimation) return\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', this._animateViewport)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t\tthis._viewportAnimation = null\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tthis._viewportAnimation.elapsed += ms\n\n\t\tconst { elapsed, easing, duration, start, end } = this._viewportAnimation\n\n\t\tif (elapsed > duration) {\n\t\t\tthis._setCamera({ x: -end.x, y: -end.y, z: this.getViewportScreenBounds().width / end.width })\n\t\t\tcancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst remaining = duration - elapsed\n\t\tconst t = easing(1 - remaining / duration)\n\n\t\tconst left = start.minX + (end.minX - start.minX) * t\n\t\tconst top = start.minY + (end.minY - start.minY) * t\n\t\tconst right = start.maxX + (end.maxX - start.maxX) * t\n\n\t\tthis._setCamera({ x: -left, y: -top, z: this.getViewportScreenBounds().width / (right - left) })\n\t}\n\n\t/** @internal */\n\tprivate _animateToViewport(targetViewportPage: Box, opts = {} as TLAnimationOptions) {\n\t\tconst { duration = 0, easing = EASINGS.easeInOutCubic } = opts\n\t\tconst animationSpeed = this.user.getAnimationSpeed()\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\n\t\t// If we have an existing animation, then stop it\n\t\tthis.stopCameraAnimation()\n\n\t\t// also stop following any user\n\t\tif (this.getInstanceState().followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tif (duration === 0 || animationSpeed === 0) {\n\t\t\t// If we have no animation, then skip the animation and just set the camera\n\t\t\treturn this._setCamera({\n\t\t\t\tx: -targetViewportPage.x,\n\t\t\t\ty: -targetViewportPage.y,\n\t\t\t\tz: this.getViewportScreenBounds().width / targetViewportPage.width,\n\t\t\t})\n\t\t}\n\n\t\t// Set our viewport animation\n\t\tthis._viewportAnimation = {\n\t\t\telapsed: 0,\n\t\t\tduration: duration / animationSpeed,\n\t\t\teasing,\n\t\t\tstart: viewportPageBounds.clone(),\n\t\t\tend: targetViewportPage.clone(),\n\t\t}\n\n\t\t// On each tick, animate the viewport\n\t\tthis.addListener('tick', this._animateViewport)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Slide the camera in a certain direction.\n\t *\n\t * @param opts - Options for the slide\n\t * @public\n\t */\n\tslideCamera(\n\t\topts = {} as {\n\t\t\tspeed: number\n\t\t\tdirection: VecLike\n\t\t\tfriction: number\n\t\t\tspeedThreshold?: number\n\t\t}\n\t): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tthis.stopCameraAnimation()\n\n\t\tconst animationSpeed = this.user.getAnimationSpeed()\n\n\t\tif (animationSpeed === 0) return this\n\n\t\tconst { speed, friction, direction, speedThreshold = 0.01 } = opts\n\t\tlet currentSpeed = Math.min(speed, 1)\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', moveCamera)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tconst moveCamera = (elapsed: number) => {\n\t\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\t\tconst movementVec = Vec.Mul(direction, (currentSpeed * elapsed) / cz)\n\n\t\t\t// Apply friction\n\t\t\tcurrentSpeed *= 1 - friction\n\t\t\tif (currentSpeed < speedThreshold) {\n\t\t\t\tcancel()\n\t\t\t} else {\n\t\t\t\tthis._setCamera({ x: cx + movementVec.x, y: cy + movementVec.y, z: cz })\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', moveCamera)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a user's cursor position.\n\t * This also briefly show the user's cursor if it's not currently visible.\n\t *\n\t * @param userId - The id of the user to aniamte to.\n\t * @public\n\t */\n\tanimateToUser(userId: string): this {\n\t\tconst presences = this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { eq: userId },\n\t\t}))\n\n\t\tconst presence = [...presences.get()]\n\t\t\t.sort((a, b) => {\n\t\t\t\treturn a.lastActivityTimestamp - b.lastActivityTimestamp\n\t\t\t})\n\t\t\t.pop()\n\n\t\tif (!presence) return this\n\n\t\tthis.batch(() => {\n\t\t\t// If we're following someone, stop following them\n\t\t\tif (this.getInstanceState().followingUserId !== null) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t}\n\n\t\t\t// If we're not on the same page, move to the page they're on\n\t\t\tconst isOnSamePage = presence.currentPageId === this.getCurrentPageId()\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.setCurrentPage(presence.currentPageId)\n\t\t\t}\n\n\t\t\t// Only animate the camera if the user is on the same page as us\n\t\t\tconst options = isOnSamePage ? { duration: 500 } : undefined\n\n\t\t\tthis.centerOnPoint(presence.cursor, options)\n\n\t\t\t// Highlight the user's cursor\n\t\t\tconst { highlightedUserIds } = this.getInstanceState()\n\t\t\tthis.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] })\n\n\t\t\t// Unhighlight the user's cursor after a few seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst highlightedUserIds = [...this.getInstanceState().highlightedUserIds]\n\t\t\t\tconst index = highlightedUserIds.indexOf(userId)\n\t\t\t\tif (index < 0) return\n\t\t\t\thighlightedUserIds.splice(index, 1)\n\t\t\t\tthis.updateInstanceState({ highlightedUserIds })\n\t\t\t}, COLLABORATOR_IDLE_TIMEOUT)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a shape.\n\t *\n\t * @public\n\t */\n\tanimateToShape(shapeId: TLShapeId, opts: TLAnimationOptions = DEFAULT_ANIMATION_OPTIONS): this {\n\t\tif (!this.getInstanceState().canMoveCamera) return this\n\n\t\tconst activeArea = this.getViewportScreenBounds().clone().expandBy(-32)\n\t\tconst viewportAspectRatio = activeArea.width / activeArea.height\n\n\t\tconst shapePageBounds = this.getShapePageBounds(shapeId)\n\n\t\tif (!shapePageBounds) return this\n\n\t\tconst shapeAspectRatio = shapePageBounds.width / shapePageBounds.height\n\n\t\tconst targetViewportPage = shapePageBounds.clone()\n\n\t\tconst z = shapePageBounds.width / activeArea.width\n\t\ttargetViewportPage.width += (activeArea.minX + activeArea.maxX) * z\n\t\ttargetViewportPage.height += (activeArea.minY + activeArea.maxY) * z\n\t\ttargetViewportPage.x -= activeArea.minX * z\n\t\ttargetViewportPage.y -= activeArea.minY * z\n\n\t\tif (shapeAspectRatio > viewportAspectRatio) {\n\t\t\ttargetViewportPage.height = shapePageBounds.width / viewportAspectRatio\n\t\t\ttargetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2\n\t\t} else {\n\t\t\ttargetViewportPage.width = shapePageBounds.height * viewportAspectRatio\n\t\t\ttargetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2\n\t\t}\n\n\t\treturn this._animateToViewport(targetViewportPage, opts)\n\t}\n\n\t// Viewport\n\n\t/** @internal */\n\tprivate _willSetInitialBounds = true\n\tprivate _wasInset = false\n\n\t/**\n\t * Update the viewport. The viewport will measure the size and screen position of its container\n\t * element. This should be done whenever the container's position on the screen changes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateViewportScreenBounds()\n\t * editor.updateViewportScreenBounds(true)\n\t * ```\n\t *\n\t * @param center - Whether to preserve the viewport page center as the viewport changes.\n\t *\n\t * @public\n\t */\n\tupdateViewportScreenBounds(screenBounds: Box, center = false): this {\n\t\tscreenBounds.width = Math.max(screenBounds.width, 1)\n\t\tscreenBounds.height = Math.max(screenBounds.height, 1)\n\n\t\tconst insets = [\n\t\t\t// top\n\t\t\tscreenBounds.minY !== 0,\n\t\t\t// right\n\t\t\tdocument.body.scrollWidth !== screenBounds.maxX,\n\t\t\t// bottom\n\t\t\tdocument.body.scrollHeight !== screenBounds.maxY,\n\t\t\t// left\n\t\t\tscreenBounds.minX !== 0,\n\t\t]\n\n\t\tconst boundsAreEqual = screenBounds.equals(this.getViewportScreenBounds())\n\n\t\tconst { _willSetInitialBounds } = this\n\n\t\tif (boundsAreEqual) {\n\t\t\tthis._willSetInitialBounds = false\n\t\t} else {\n\t\t\tif (_willSetInitialBounds) {\n\t\t\t\t// If we have just received the initial bounds, don't center the camera.\n\t\t\t\tthis._willSetInitialBounds = false\n\t\t\t\tthis.updateInstanceState(\n\t\t\t\t\t{ screenBounds: screenBounds.toJson(), insets },\n\t\t\t\t\t{ squashing: true, ephemeral: true }\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tif (center && !this.getInstanceState().followingUserId) {\n\t\t\t\t\t// Get the page center before the change, make the change, and restore it\n\t\t\t\t\tconst before = this.getViewportPageCenter()\n\t\t\t\t\tthis.updateInstanceState(\n\t\t\t\t\t\t{ screenBounds: screenBounds.toJson(), insets },\n\t\t\t\t\t\t{ squashing: true, ephemeral: true }\n\t\t\t\t\t)\n\t\t\t\t\tthis.centerOnPoint(before)\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise,\n\t\t\t\t\tthis.updateInstanceState(\n\t\t\t\t\t\t{ screenBounds: screenBounds.toJson(), insets },\n\t\t\t\t\t\t{ squashing: true, ephemeral: true }\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._tickCameraState()\n\t\tthis.updateRenderingBounds()\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The bounds of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportScreenBounds() {\n\t\tconst { x, y, w, h } = this.getInstanceState().screenBounds\n\t\treturn new Box(x, y, w, h)\n\t}\n\n\t/**\n\t * The center of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportScreenCenter() {\n\t\tconst viewportScreenBounds = this.getViewportScreenBounds()\n\t\treturn new Vec(\n\t\t\tviewportScreenBounds.midX - viewportScreenBounds.minX,\n\t\t\tviewportScreenBounds.midY - viewportScreenBounds.minY\n\t\t)\n\t}\n\n\t/**\n\t * The current viewport in the current page space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportPageBounds() {\n\t\tconst { w, h } = this.getViewportScreenBounds()\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\treturn new Box(-cx, -cy, w / cz, h / cz)\n\t}\n\n\t/**\n\t * The center of the viewport in the current page space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportPageCenter() {\n\t\treturn this.getViewportPageBounds().center\n\t}\n\t/**\n\t * Convert a point in screen space to a point in the current page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.screenToPage({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The point in screen space.\n\t *\n\t * @public\n\t */\n\tscreenToPage(point: VecLike) {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = this.getCamera()\n\t\treturn {\n\t\t\tx: (point.x - screenBounds.x) / cz - cx,\n\t\t\ty: (point.y - screenBounds.y) / cz - cy,\n\t\t\tz: point.z ?? 0.5,\n\t\t}\n\t}\n\n\t/**\n\t * Convert a point in the current page space to a point in current screen space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pageToScreen({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The point in screen space.\n\t *\n\t * @public\n\t */\n\tpageToScreen(point: VecLike) {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = this.getCamera()\n\n\t\treturn {\n\t\t\tx: (point.x + cx) * cz + screenBounds.x,\n\t\t\ty: (point.y + cy) * cz + screenBounds.y,\n\t\t\tz: point.z ?? 0.5,\n\t\t}\n\t}\n\n\t// Following\n\n\t/**\n\t * Start viewport-following a user.\n\t *\n\t * @param userId - The id of the user to follow.\n\t *\n\t * @public\n\t */\n\tstartFollowingUser(userId: string): this {\n\t\tconst leaderPresences = this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { eq: userId },\n\t\t}))\n\n\t\tconst thisUserId = this.user.getId()\n\n\t\tif (!thisUserId) {\n\t\t\tconsole.warn('You should set the userId for the current instance before following a user')\n\t\t}\n\n\t\t// If the leader is following us, then we can't follow them\n\t\tif (leaderPresences.get().some((p) => p.followingUserId === thisUserId)) {\n\t\t\treturn this\n\t\t}\n\n\t\ttransact(() => {\n\t\t\tthis.stopFollowingUser()\n\n\t\t\tthis.updateInstanceState({ followingUserId: userId }, { ephemeral: true })\n\t\t})\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('frame', moveTowardsUser)\n\t\t\tthis.removeListener('stop-following', cancel)\n\t\t}\n\n\t\tlet isCaughtUp = false\n\n\t\tconst moveTowardsUser = () => {\n\t\t\t// Stop following if we can't find the user\n\t\t\tconst leaderPresence = [...leaderPresences.get()]\n\t\t\t\t.sort((a, b) => {\n\t\t\t\t\treturn a.lastActivityTimestamp - b.lastActivityTimestamp\n\t\t\t\t})\n\t\t\t\t.pop()\n\t\t\tif (!leaderPresence) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Change page if leader is on a different page\n\t\t\tconst isOnSamePage = leaderPresence.currentPageId === this.getCurrentPageId()\n\t\t\tconst chaseProportion = isOnSamePage ? FOLLOW_CHASE_PROPORTION : 1\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t\tthis.setCurrentPage(leaderPresence.currentPageId)\n\t\t\t\tthis.startFollowingUser(userId)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Get the bounds of the follower (me) and the leader (them)\n\t\t\tconst { center, width, height } = this.getViewportPageBounds()\n\t\t\tconst leaderScreen = Box.From(leaderPresence.screenBounds)\n\t\t\tconst leaderWidth = leaderScreen.width / leaderPresence.camera.z\n\t\t\tconst leaderHeight = leaderScreen.height / leaderPresence.camera.z\n\t\t\tconst leaderCenter = new Vec(\n\t\t\t\tleaderWidth / 2 - leaderPresence.camera.x,\n\t\t\t\tleaderHeight / 2 - leaderPresence.camera.y\n\t\t\t)\n\n\t\t\t// At this point, let's check if we're following someone who's following us.\n\t\t\t// If so, we can't try to contain their entire viewport\n\t\t\t// because that would become a feedback loop where we zoom, they zoom, etc.\n\t\t\tconst isFollowingFollower = leaderPresence.followingUserId === thisUserId\n\n\t\t\t// Figure out how much to zoom\n\t\t\tconst desiredWidth = width + (leaderWidth - width) * chaseProportion\n\t\t\tconst desiredHeight = height + (leaderHeight - height) * chaseProportion\n\t\t\tconst ratio = !isFollowingFollower\n\t\t\t\t? Math.min(width / desiredWidth, height / desiredHeight)\n\t\t\t\t: height / desiredHeight\n\n\t\t\tconst targetZoom = clamp(this.getCamera().z * ratio, MIN_ZOOM, MAX_ZOOM)\n\t\t\tconst targetWidth = this.getViewportScreenBounds().w / targetZoom\n\t\t\tconst targetHeight = this.getViewportScreenBounds().h / targetZoom\n\n\t\t\t// Figure out where to move the camera\n\t\t\tconst displacement = leaderCenter.sub(center)\n\t\t\tconst targetCenter = Vec.Add(center, Vec.Mul(displacement, chaseProportion))\n\n\t\t\t// Now let's assess whether we've caught up to the leader or not\n\t\t\tconst distance = Vec.Sub(targetCenter, center).len()\n\t\t\tconst zoomChange = Math.abs(targetZoom - this.getCamera().z)\n\n\t\t\t// If we're chasing the leader...\n\t\t\t// Stop chasing if we're close enough\n\t\t\tif (distance < FOLLOW_CHASE_PAN_SNAP && zoomChange < FOLLOW_CHASE_ZOOM_SNAP) {\n\t\t\t\tisCaughtUp = true\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If we're already caught up with the leader...\n\t\t\t// Only start moving again if we're far enough away\n\t\t\tif (\n\t\t\t\tisCaughtUp &&\n\t\t\t\tdistance < FOLLOW_CHASE_PAN_UNSNAP &&\n\t\t\t\tzoomChange < FOLLOW_CHASE_ZOOM_UNSNAP\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Update the camera!\n\t\t\tisCaughtUp = false\n\t\t\tthis.stopCameraAnimation()\n\t\t\tthis._setCamera({\n\t\t\t\tx: -(targetCenter.x - targetWidth / 2),\n\t\t\t\ty: -(targetCenter.y - targetHeight / 2),\n\t\t\t\tz: targetZoom,\n\t\t\t})\n\t\t}\n\n\t\tthis.once('stop-following', cancel)\n\t\tthis.addListener('frame', moveTowardsUser)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop viewport-following a user.\n\t *\n\t * @public\n\t */\n\tstopFollowingUser(): this {\n\t\tthis.updateInstanceState({ followingUserId: null }, { ephemeral: true })\n\t\tthis.emit('stop-following')\n\t\treturn this\n\t}\n\n\t// Camera state\n\n\tprivate _cameraState = atom('camera state', 'idle' as 'idle' | 'moving')\n\n\t/**\n\t * Whether the camera is moving or idle.\n\t *\n\t * @public\n\t */\n\tgetCameraState() {\n\t\treturn this._cameraState.get()\n\t}\n\n\t// Camera state does two things: first, it allows us to subscribe to whether\n\t// the camera is moving or not; and second, it allows us to update the rendering\n\t// shapes on the canvas. Changing the rendering shapes may cause shapes to\n\t// unmount / remount in the DOM, which is expensive; and computing visibility is\n\t// also expensive in large projects. For this reason, we use a second bounding\n\t// box just for rendering, and we only update after the camera stops moving.\n\n\tprivate _cameraStateTimeoutRemaining = 0\n\tprivate _lastUpdateRenderingBoundsTimestamp = Date.now()\n\n\tprivate _decayCameraStateTimeout = (elapsed: number) => {\n\t\tthis._cameraStateTimeoutRemaining -= elapsed\n\n\t\tif (this._cameraStateTimeoutRemaining <= 0) {\n\t\t\tthis.off('tick', this._decayCameraStateTimeout)\n\t\t\tthis._cameraState.set('idle')\n\t\t\tthis.updateRenderingBounds()\n\t\t}\n\t}\n\n\tprivate _tickCameraState = () => {\n\t\t// always reset the timeout\n\t\tthis._cameraStateTimeoutRemaining = CAMERA_MOVING_TIMEOUT\n\n\t\tconst now = Date.now()\n\n\t\t// If the state is idle, then start the tick\n\t\tif (this._cameraState.__unsafe__getWithoutCapture() === 'idle') {\n\t\t\tthis._lastUpdateRenderingBoundsTimestamp = now // don't render right away\n\t\t\tthis._cameraState.set('moving')\n\t\t\tthis.on('tick', this._decayCameraStateTimeout)\n\t\t} else {\n\t\t\tif (now - this._lastUpdateRenderingBoundsTimestamp > CAMERA_MAX_RENDERING_INTERVAL) {\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getUnorderedRenderingShapes(\n\t\t// The rendering state. We use this method both for rendering, which\n\t\t// is based on other state, and for computing order for SVG export,\n\t\t// which should work even when things are for example off-screen.\n\t\tuseEditorState: boolean\n\t) {\n\t\t// Here we get the shape as well as any of its children, as well as their\n\t\t// opacities. If the shape is being erased, and none of its ancestors are\n\t\t// being erased, then we reduce the opacity of the shape and all of its\n\t\t// ancestors; but we don't apply this effect more than once among a set\n\t\t// of descendants so that it does not compound.\n\n\t\t// This is designed to keep all the shapes in a single list which\n\t\t// allows the DOM nodes to be reused even when they become children\n\t\t// of other nodes.\n\n\t\tconst renderingShapes: {\n\t\t\tid: TLShapeId\n\t\t\tshape: TLShape\n\t\t\tutil: ShapeUtil\n\t\t\tindex: number\n\t\t\tbackgroundIndex: number\n\t\t\topacity: number\n\t\t\tisCulled: boolean\n\t\t\tmaskedPageBounds: Box | undefined\n\t\t}[] = []\n\n\t\tlet nextIndex = MAX_SHAPES_PER_PAGE * 2\n\t\tlet nextBackgroundIndex = MAX_SHAPES_PER_PAGE\n\n\t\t// We only really need these if we're using editor state, but that's ok\n\t\tconst editingShapeId = this.getEditingShapeId()\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\tconst erasingShapeIds = this.getErasingShapeIds()\n\t\tconst renderingBoundsExpanded = this.getRenderingBoundsExpanded()\n\n\t\t// If renderingBoundsMargin is set to Infinity, then we won't cull offscreen shapes\n\t\tconst isCullingOffScreenShapes = Number.isFinite(this.renderingBoundsMargin)\n\n\t\tconst addShapeById = (id: TLShapeId, opacity: number, isAncestorErasing: boolean) => {\n\t\t\tconst shape = this.getShape(id)\n\t\t\tif (!shape) return\n\n\t\t\topacity *= shape.opacity\n\t\t\tlet isCulled = false\n\t\t\tlet isShapeErasing = false\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tconst maskedPageBounds = this.getShapeMaskedPageBounds(id)\n\n\t\t\tif (useEditorState) {\n\t\t\t\tisShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id)\n\t\t\t\tif (isShapeErasing) {\n\t\t\t\t\topacity *= 0.32\n\t\t\t\t}\n\n\t\t\t\tisCulled =\n\t\t\t\t\tisCullingOffScreenShapes &&\n\t\t\t\t\t// only cull shapes that allow unmounting, i.e. not stateful components\n\t\t\t\t\tutil.canUnmount(shape) &&\n\t\t\t\t\t// never cull editingg shapes\n\t\t\t\t\teditingShapeId !== id &&\n\t\t\t\t\t// if the shape is fully outside of its parent's clipping bounds...\n\t\t\t\t\t(maskedPageBounds === undefined ||\n\t\t\t\t\t\t// ...or if the shape is outside of the expanded viewport bounds...\n\t\t\t\t\t\t(!renderingBoundsExpanded.includes(maskedPageBounds) &&\n\t\t\t\t\t\t\t// ...and if it's not selected... then cull it\n\t\t\t\t\t\t\t!selectedShapeIds.includes(id)))\n\t\t\t}\n\n\t\t\trenderingShapes.push({\n\t\t\t\tid,\n\t\t\t\tshape,\n\t\t\t\tutil,\n\t\t\t\tindex: nextIndex,\n\t\t\t\tbackgroundIndex: nextBackgroundIndex,\n\t\t\t\topacity,\n\t\t\t\tisCulled,\n\t\t\t\tmaskedPageBounds,\n\t\t\t})\n\n\t\t\tnextIndex += 1\n\t\t\tnextBackgroundIndex += 1\n\n\t\t\tconst childIds = this.getSortedChildIdsForParent(id)\n\t\t\tif (!childIds.length) return\n\n\t\t\tlet backgroundIndexToRestore = null\n\t\t\tif (util.providesBackgroundForChildren(shape)) {\n\t\t\t\tbackgroundIndexToRestore = nextBackgroundIndex\n\t\t\t\tnextBackgroundIndex = nextIndex\n\t\t\t\tnextIndex += MAX_SHAPES_PER_PAGE\n\t\t\t}\n\n\t\t\tfor (const childId of childIds) {\n\t\t\t\taddShapeById(childId, opacity, isAncestorErasing || isShapeErasing)\n\t\t\t}\n\n\t\t\tif (backgroundIndexToRestore !== null) {\n\t\t\t\tnextBackgroundIndex = backgroundIndexToRestore\n\t\t\t}\n\t\t}\n\n\t\t// If we're using editor state, then we're only interested in on-screen shapes.\n\t\t// If we're not using the editor state, then we're interested in ALL shapes, even those from other pages.\n\t\tconst pages = useEditorState ? [this.getCurrentPage()] : this.getPages()\n\t\tfor (const page of pages) {\n\t\t\tfor (const childId of this.getSortedChildIdsForParent(page.id)) {\n\t\t\t\taddShapeById(childId, 1, false)\n\t\t\t}\n\t\t}\n\n\t\treturn renderingShapes\n\t}\n\n\t/**\n\t * Get the shapes that should be displayed in the current viewport.\n\t *\n\t * @public\n\t */\n\t@computed getRenderingShapes() {\n\t\tconst renderingShapes = this.getUnorderedRenderingShapes(true)\n\n\t\t// Its IMPORTANT that the result be sorted by id AND include the index\n\t\t// that the shape should be displayed at. Steve, this is the past you\n\t\t// telling the present you not to change this.\n\n\t\t// We want to sort by id because moving elements about in the DOM will\n\t\t// cause the element to get removed by react as it moves the DOM node. This\n\t\t// causes <iframes/> to re-render which is hella annoying and a perf\n\t\t// drain. By always sorting by 'id' we keep the shapes always in the\n\t\t// same order; but we later use index to set the element's 'z-index'\n\t\t// to change the \"rendered\" position in z-space.\n\t\treturn renderingShapes.sort(sortById)\n\t}\n\n\t/**\n\t * The current rendering bounds in the current page space, used for checking which shapes are \"on screen\".\n\t *\n\t * @public\n\t */\n\tgetRenderingBounds() {\n\t\treturn this._renderingBounds.get()\n\t}\n\n\t/** @internal */\n\tprivate readonly _renderingBounds = atom('rendering viewport', new Box())\n\n\t/**\n\t * The current rendering bounds in the current page space, expanded slightly. Used for determining which shapes\n\t * to render and which to \"cull\".\n\t *\n\t * @public\n\t */\n\tgetRenderingBoundsExpanded() {\n\t\treturn this._renderingBoundsExpanded.get()\n\t}\n\n\t/** @internal */\n\tprivate readonly _renderingBoundsExpanded = atom('rendering viewport expanded', new Box())\n\n\t/**\n\t * Update the rendering bounds. This should be called when the viewport has stopped changing, such\n\t * as at the end of a pan, zoom, or animation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateRenderingBounds()\n\t * ```\n\t *\n\t *\n\t * @internal\n\t */\n\tupdateRenderingBounds(): this {\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\tif (viewportPageBounds.equals(this._renderingBounds.__unsafe__getWithoutCapture())) return this\n\t\tthis._renderingBounds.set(viewportPageBounds.clone())\n\n\t\tif (Number.isFinite(this.renderingBoundsMargin)) {\n\t\t\tthis._renderingBoundsExpanded.set(\n\t\t\t\tviewportPageBounds.clone().expandBy(this.renderingBoundsMargin / this.getZoomLevel())\n\t\t\t)\n\t\t} else {\n\t\t\tthis._renderingBoundsExpanded.set(viewportPageBounds)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * The distance to expand the viewport when measuring culling. A larger distance will\n\t * mean that shapes near to the viewport (but still outside of it) will not be culled.\n\t *\n\t * @public\n\t */\n\trenderingBoundsMargin = 100\n\n\t/* --------------------- Pages ---------------------- */\n\n\t@computed private _getAllPagesQuery() {\n\t\treturn this.store.query.records('page')\n\t}\n\n\t/**\n\t * Info about the project's current pages.\n\t *\n\t * @public\n\t */\n\t@computed getPages(): TLPage[] {\n\t\treturn this._getAllPagesQuery().get().sort(sortByIndex)\n\t}\n\n\t/**\n\t * The current page.\n\t *\n\t * @public\n\t */\n\tgetCurrentPage(): TLPage {\n\t\treturn this.getPage(this.getCurrentPageId())!\n\t}\n\n\t/**\n\t * The current page id.\n\t *\n\t * @public\n\t */\n\tgetCurrentPageId(): TLPageId {\n\t\treturn this.getInstanceState().currentPageId\n\t}\n\n\t/**\n\t * Get a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPage(myPage.id)\n\t * editor.getPage(myPage)\n\t * ```\n\t *\n\t * @param page - The page (or page id) to get.\n\t *\n\t * @public\n\t */\n\tgetPage(page: TLPageId | TLPage): TLPage | undefined {\n\t\treturn this.store.get(typeof page === 'string' ? page : page.id)\n\t}\n\n\t/* @internal */\n\tprivate readonly _currentPageShapeIds: ReturnType<typeof deriveShapeIdsInCurrentPage>\n\n\t/**\n\t * An array of all of the shapes on the current page.\n\t *\n\t * @public\n\t */\n\tgetCurrentPageShapeIds() {\n\t\treturn this._currentPageShapeIds.get()\n\t}\n\n\t/**\n\t * Get the ids of shapes on a page.\n\t *\n\t * @example\n\t * ```ts\n\t * const idsOnPage1 = editor.getPageShapeIds('page1')\n\t * const idsOnPage2 = editor.getPageShapeIds(myPage2)\n\t * ```\n\t *\n\t * @param page - The page (or page id) to get.\n\t *\n\t * @public\n\t **/\n\tgetPageShapeIds(page: TLPageId | TLPage): Set<TLShapeId> {\n\t\tconst pageId = typeof page === 'string' ? page : page.id\n\t\tconst result = this.store.query.exec('shape', { parentId: { eq: pageId } })\n\t\treturn this.getShapeAndDescendantIds(result.map((s) => s.id))\n\t}\n\n\t/**\n\t * Set the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCurrentPage('page1')\n\t * editor.setCurrentPage(myPage1)\n\t * ```\n\t *\n\t * @param page - The page (or page id) to set as the current page.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tsetCurrentPage(page: TLPageId | TLPage, historyOptions?: TLCommandHistoryOptions): this {\n\t\tconst pageId = typeof page === 'string' ? page : page.id\n\t\tthis._setCurrentPageId(pageId, historyOptions)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _setCurrentPageId = this.history.createCommand(\n\t\t'setCurrentPage',\n\t\t(pageId: TLPageId, historyOptions?: TLCommandHistoryOptions) => {\n\t\t\tif (!this.store.has(pageId)) {\n\t\t\t\tconsole.error(\"Tried to set the current page id to a page that doesn't exist.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.stopFollowingUser()\n\n\t\t\treturn {\n\t\t\t\tdata: { toId: pageId, fromId: this.getCurrentPageId() },\n\t\t\t\tsquashing: true,\n\t\t\t\tpreservesRedoStack: true,\n\t\t\t\t...historyOptions,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ toId }) => {\n\t\t\t\tif (!this.store.has(toId)) {\n\t\t\t\t\t// in multiplayer contexts this page might have been deleted\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (!this.getPageStates().find((p) => p.pageId === toId)) {\n\t\t\t\t\tconst camera = CameraRecordType.create({\n\t\t\t\t\t\tid: CameraRecordType.createId(toId),\n\t\t\t\t\t})\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\tcamera,\n\t\t\t\t\t\tInstancePageStateRecordType.create({\n\t\t\t\t\t\t\tid: InstancePageStateRecordType.createId(toId),\n\t\t\t\t\t\t\tpageId: toId,\n\t\t\t\t\t\t}),\n\t\t\t\t\t])\n\t\t\t\t}\n\n\t\t\t\tthis.store.put([{ ...this.getInstanceState(), currentPageId: toId }])\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ fromId }) => {\n\t\t\t\tif (!this.store.has(fromId)) {\n\t\t\t\t\t// in multiplayer contexts this page might have been deleted\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.store.put([{ ...this.getInstanceState(), currentPageId: fromId }])\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tsquash: ({ fromId }, { toId }) => {\n\t\t\t\treturn { toId, fromId }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updatePage({ id: 'page2', name: 'Page 2' })\n\t * editor.updatePage({ id: 'page2', name: 'Page 2' }, { squashing: true })\n\t * ```\n\t *\n\t * @param partial - The partial of the shape to update.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tupdatePage(partial: RequiredKeys<TLPage, 'id'>, historyOptions?: TLCommandHistoryOptions): this {\n\t\tthis._updatePage(partial, historyOptions)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _updatePage = this.history.createCommand(\n\t\t'updatePage',\n\t\t(partial: RequiredKeys<TLPage, 'id'>, historyOptions?: TLCommandHistoryOptions) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\n\t\t\tconst prev = this.getPage(partial.id)\n\n\t\t\tif (!prev) return null\n\n\t\t\treturn { data: { prev, partial }, ...historyOptions }\n\t\t},\n\t\t{\n\t\t\tdo: ({ partial }) => {\n\t\t\t\tthis.store.update(partial.id, (page) => ({ ...page, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(partial.id, () => prev)\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\tprev: { ...prevData.prev, ...nextData.prev },\n\t\t\t\t\tpartial: nextData.partial,\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Create a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createPage(myPage)\n\t * editor.createPage({ name: 'Page 2' })\n\t * ```\n\t *\n\t * @param page - The page (or page partial) to create.\n\t *\n\t * @public\n\t */\n\tcreatePage(page: Partial<TLPage>): this {\n\t\tthis._createPage(page)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _createPage = this.history.createCommand(\n\t\t'createPage',\n\t\t(page: Partial<TLPage>) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\t\t\tif (this.getPages().length >= MAX_PAGES) return null\n\t\t\tconst pages = this.getPages()\n\n\t\t\tconst name = getIncrementedName(\n\t\t\t\tpage.name ?? 'Page 1',\n\t\t\t\tpages.map((p) => p.name)\n\t\t\t)\n\n\t\t\tlet index = page.index\n\n\t\t\tif (!index || pages.some((p) => p.index === index)) {\n\t\t\t\tindex = getIndexAbove(pages[pages.length - 1].index)\n\t\t\t}\n\n\t\t\tconst newPage = PageRecordType.create({\n\t\t\t\tmeta: {},\n\t\t\t\t...page,\n\t\t\t\tname,\n\t\t\t\tindex,\n\t\t\t})\n\n\t\t\tconst newCamera = CameraRecordType.create({\n\t\t\t\tid: CameraRecordType.createId(newPage.id),\n\t\t\t})\n\n\t\t\tconst newTabPageState = InstancePageStateRecordType.create({\n\t\t\t\tid: InstancePageStateRecordType.createId(newPage.id),\n\t\t\t\tpageId: newPage.id,\n\t\t\t})\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\tnewCamera,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ newPage, newTabPageState, newCamera }) => {\n\t\t\t\tthis.store.put([newPage, newCamera, newTabPageState])\n\t\t\t},\n\t\t\tundo: ({ newPage, newTabPageState, newCamera }) => {\n\t\t\t\tif (this.getPages().length === 1) return\n\t\t\t\tthis.store.remove([newTabPageState.id, newPage.id, newCamera.id])\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Delete a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deletePage('page1')\n\t * ```\n\t *\n\t * @param id - The id of the page to delete.\n\t *\n\t * @public\n\t */\n\tdeletePage(page: TLPageId | TLPage): this {\n\t\tconst id = typeof page === 'string' ? page : page.id\n\t\tthis._deletePage(id)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _deletePage = this.history.createCommand(\n\t\t'delete_page',\n\t\t(id: TLPageId) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\t\t\tconst pages = this.getPages()\n\t\t\tif (pages.length === 1) return null\n\n\t\t\tconst deletedPage = this.getPage(id)\n\t\t\tconst deletedPageStates = this.getPageStates().filter((s) => s.pageId === id)\n\n\t\t\tif (!deletedPage) return null\n\n\t\t\tif (id === this.getCurrentPageId()) {\n\t\t\t\tconst index = pages.findIndex((page) => page.id === id)\n\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\tthis.setCurrentPage(next.id)\n\t\t\t}\n\n\t\t\treturn { data: { id, deletedPage, deletedPageStates } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tconst pages = this.getPages()\n\t\t\t\tif (pages.length === 1) return\n\n\t\t\t\tif (deletedPage.id === this.getCurrentPageId()) {\n\t\t\t\t\tconst index = pages.findIndex((page) => page.id === deletedPage.id)\n\t\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\t\tthis.setCurrentPage(next.id)\n\t\t\t\t}\n\n\t\t\t\tthis.store.remove(deletedPageStates.map((s) => s.id)) // remove the page state\n\t\t\t\tthis.store.remove([deletedPage.id]) // remove the page\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tthis.store.put([deletedPage])\n\t\t\t\tthis.store.put(deletedPageStates)\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Duplicate a page.\n\t *\n\t * @param id - The id of the page to duplicate. Defaults to the current page.\n\t * @param createId - The id of the new page. Defaults to a new id.\n\t *\n\t * @public\n\t */\n\tduplicatePage(page: TLPageId | TLPage, createId: TLPageId = PageRecordType.createId()): this {\n\t\tif (this.getPages().length >= MAX_PAGES) return this\n\t\tconst id = typeof page === 'string' ? page : page.id\n\t\tconst freshPage = this.getPage(id) // get the most recent version of the page anyway\n\t\tif (!freshPage) return this\n\n\t\tconst prevCamera = { ...this.getCamera() }\n\t\tconst content = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(freshPage.id))\n\n\t\tthis.batch(() => {\n\t\t\tconst pages = this.getPages()\n\t\t\tconst index = getIndexBetween(freshPage.index, pages[pages.indexOf(freshPage) + 1]?.index)\n\n\t\t\t// create the page (also creates the pagestate and camera for the new page)\n\t\t\tthis.createPage({ name: freshPage.name + ' Copy', id: createId, index })\n\t\t\t// set the new page as the current page\n\t\t\tthis.setCurrentPage(createId)\n\t\t\t// update the new page's camera to the previous page's camera\n\t\t\tthis.setCamera(prevCamera)\n\n\t\t\tif (content) {\n\t\t\t\t// If we had content on the previous page, put it on the new page\n\t\t\t\treturn this.putContentOntoCurrentPage(content)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Rename a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.renamePage('page1', 'My Page')\n\t * ```\n\t *\n\t * @param id - The id of the page to rename.\n\t * @param name - The new name.\n\t *\n\t * @public\n\t */\n\trenamePage(page: TLPageId | TLPage, name: string, historyOptions?: TLCommandHistoryOptions) {\n\t\tconst id = typeof page === 'string' ? page : page.id\n\t\tif (this.getInstanceState().isReadonly) return this\n\t\tthis.updatePage({ id, name }, historyOptions)\n\t\treturn this\n\t}\n\n\t/* --------------------- Assets --------------------- */\n\n\t/** @internal */\n\t@computed private _getAllAssetsQuery() {\n\t\treturn this.store.query.records('asset')\n\t}\n\n\t/**\n\t * Get all assets in the editor.\n\t *\n\t * @public\n\t */\n\tgetAssets() {\n\t\treturn this._getAllAssetsQuery().get()\n\t}\n\n\t/**\n\t * Create one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createAssets([...myAssets])\n\t * ```\n\t *\n\t * @param assets - The assets to create.\n\t *\n\t * @public\n\t */\n\tcreateAssets(assets: TLAsset[]): this {\n\t\tthis._createAssets(assets)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _createAssets = this.history.createCommand(\n\t\t'createAssets',\n\t\t(assets: TLAsset[]) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\t\t\tif (assets.length <= 0) return null\n\n\t\t\treturn { data: { assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets }) => {\n\t\t\t\tthis.store.put(assets)\n\t\t\t},\n\t\t\tundo: ({ assets }) => {\n\t\t\t\t// todo: should we actually remove assets here? or on cleanup elsewhere?\n\t\t\t\tthis.store.remove(assets.map((a) => a.id))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateAssets([{ id: 'asset1', name: 'New name' }])\n\t * ```\n\t *\n\t * @param assets - The assets to update.\n\t *\n\t * @public\n\t */\n\tupdateAssets(assets: TLAssetPartial[]): this {\n\t\tthis._updateAssets(assets)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _updateAssets = this.history.createCommand(\n\t\t'updateAssets',\n\t\t(assets: TLAssetPartial[]) => {\n\t\t\tif (this.getInstanceState().isReadonly) return\n\t\t\tif (assets.length <= 0) return\n\n\t\t\tconst snapshots: Record<string, TLAsset> = {}\n\n\t\t\treturn { data: { snapshots, assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets, snapshots }) => {\n\t\t\t\tthis.store.put(\n\t\t\t\t\tassets.map((a) => {\n\t\t\t\t\t\tconst asset = this.store.get(a.id)!\n\t\t\t\t\t\tsnapshots[a.id] = asset\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...asset,\n\t\t\t\t\t\t\t...a,\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Delete one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteAssets(['asset1', 'asset2'])\n\t * ```\n\t *\n\t * @param ids - The assets to delete.\n\t *\n\t * @public\n\t */\n\tdeleteAssets(assets: TLAssetId[] | TLAsset[]): this {\n\t\tconst ids =\n\t\t\ttypeof assets[0] === 'string'\n\t\t\t\t? (assets as TLAssetId[])\n\t\t\t\t: (assets as TLAsset[]).map((a) => a.id)\n\t\tthis._deleteAssets(ids)\n\t\treturn this\n\t}\n\t/** @internal */\n\tprivate _deleteAssets = this.history.createCommand(\n\t\t'deleteAssets',\n\t\t(ids: TLAssetId[]) => {\n\t\t\tif (this.getInstanceState().isReadonly) return\n\t\t\tif (ids.length <= 0) return\n\n\t\t\tconst prev = compact(ids.map((id) => this.store.get(id)))\n\n\t\t\treturn { data: { ids, prev } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.remove(ids)\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put(prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Get an asset by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getAsset('asset1')\n\t * ```\n\t *\n\t * @param asset - The asset (or asset id) to get.\n\t *\n\t * @public\n\t */\n\tgetAsset(asset: TLAssetId | TLAsset): TLAsset | undefined {\n\t\treturn this.store.get(typeof asset === 'string' ? asset : asset.id) as TLAsset | undefined\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\t@computed\n\tprivate _getShapeGeometryCache(): ComputedCache<Geometry2d, TLShape> {\n\t\treturn this.store.createComputedCache(\n\t\t\t'bounds',\n\t\t\t(shape) => this.getShapeUtil(shape).getGeometry(shape),\n\t\t\t(a, b) => a.props === b.props\n\t\t)\n\t}\n\n\t/**\n\t * Get the geometry of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeGeometry(myShape)\n\t * editor.getShapeGeometry(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the geometry for.\n\t *\n\t * @public\n\t */\n\tgetShapeGeometry<T extends Geometry2d>(shape: TLShape | TLShapeId): T {\n\t\treturn this._getShapeGeometryCache().get(typeof shape === 'string' ? shape : shape.id)! as T\n\t}\n\n\t/** @internal */\n\t@computed private _getShapeHandlesCache(): ComputedCache<TLHandle[] | undefined, TLShape> {\n\t\treturn this.store.createComputedCache('handles', (shape) => {\n\t\t\treturn this.getShapeUtil(shape).getHandles?.(shape)\n\t\t})\n\t}\n\n\t/**\n\t * Get the handles (if any) for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeHandles(myShape)\n\t * editor.getShapeHandles(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the handles for.\n\t * @public\n\t */\n\tgetShapeHandles<T extends TLShape>(shape: T | T['id']): TLHandle[] | undefined {\n\t\treturn this._getShapeHandlesCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/**\n\t * Get the local transform for a shape as a matrix model. This transform reflects both its\n\t * translation (x, y) from from either its parent's top left corner, if the shape's parent is\n\t * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the\n\t * shape's rotation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeLocalTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the local transform for.\n\t *\n\t * @public\n\t */\n\tgetShapeLocalTransform(shape: TLShape | TLShapeId): Mat {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) throw Error('Editor.getTransform: shape not found')\n\t\treturn Mat.Identity().translate(freshShape.x, freshShape.y).rotate(freshShape.rotation)\n\t}\n\n\t/**\n\t * A cache of page transforms.\n\t *\n\t * @internal\n\t */\n\t@computed private _getShapePageTransformCache(): ComputedCache<Mat, TLShape> {\n\t\treturn this.store.createComputedCache<Mat, TLShape>('pageTransformCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) {\n\t\t\t\treturn this.getShapeLocalTransform(shape)\n\t\t\t}\n\n\t\t\t// If the shape's parent doesn't exist yet (e.g. when merging in changes from remote in the wrong order)\n\t\t\t// then we can't compute the transform yet, so just return the identity matrix.\n\t\t\t// In the future we should look at creating a store update mechanism that understands and preserves\n\t\t\t// ordering.\n\t\t\tconst parentTransform =\n\t\t\t\tthis._getShapePageTransformCache().get(shape.parentId) ?? Mat.Identity()\n\t\t\treturn Mat.Compose(parentTransform, this.getShapeLocalTransform(shape)!)\n\t\t})\n\t}\n\n\t/**\n\t * Get the local transform of a shape's parent as a matrix model.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeParentTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the parent transform for.\n\t *\n\t * @public\n\t */\n\tgetShapeParentTransform(shape: TLShape | TLShapeId): Mat {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape || isPageId(freshShape.parentId)) return Mat.Identity()\n\t\treturn this._getShapePageTransformCache().get(freshShape.parentId) ?? Mat.Identity()\n\t}\n\n\t/**\n\t * Get the transform of a shape in the current page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapePageTransform(myShape)\n\t * editor.getShapePageTransform(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the page transform for.\n\t *\n\t * @public\n\t */\n\tgetShapePageTransform(shape: TLShape | TLShapeId): Mat {\n\t\tconst id = typeof shape === 'string' ? shape : this.getShape(shape)!.id\n\t\treturn this._getShapePageTransformCache().get(id) ?? Mat.Identity()\n\t}\n\n\t/** @internal */\n\t@computed private _getShapePageBoundsCache(): ComputedCache<Box, TLShape> {\n\t\treturn this.store.createComputedCache<Box, TLShape>('pageBoundsCache', (shape) => {\n\t\t\tconst pageTransform = this._getShapePageTransformCache().get(shape.id)\n\n\t\t\tif (!pageTransform) return new Box()\n\n\t\t\tconst result = Box.FromPoints(\n\t\t\t\tMat.applyToPoints(pageTransform, this.getShapeGeometry(shape).vertices)\n\t\t\t)\n\n\t\t\treturn result\n\t\t})\n\t}\n\n\t/**\n\t * Get the bounds of a shape in the current page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapePageBounds(myShape)\n\t * editor.getShapePageBounds(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetShapePageBounds(shape: TLShape | TLShapeId): Box | undefined {\n\t\treturn this._getShapePageBoundsCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/**\n\t * A cache of clip paths used for clipping.\n\t *\n\t * @internal\n\t */\n\t@computed private _getShapeClipPathCache(): ComputedCache<string, TLShape> {\n\t\treturn this.store.createComputedCache<string, TLShape>('clipPathCache', (shape) => {\n\t\t\tconst pageMask = this._getShapeMaskCache().get(shape.id)\n\t\t\tif (!pageMask) return undefined\n\t\t\tif (pageMask.length === 0) {\n\t\t\t\treturn `polygon(0px 0px, 0px 0px, 0px 0px)`\n\t\t\t}\n\n\t\t\tconst pageTransform = this._getShapePageTransformCache().get(shape.id)\n\t\t\tif (!pageTransform) return undefined\n\n\t\t\tconst localMask = Mat.applyToPoints(Mat.Inverse(pageTransform), pageMask)\n\n\t\t\treturn `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(',')})`\n\t\t})\n\t}\n\n\t/**\n\t * Get the clip path for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const clipPath = editor.getShapeClipPath(shape)\n\t * const clipPath = editor.getShapeClipPath(shape.id)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the clip path for.\n\t *\n\t * @returns The clip path or undefined.\n\t *\n\t * @public\n\t */\n\tgetShapeClipPath(shape: TLShape | TLShapeId): string | undefined {\n\t\treturn this._getShapeClipPathCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/** @internal */\n\t@computed private _getShapeMaskCache(): ComputedCache<Vec[], TLShape> {\n\t\treturn this.store.createComputedCache('pageMaskCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) return undefined\n\n\t\t\tconst frameAncestors = this.getShapeAncestors(shape.id).filter((shape) =>\n\t\t\t\tthis.isShapeOfType<TLFrameShape>(shape, 'frame')\n\t\t\t)\n\n\t\t\tif (frameAncestors.length === 0) return undefined\n\n\t\t\tconst pageMask = frameAncestors\n\t\t\t\t.map<Vec[] | undefined>((s) =>\n\t\t\t\t\t// Apply the frame transform to the frame outline to get the frame outline in the current page space\n\t\t\t\t\tthis._getShapePageTransformCache()\n\t\t\t\t\t\t.get(s.id)!\n\t\t\t\t\t\t.applyToPoints(this.getShapeGeometry(s).vertices)\n\t\t\t\t)\n\t\t\t\t.reduce((acc, b) => {\n\t\t\t\t\tif (!(b && acc)) return undefined\n\t\t\t\t\tconst intersection = intersectPolygonPolygon(acc, b)\n\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\treturn intersection.map(Vec.Cast)\n\t\t\t\t\t}\n\t\t\t\t\treturn []\n\t\t\t\t})\n\n\t\t\treturn pageMask\n\t\t})\n\t}\n\n\t/**\n\t * Get the mask (in the current page space) for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const pageMask = editor.getShapeMask(shape.id)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the mask for.\n\t *\n\t * @returns The mask for the shape.\n\t *\n\t * @public\n\t */\n\tgetShapeMask(shape: TLShapeId | TLShape): VecLike[] | undefined {\n\t\treturn this._getShapeMaskCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/**\n\t * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the\n\t * shape were the child of a frame and was half way out of the frame, the bounds would be the half\n\t * of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeMaskedPageBounds(myShape)\n\t * editor.getShapeMaskedPageBounds(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape to get the masked bounds for.\n\t *\n\t * @public\n\t */\n\tgetShapeMaskedPageBounds(shape: TLShapeId | TLShape): Box | undefined {\n\t\tif (typeof shape !== 'string') shape = shape.id\n\t\tconst pageBounds = this._getShapePageBoundsCache().get(shape)\n\t\tif (!pageBounds) return\n\t\tconst pageMask = this._getShapeMaskCache().get(shape)\n\t\tif (pageMask) {\n\t\t\tif (pageMask.length === 0) return undefined\n\n\t\t\tconst { corners } = pageBounds\n\t\t\tif (corners.every((p, i) => p && Vec.Equals(p, pageMask[i]))) return pageBounds.clone()\n\n\t\t\t// todo: find out why intersect polygon polygon for identical polygons produces zero w/h intersections\n\t\t\tconst intersection = intersectPolygonPolygon(pageMask, corners)\n\t\t\tif (!intersection) return\n\t\t\treturn Box.FromPoints(intersection)\n\t\t}\n\n\t\treturn pageBounds\n\t}\n\n\t/**\n\t * Get the ancestors of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestors = editor.getShapeAncestors(myShape)\n\t * const ancestors = editor.getShapeAncestors(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the ancestors for.\n\t *\n\t * @public\n\t */\n\tgetShapeAncestors(shape: TLShapeId | TLShape, acc: TLShape[] = []): TLShape[] {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) return acc\n\t\tconst parentId = freshShape.parentId\n\t\tif (isPageId(parentId)) {\n\t\t\tacc.reverse()\n\t\t\treturn acc\n\t\t}\n\n\t\tconst parent = this.store.get(parentId)\n\t\tif (!parent) return acc\n\t\tacc.push(parent)\n\t\treturn this.getShapeAncestors(parent, acc)\n\t}\n\n\t/**\n\t * Find the first ancestor matching the given predicate\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestor = editor.findShapeAncestor(myShape)\n\t * const ancestor = editor.findShapeAncestor(myShape.id)\n\t * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')\n\t * ```\n\t *\n\t * @param shape - The shape to check the ancestors for.\n\t *\n\t * @public\n\t */\n\tfindShapeAncestor(\n\t\tshape: TLShape | TLShapeId,\n\t\tpredicate: (parent: TLShape) => boolean\n\t): TLShape | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) return\n\n\t\tconst parentId = freshShape.parentId\n\t\tif (isPageId(parentId)) return\n\n\t\tconst parent = this.getShape(parentId)\n\t\tif (!parent) return\n\t\treturn predicate(parent) ? parent : this.findShapeAncestor(parent, predicate)\n\t}\n\n\t/**\n\t * Returns true if the the given shape has the given ancestor.\n\t *\n\t * @param shape - The shape.\n\t * @param ancestorId - The id of the ancestor.\n\t *\n\t * @public\n\t */\n\thasAncestor(shape: TLShape | TLShapeId | undefined, ancestorId: TLShapeId): boolean {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id\n\t\tconst freshShape = id && this.getShape(id)\n\t\tif (!freshShape) return false\n\t\tif (freshShape.parentId === ancestorId) return true\n\t\treturn this.hasAncestor(this.getShapeParent(freshShape), ancestorId)\n\t}\n\n\t/**\n\t * Get the common ancestor of two or more shapes that matches a predicate.\n\t *\n\t * @param shapes - The shapes (or shape ids) to check.\n\t * @param predicate - The predicate to match.\n\t */\n\tfindCommonAncestor(\n\t\tshapes: TLShape[] | TLShapeId[],\n\t\tpredicate?: (shape: TLShape) => boolean\n\t): TLShapeId | undefined {\n\t\tif (shapes.length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst freshShapes = compact(ids.map((id) => this.getShape(id)))\n\n\t\tif (freshShapes.length === 1) {\n\t\t\tconst parentId = freshShapes[0].parentId\n\t\t\tif (isPageId(parentId)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn predicate ? this.findShapeAncestor(freshShapes[0], predicate)?.id : parentId\n\t\t}\n\n\t\tconst [nodeA, ...others] = freshShapes\n\t\tlet ancestor = this.getShapeParent(nodeA)\n\t\twhile (ancestor) {\n\t\t\t// TODO: this is not ideal, optimize\n\t\t\tif (predicate && !predicate(ancestor)) {\n\t\t\t\tancestor = this.getShapeParent(ancestor)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (others.every((shape) => this.hasAncestor(shape, ancestor!.id))) {\n\t\t\t\treturn ancestor!.id\n\t\t\t}\n\t\t\tancestor = this.getShapeParent(ancestor)\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Check whether a shape or its parent is locked.\n\t *\n\t * @param shape - The shape (or shape id) to check.\n\t *\n\t * @public\n\t */\n\tisShapeOrAncestorLocked(shape?: TLShape): boolean\n\tisShapeOrAncestorLocked(id?: TLShapeId): boolean\n\tisShapeOrAncestorLocked(arg?: TLShape | TLShapeId): boolean {\n\t\tconst shape = typeof arg === 'string' ? this.getShape(arg) : arg\n\t\tif (shape === undefined) return false\n\t\tif (shape.isLocked) return true\n\t\treturn this.isShapeOrAncestorLocked(this.getShapeParent(shape))\n\t}\n\n\t/**\n\t * The bounds of the current page (the common bounds of all of the shapes on the page).\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageBounds(): Box | undefined {\n\t\tlet commonBounds: Box | undefined\n\n\t\tthis.getCurrentPageShapeIds().forEach((shapeId) => {\n\t\t\tconst bounds = this.getShapeMaskedPageBounds(shapeId)\n\t\t\tif (!bounds) return\n\t\t\tif (!commonBounds) {\n\t\t\t\tcommonBounds = bounds.clone()\n\t\t\t} else {\n\t\t\t\tcommonBounds = commonBounds.expand(bounds)\n\t\t\t}\n\t\t})\n\n\t\treturn commonBounds\n\t}\n\n\t/**\n\t * Get the top-most selected shape at the given point, ignoring groups.\n\t *\n\t * @param point - The point to check.\n\t *\n\t * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.\n\t */\n\tgetSelectedShapeAtPoint(point: VecLike): TLShape | undefined {\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\treturn this.getCurrentPageShapesSorted()\n\t\t\t.filter((shape) => shape.type !== 'group' && selectedShapeIds.includes(shape.id))\n\t\t\t.reverse() // findlast\n\t\t\t.find((shape) => this.isPointInShape(shape, point, { hitInside: true, margin: 0 }))\n\t}\n\n\t/**\n\t * Get the shape at the current point.\n\t *\n\t * @param point - The point to check.\n\t * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.\n\t *\n\t * @returns The shape at the given point, or undefined if there is no shape at the point.\n\t */\n\tgetShapeAtPoint(\n\t\tpoint: VecLike,\n\t\topts = {} as {\n\t\t\trenderingOnly?: boolean\n\t\t\tmargin?: number\n\t\t\thitInside?: boolean\n\t\t\thitLabels?: boolean\n\t\t\thitFrameInside?: boolean\n\t\t\tfilter?: (shape: TLShape) => boolean\n\t\t}\n\t): TLShape | undefined {\n\t\tconst zoomLevel = this.getZoomLevel()\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\tconst {\n\t\t\tfilter,\n\t\t\tmargin = 0,\n\t\t\thitLabels = false,\n\t\t\thitInside = false,\n\t\t\thitFrameInside = false,\n\t\t} = opts\n\n\t\tlet inHollowSmallestArea = Infinity\n\t\tlet inHollowSmallestAreaHit: TLShape | null = null\n\n\t\tlet inMarginClosestToEdgeDistance = Infinity\n\t\tlet inMarginClosestToEdgeHit: TLShape | null = null\n\n\t\tconst shapesToCheck = (\n\t\t\topts.renderingOnly\n\t\t\t\t? this.getCurrentPageRenderingShapesSorted()\n\t\t\t\t: this.getCurrentPageShapesSorted()\n\t\t).filter((shape) => {\n\t\t\tif (this.isShapeOfType(shape, 'group')) return false\n\t\t\tconst pageMask = this.getShapeMask(shape)\n\t\t\tif (pageMask && !pointInPolygon(point, pageMask)) return false\n\t\t\tif (filter) return filter(shape)\n\t\t\treturn true\n\t\t})\n\n\t\tfor (let i = shapesToCheck.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapesToCheck[i]\n\t\t\tconst geometry = this.getShapeGeometry(shape)\n\t\t\tconst isGroup = geometry instanceof Group2d\n\n\t\t\tconst pointInShapeSpace = this.getPointInShapeSpace(shape, point)\n\n\t\t\t// Check labels first\n\t\t\tif (\n\t\t\t\tthis.isShapeOfType<TLArrowShape>(shape, 'arrow') ||\n\t\t\t\t(this.isShapeOfType<TLGeoShape>(shape, 'geo') && shape.props.fill === 'none')\n\t\t\t) {\n\t\t\t\tif (shape.props.text.trim()) {\n\t\t\t\t\t// let's check whether the shape has a label and check that\n\t\t\t\t\tfor (const childGeometry of (geometry as Group2d).children) {\n\t\t\t\t\t\tif (childGeometry.isLabel && childGeometry.isPointInBounds(pointInShapeSpace)) {\n\t\t\t\t\t\t\treturn shape\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isShapeOfType(shape, 'frame')) {\n\t\t\t\t// On the rare case that we've hit a frame, test again hitInside to be forced true;\n\t\t\t\t// this prevents clicks from passing through the body of a frame to shapes behhind it.\n\n\t\t\t\t// If the hit is within the frame's outer margin, then select the frame\n\t\t\t\tconst distance = geometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\tif (Math.abs(distance) <= margin) {\n\t\t\t\t\treturn inMarginClosestToEdgeHit || shape\n\t\t\t\t}\n\n\t\t\t\tif (geometry.hitTestPoint(pointInShapeSpace, 0, true)) {\n\t\t\t\t\t// Once we've hit a frame, we want to end the search. If we have hit a shape\n\t\t\t\t\t// already, then this would either be above the frame or a child of the frame,\n\t\t\t\t\t// so we want to return that. Otherwise, the point is in the empty space of the\n\t\t\t\t\t// frame. If `hitFrameInside` is true (e.g. used drawing an arrow into the\n\t\t\t\t\t// frame) we the frame itself; other wise, (e.g. when hovering or pointing)\n\t\t\t\t\t// we would want to return null.\n\t\t\t\t\treturn (\n\t\t\t\t\t\tinMarginClosestToEdgeHit ||\n\t\t\t\t\t\tinHollowSmallestAreaHit ||\n\t\t\t\t\t\t(hitFrameInside ? shape : undefined)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlet distance: number\n\n\t\t\tif (isGroup) {\n\t\t\t\tlet minDistance = Infinity\n\t\t\t\tfor (const childGeometry of geometry.children) {\n\t\t\t\t\tif (childGeometry.isLabel && !hitLabels) continue\n\n\t\t\t\t\t// hit test the all of the child geometries that aren't labels\n\t\t\t\t\tconst tDistance = childGeometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\t\tif (tDistance < minDistance) {\n\t\t\t\t\t\tminDistance = tDistance\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdistance = minDistance\n\t\t\t} else {\n\t\t\t\t// If the margin is zero and the geometry has a very small width or height,\n\t\t\t\t// then check the actual distance. This is to prevent a bug where straight\n\t\t\t\t// lines would never pass the broad phase (point-in-bounds) check.\n\t\t\t\tif (margin === 0 && (geometry.bounds.w < 1 || geometry.bounds.h < 1)) {\n\t\t\t\t\tdistance = geometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\t} else {\n\t\t\t\t\t// Broad phase\n\t\t\t\t\tif (geometry.bounds.containsPoint(pointInShapeSpace, margin)) {\n\t\t\t\t\t\t// Narrow phase (actual distance)\n\t\t\t\t\t\tdistance = geometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Failed the broad phase, geddafugaotta'ere!\n\t\t\t\t\t\tdistance = Infinity\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (geometry.isClosed) {\n\t\t\t\t// For closed shapes, the distance will be positive if outside of\n\t\t\t\t// the shape or negative if inside of the shape. If the distance\n\t\t\t\t// is greater than the margin, then it's a miss. Otherwise...\n\n\t\t\t\tif (distance <= margin) {\n\t\t\t\t\tif (geometry.isFilled || (isGroup && geometry.children[0].isFilled)) {\n\t\t\t\t\t\t// If the shape is filled, then it's a hit. Remember, we're\n\t\t\t\t\t\t// starting from the TOP-MOST shape in z-index order, so any\n\t\t\t\t\t\t// other hits would be occluded by the shape.\n\t\t\t\t\t\treturn inMarginClosestToEdgeHit || shape\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the shape is bigger than the viewport, then skip it.\n\t\t\t\t\t\tif (this.getShapePageBounds(shape)!.contains(viewportPageBounds)) continue\n\n\t\t\t\t\t\t// For hollow shapes...\n\t\t\t\t\t\tif (Math.abs(distance) < margin) {\n\t\t\t\t\t\t\t// We want to preference shapes where we're inside of the\n\t\t\t\t\t\t\t// shape margin; and we would want to hit the shape with the\n\t\t\t\t\t\t\t// edge closest to the point.\n\t\t\t\t\t\t\tif (Math.abs(distance) < inMarginClosestToEdgeDistance) {\n\t\t\t\t\t\t\t\tinMarginClosestToEdgeDistance = Math.abs(distance)\n\t\t\t\t\t\t\t\tinMarginClosestToEdgeHit = shape\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!inMarginClosestToEdgeHit) {\n\t\t\t\t\t\t\t// If we're not within margin distnce to any edge, and if the\n\t\t\t\t\t\t\t// shape is hollow, then we want to hit the shape with the\n\t\t\t\t\t\t\t// smallest area. (There's a bug here with self-intersecting\n\t\t\t\t\t\t\t// shapes, like a closed drawing of an \"8\", but that's a bigger\n\t\t\t\t\t\t\t// problem to solve.)\n\t\t\t\t\t\t\tconst { area } = geometry\n\t\t\t\t\t\t\tif (area < inHollowSmallestArea) {\n\t\t\t\t\t\t\t\tinHollowSmallestArea = area\n\t\t\t\t\t\t\t\tinHollowSmallestAreaHit = shape\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For open shapes (e.g. lines or draw shapes) always use the margin.\n\t\t\t\t// If the distance is less than the margin, return the shape as the hit.\n\t\t\t\tif (distance < HIT_TEST_MARGIN / zoomLevel) {\n\t\t\t\t\treturn shape\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't hit any filled shapes or frames, then return either\n\t\t// the shape who we hit within the margin (and of those, the one that\n\t\t// had the shortest distance between the point and the shape edge),\n\t\t// or else the hollow shape with the smallest area\u2014or if we didn't hit\n\t\t// any margins or any hollow shapes, then null.\n\t\treturn inMarginClosestToEdgeHit || inHollowSmallestAreaHit || undefined\n\t}\n\n\t/**\n\t * Get the shapes, if any, at a given page point.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapesAtPoint({ x: 100, y: 100 })\n\t * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, exact: true })\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t *\n\t * @public\n\t */\n\tgetShapesAtPoint(\n\t\tpoint: VecLike,\n\t\topts = {} as { margin?: number; hitInside?: boolean }\n\t): TLShape[] {\n\t\treturn this.getCurrentPageShapes().filter((shape) => this.isPointInShape(shape, point, opts))\n\t}\n\n\t/**\n\t * Test whether a point (in the current page space) will will a shape. This method takes into account masks,\n\t * such as when a shape is the child of a frame and is partially clipped by the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isPointInShape({ x: 100, y: 100 }, myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to test against.\n\t * @param point - The page point to test (in the current page space).\n\t * @param hitInside - Whether to count as a hit if the point is inside of a closed shape.\n\t *\n\t * @public\n\t */\n\n\tisPointInShape(\n\t\tshape: TLShape | TLShapeId,\n\t\tpoint: VecLike,\n\t\topts = {} as {\n\t\t\tmargin?: number\n\t\t\thitInside?: boolean\n\t\t}\n\t): boolean {\n\t\tconst { hitInside = false, margin = 0 } = opts\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\t// If the shape is masked, and if the point falls outside of that\n\t\t// mask, then it's defintely a miss\u2014we don't need to test further.\n\t\tconst pageMask = this.getShapeMask(id)\n\t\tif (pageMask && !pointInPolygon(point, pageMask)) return false\n\n\t\treturn this.getShapeGeometry(id).hitTestPoint(\n\t\t\tthis.getPointInShapeSpace(shape, point),\n\t\t\tmargin,\n\t\t\thitInside\n\t\t)\n\t}\n\n\t/**\n\t * Convert a point in the current page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInShapeSpace(shape: TLShape | TLShapeId, point: VecLike): Vec {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\treturn this._getShapePageTransformCache().get(id)!.clone().invert().applyToPoint(point)\n\t}\n\n\t/**\n\t * Convert a delta in the current page space to a point in the local space of a shape's parent.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInParentSpace(shape: TLShapeId | TLShape, point: VecLike): Vec {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) return new Vec(0, 0)\n\t\tif (isPageId(freshShape.parentId)) return Vec.From(point)\n\n\t\tconst parentTransform = this.getShapePageTransform(freshShape.parentId)\n\t\tif (!parentTransform) return Vec.From(point)\n\t\treturn parentTransform.clone().invert().applyToPoint(point)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageShapes(): TLShape[] {\n\t\treturn Array.from(this.getCurrentPageShapeIds(), (id) => this.store.get(id)! as TLShape)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageShapesSorted(): TLShape[] {\n\t\t// todo: consider making into a function call that includes options for selected-only, rendering, etc.\n\t\t// todo: consider making a derivation or something, or merging with rendering shapes\n\t\tconst shapes = new Set(this.getCurrentPageShapes().sort(sortByIndex))\n\n\t\tconst results: TLShape[] = []\n\n\t\tfunction pushShapeWithDescendants(shape: TLShape): void {\n\t\t\tresults.push(shape)\n\t\t\tshapes.delete(shape)\n\n\t\t\tshapes.forEach((otherShape) => {\n\t\t\t\tif (otherShape.parentId === shape.id) {\n\t\t\t\t\tpushShapeWithDescendants(otherShape)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst parent = this.getShape(shape.parentId)\n\t\t\tif (!isShape(parent)) {\n\t\t\t\tpushShapeWithDescendants(shape)\n\t\t\t}\n\t\t})\n\n\t\treturn results\n\t}\n\n\t/**\n\t * An array containing all of the rendering shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageRenderingShapesSorted(): TLShape[] {\n\t\treturn this.getRenderingShapes()\n\t\t\t.filter(({ isCulled }) => !isCulled)\n\t\t\t.sort((a, b) => a.index - b.index)\n\t\t\t.map(({ shape }) => shape)\n\t}\n\n\t/**\n\t * Get whether a shape matches the type of a TLShapeUtil.\n\t *\n\t * @example\n\t * ```ts\n\t * const isArrowShape = isShapeOfType<TLArrowShape>(someShape, 'arrow')\n\t * ```\n\t *\n\t * @param util - the TLShapeUtil constructor to test against\n\t * @param shape - the shape to test\n\t *\n\t * @public\n\t */\n\tisShapeOfType<T extends TLUnknownShape>(shape: TLUnknownShape, type: T['type']): shape is T\n\tisShapeOfType<T extends TLUnknownShape>(\n\t\tshapeId: TLUnknownShape['id'],\n\t\ttype: T['type']\n\t): shapeId is T['id']\n\tisShapeOfType<T extends TLUnknownShape>(\n\t\targ: TLUnknownShape | TLUnknownShape['id'],\n\t\ttype: T['type']\n\t) {\n\t\tconst shape = typeof arg === 'string' ? this.getShape(arg)! : arg\n\t\treturn shape.type === type\n\t}\n\n\t/**\n\t * Get a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShape('box1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to get.\n\t *\n\t * @public\n\t */\n\tgetShape<T extends TLShape = TLShape>(shape: TLShape | TLParentId): T | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tif (!isShapeId(id)) return undefined\n\t\treturn this.store.get(id) as T\n\t}\n\n\t/**\n\t * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of\n\t * the page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeParent(myShape)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetShapeParent(shape?: TLShape | TLShapeId): TLShape | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id\n\t\tif (!id) return undefined\n\t\tconst freshShape = this.getShape(id)\n\t\tif (freshShape === undefined || !isShapeId(freshShape.parentId)) return undefined\n\t\treturn this.store.get(freshShape.parentId)\n\t}\n\n\t/**\n\t * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an\n\t * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns\n\t * undefined.\n\t *\n\t * @internal\n\t */\n\tprivate getShapeNearestSibling(\n\t\tsiblingShape: TLShape,\n\t\ttargetShape: TLShape | undefined\n\t): TLShape | undefined {\n\t\tif (!targetShape) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (targetShape.parentId === siblingShape.parentId) {\n\t\t\treturn targetShape\n\t\t}\n\n\t\tconst ancestor = this.findShapeAncestor(\n\t\t\ttargetShape,\n\t\t\t(ancestor) => ancestor.parentId === siblingShape.parentId\n\t\t)\n\n\t\treturn ancestor\n\t}\n\n\t/**\n\t * Get whether the given shape is the descendant of the given page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isShapeInPage(myShape)\n\t * editor.isShapeInPage(myShape, 'page1')\n\t * ```\n\t *\n\t * @param shape - The shape to check.\n\t * @param pageId - The id of the page to check against. Defaults to the current page.\n\t *\n\t * @public\n\t */\n\tisShapeInPage(shape: TLShape | TLShapeId, pageId = this.getCurrentPageId()): boolean {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst shapeToCheck = this.getShape(id)\n\t\tif (!shapeToCheck) return false\n\n\t\tlet shapeIsInPage = false\n\n\t\tif (shapeToCheck.parentId === pageId) {\n\t\t\tshapeIsInPage = true\n\t\t} else {\n\t\t\tlet parent = this.getShape(shapeToCheck.parentId)\n\t\t\tisInPageSearch: while (parent) {\n\t\t\t\tif (parent.parentId === pageId) {\n\t\t\t\t\tshapeIsInPage = true\n\t\t\t\t\tbreak isInPageSearch\n\t\t\t\t}\n\t\t\t\tparent = this.getShape(parent.parentId)\n\t\t\t}\n\t\t}\n\n\t\treturn shapeIsInPage\n\t}\n\n\t/**\n\t * Get the id of the containing page for a given shape.\n\t *\n\t * @param shape - The shape to get the page id for.\n\t *\n\t * @returns The id of the page that contains the shape, or undefined if the shape is undefined.\n\t *\n\t * @public\n\t */\n\tgetAncestorPageId(shape?: TLShape | TLShapeId): TLPageId | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id\n\t\tconst _shape = id && this.getShape(id)\n\t\tif (!_shape) return undefined\n\t\tif (isPageId(_shape.parentId)) {\n\t\t\treturn _shape.parentId\n\t\t} else {\n\t\t\treturn this.getAncestorPageId(this.getShape(_shape.parentId))\n\t\t}\n\t}\n\n\t// Parents and children\n\n\t/**\n\t * A cache of parents to children.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _parentIdsToChildIds: ReturnType<typeof parentsToChildren>\n\n\t/**\n\t * Reparent shapes to a new parent. This operation preserves the shape's current page positions /\n\t * rotations.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.reparentShapes([box1, box2], 'frame1')\n\t * editor.reparentShapes([box1.id, box2.id], 'frame1')\n\t * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) of the shapes to reparent.\n\t * @param parentId - The id of the new parent shape.\n\t * @param insertIndex - The index to insert the children.\n\t *\n\t * @public\n\t */\n\treparentShapes(shapes: TLShapeId[] | TLShape[], parentId: TLParentId, insertIndex?: IndexKey) {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string' ? (shapes as TLShapeId[]) : shapes.map((s) => (s as TLShape).id)\n\t\tif (ids.length === 0) return this\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tconst parentTransform = isPageId(parentId)\n\t\t\t? Mat.Identity()\n\t\t\t: this.getShapePageTransform(parentId)!\n\n\t\tconst parentPageRotation = parentTransform.rotation()\n\n\t\tlet indices: IndexKey[] = []\n\n\t\tconst sibs = compact(this.getSortedChildIdsForParent(parentId).map((id) => this.getShape(id)))\n\n\t\tif (insertIndex) {\n\t\t\tconst sibWithInsertIndex = sibs.find((s) => s.index === insertIndex)\n\t\t\tif (sibWithInsertIndex) {\n\t\t\t\t// If there's a sibling with the same index as the insert index...\n\t\t\t\tconst sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1]\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the sibling has a sibling above it, insert the shapes\n\t\t\t\t\t// between the sibling and its sibling above it.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Or if the sibling is the top sibling, insert the shapes\n\t\t\t\t\t// above the sibling\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If there's no collision, then we can start at the insert index\n\t\t\t\tconst sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex)\n\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the siblings include a sibling with a higher index, insert the shapes\n\t\t\t\t\t// between the insert index and the sibling with the higher index.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, we're at the top of the order, so insert the shapes above\n\t\t\t\t\t// the insert index.\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If insert index is not specified, start the index at the top.\n\t\t\tconst sib = sibs.length && sibs[sibs.length - 1]\n\t\t\tindices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length)\n\t\t}\n\n\t\tconst invertedParentTransform = parentTransform.clone().invert()\n\n\t\tconst shapesToReparent = compact(ids.map((id) => this.getShape(id)))\n\n\t\t// The user is allowed to re-parent locked shapes. Unintutive? Yeah! But there are plenty of\n\t\t// times when a locked shape's parent is deleted... and we need to put that shape somewhere!\n\t\tconst lockedShapes = shapesToReparent.filter((shape) => shape.isLocked)\n\n\t\tif (lockedShapes.length) {\n\t\t\t// If we have locked shapes, unlock them before we update them\n\t\t\tthis.updateShapes(lockedShapes.map(({ id, type }) => ({ id, type, isLocked: false })))\n\t\t}\n\n\t\tfor (let i = 0; i < shapesToReparent.length; i++) {\n\t\t\tconst shape = shapesToReparent[i]\n\n\t\t\tconst pageTransform = this.getShapePageTransform(shape)!\n\t\t\tif (!pageTransform) continue\n\n\t\t\tconst pagePoint = pageTransform.point()\n\t\t\tif (!pagePoint) continue\n\n\t\t\tconst newPoint = invertedParentTransform.applyToPoint(pagePoint)\n\t\t\tconst newRotation = pageTransform.rotation() - parentPageRotation\n\n\t\t\tchanges.push({\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tparentId: parentId,\n\t\t\t\tx: newPoint.x,\n\t\t\t\ty: newPoint.y,\n\t\t\t\trotation: newRotation,\n\t\t\t\tindex: indices[i],\n\t\t\t\tisLocked: shape.isLocked, // this will re-lock locked shapes\n\t\t\t})\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the index above the highest child of a given parent.\n\t *\n\t * @param parentId - The id of the parent.\n\t *\n\t * @returns The index.\n\t *\n\t * @public\n\t */\n\tgetHighestIndexForParent(parent: TLParentId | TLPage | TLShape): IndexKey {\n\t\tconst parentId = typeof parent === 'string' ? parent : parent.id\n\t\tconst children = this._parentIdsToChildIds.get()[parentId]\n\n\t\tif (!children || children.length === 0) {\n\t\t\treturn 'a1' as IndexKey\n\t\t}\n\t\tconst shape = this.getShape(children[children.length - 1])!\n\t\treturn getIndexAbove(shape.index)\n\t}\n\n\t/**\n\t * A cache of children for each parent.\n\t *\n\t * @internal\n\t */\n\tprivate _childIdsCache = new WeakMapCache<any[], TLShapeId[]>()\n\n\t/**\n\t * Get an array of all the children of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getSortedChildIdsForParent('frame1')\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t *\n\t * @public\n\t */\n\tgetSortedChildIdsForParent(parent: TLParentId | TLPage | TLShape): TLShapeId[] {\n\t\tconst parentId = typeof parent === 'string' ? parent : parent.id\n\t\tconst ids = this._parentIdsToChildIds.get()[parentId]\n\t\tif (!ids) return EMPTY_ARRAY\n\t\treturn this._childIdsCache.get(ids, () => ids)\n\t}\n\n\t/**\n\t * Run a visitor function for all descendants of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.visitDescendants('frame1', myCallback)\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t * @param visitor - The visitor function.\n\t *\n\t * @public\n\t */\n\tvisitDescendants(\n\t\tparent: TLParentId | TLPage | TLShape,\n\t\tvisitor: (id: TLShapeId) => void | false\n\t): this {\n\t\tconst parentId = typeof parent === 'string' ? parent : parent.id\n\t\tconst children = this.getSortedChildIdsForParent(parentId)\n\t\tfor (const id of children) {\n\t\t\tif (visitor(id) === false) continue\n\t\t\tthis.visitDescendants(id, visitor)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the shape ids of all descendants of the given shapes (including the shapes themselves).\n\t *\n\t * @param ids - The ids of the shapes to get descendants of.\n\t *\n\t * @returns The decscendant ids.\n\t *\n\t * @public\n\t */\n\tgetShapeAndDescendantIds(ids: TLShapeId[]): Set<TLShapeId> {\n\t\tconst idsToInclude = new Set<TLShapeId>()\n\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tif (idsToInclude.has(id)) continue\n\t\t\tidsToInclude.add(id)\n\t\t\tfor (const childId of this.getSortedChildIdsForParent(id)) {\n\t\t\t\tidsToCheck.push(childId)\n\t\t\t}\n\t\t}\n\n\t\treturn idsToInclude\n\t}\n\n\t/**\n\t * Get the shape that some shapes should be dropped on at a given point.\n\t *\n\t * @param point - The point to find the parent for.\n\t * @param droppingShapes - The shapes that are being dropped.\n\t *\n\t * @returns The shape to drop on.\n\t *\n\t * @public\n\t */\n\tgetDroppingOverShape(point: VecLike, droppingShapes: TLShape[] = []) {\n\t\t// starting from the top...\n\t\tconst currentPageShapesSorted = this.getCurrentPageShapesSorted()\n\t\tfor (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {\n\t\t\tconst shape = currentPageShapesSorted[i]\n\n\t\t\tif (\n\t\t\t\t// only allow shapes that can receive children\n\t\t\t\t!this.getShapeUtil(shape).canDropShapes(shape, droppingShapes) ||\n\t\t\t\t// don't allow dropping a shape on itself or one of it's children\n\t\t\t\tdroppingShapes.find((s) => s.id === shape.id || this.hasAncestor(shape, s.id))\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Only allow dropping into the masked page bounds of the shape, e.g. when a frame is\n\t\t\t// partially clipped by its own parent frame\n\t\t\tconst maskedPageBounds = this.getShapeMaskedPageBounds(shape.id)\n\n\t\t\tif (\n\t\t\t\tmaskedPageBounds &&\n\t\t\t\tmaskedPageBounds.containsPoint(point) &&\n\t\t\t\tthis.getShapeGeometry(shape).hitTestPoint(this.getPointInShapeSpace(shape, point), 0, true)\n\t\t\t) {\n\t\t\t\treturn shape\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the shape that should be selected when you click on a given shape, assuming there is\n\t * nothing already selected. It will not return anything higher than or including the current\n\t * focus layer.\n\t *\n\t * @param shape - The shape to get the outermost selectable shape for.\n\t * @param filter - A function to filter the selectable shapes.\n\t *\n\t * @returns The outermost selectable shape.\n\t *\n\t * @public\n\t */\n\tgetOutermostSelectableShape(\n\t\tshape: TLShape | TLShapeId,\n\t\tfilter?: (shape: TLShape) => boolean\n\t): TLShape {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)!\n\t\tlet match = freshShape\n\t\tlet node = freshShape as TLShape | undefined\n\n\t\tconst focusedGroup = this.getFocusedGroup()\n\n\t\twhile (node) {\n\t\t\tif (\n\t\t\t\tthis.isShapeOfType<TLGroupShape>(node, 'group') &&\n\t\t\t\tfocusedGroup?.id !== node.id &&\n\t\t\t\t!this.hasAncestor(focusedGroup, node.id) &&\n\t\t\t\t(filter?.(node) ?? true)\n\t\t\t) {\n\t\t\t\tmatch = node\n\t\t\t} else if (focusedGroup?.id === node.id) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = this.getShapeParent(node)\n\t\t}\n\n\t\treturn match\n\t}\n\n\t/* -------------------- Commands -------------------- */\n\n\t/**\n\t * Rotate shapes by a delta in radians.\n\t * Note: Currently, this assumes that the shapes are your currently selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)\n\t * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) of the shapes to move.\n\t * @param delta - The delta in radians to apply to the selection rotation.\n\t */\n\trotateShapesBy(shapes: TLShapeId[] | TLShape[], delta: number): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length <= 0) return this\n\n\t\tconst snapshot = getRotationSnapshot({ editor: this })\n\t\tif (!snapshot) return this\n\t\tapplyRotationToSnapshotShapes({ delta, snapshot, editor: this, stage: 'one-off' })\n\n\t\treturn this\n\t}\n\n\tprivate getChangesToTranslateShape(initialShape: TLShape, newShapeCoords: VecLike): TLShape {\n\t\tlet workingShape = initialShape\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tworkingShape = applyPartialToShape(\n\t\t\tworkingShape,\n\t\t\tutil.onTranslateStart?.(workingShape) ?? undefined\n\t\t)\n\n\t\tworkingShape = applyPartialToShape(workingShape, {\n\t\t\tid: initialShape.id,\n\t\t\ttype: initialShape.type,\n\t\t\tx: newShapeCoords.x,\n\t\t\ty: newShapeCoords.y,\n\t\t})\n\n\t\tworkingShape = applyPartialToShape(\n\t\t\tworkingShape,\n\t\t\tutil.onTranslate?.(initialShape, workingShape) ?? undefined\n\t\t)\n\n\t\tworkingShape = applyPartialToShape(\n\t\t\tworkingShape,\n\t\t\tutil.onTranslateEnd?.(initialShape, workingShape) ?? undefined\n\t\t)\n\n\t\treturn workingShape\n\t}\n\n\t/**\n\t * Move shapes by a delta.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })\n\t * editor.nudgeShapes(editor.getSelectedShapes(), { x: 8, y: 8 }, { squashing: true })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t * @param direction - The direction in which to move the shapes.\n\t * @param historyOptions - The history options for the change.\n\t */\n\tnudgeShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\toffset: VecLike,\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length <= 0) return this\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShape(id)!\n\t\t\tconst localDelta = Vec.From(offset)\n\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\tif (parentTransform) localDelta.rot(-parentTransform.rotation())\n\n\t\t\tchanges.push(this.getChangesToTranslateShape(shape, localDelta.add(shape)))\n\t\t}\n\n\t\tthis.updateShapes(changes, {\n\t\t\tsquashing: true,\n\t\t\t...historyOptions,\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Duplicate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })\n\t * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to duplicate.\n\t * @param offset - The offset (in pixels) to apply to the duplicated shapes.\n\t *\n\t * @public\n\t */\n\tduplicateShapes(shapes: TLShapeId[] | TLShape[], offset?: VecLike): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length <= 0) return this\n\n\t\tconst initialIds = new Set(ids)\n\t\tconst idsToCreate: TLShapeId[] = []\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tidsToCreate.push(id)\n\t\t\tthis.getSortedChildIdsForParent(id).forEach((childId) => idsToCheck.push(childId))\n\t\t}\n\n\t\tidsToCreate.reverse()\n\n\t\tconst idsMap = new Map<any, TLShapeId>(idsToCreate.map((id) => [id, createShapeId()]))\n\n\t\tconst shapesToCreate = compact(\n\t\t\tidsToCreate.map((id) => {\n\t\t\t\tconst shape = this.getShape(id)\n\n\t\t\t\tif (!shape) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tconst createId = idsMap.get(id)!\n\n\t\t\t\tlet ox = 0\n\t\t\t\tlet oy = 0\n\n\t\t\t\tif (offset && initialIds.has(id)) {\n\t\t\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\t\t\tconst vec = new Vec(offset.x, offset.y).rot(-parentTransform!.rotation())\n\t\t\t\t\tox = vec.x\n\t\t\t\t\toy = vec.y\n\t\t\t\t}\n\n\t\t\t\tconst parentId = shape.parentId ?? this.getCurrentPageId()\n\t\t\t\tconst siblings = this.getSortedChildIdsForParent(parentId)\n\t\t\t\tconst currentIndex = siblings.indexOf(shape.id)\n\t\t\t\tconst siblingAboveId = siblings[currentIndex + 1]\n\t\t\t\tconst siblingAbove = siblingAboveId ? this.getShape(siblingAboveId) : null\n\n\t\t\t\tconst index = siblingAbove\n\t\t\t\t\t? getIndexBetween(shape.index, siblingAbove.index)\n\t\t\t\t\t: getIndexAbove(shape.index)\n\n\t\t\t\tlet newShape: TLShape = deepCopy(shape)\n\n\t\t\t\tif (\n\t\t\t\t\tthis.isShapeOfType<TLArrowShape>(shape, 'arrow') &&\n\t\t\t\t\tthis.isShapeOfType<TLArrowShape>(newShape, 'arrow')\n\t\t\t\t) {\n\t\t\t\t\tconst info = this.getArrowInfo(shape)\n\t\t\t\t\tlet newStartShapeId: TLShapeId | undefined = undefined\n\t\t\t\t\tlet newEndShapeId: TLShapeId | undefined = undefined\n\n\t\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\t\tnewStartShapeId = idsMap.get(shape.props.start.boundShapeId)\n\n\t\t\t\t\t\tif (!newStartShapeId) {\n\t\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\t\tconst { x, y } = info.start.point\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\t\tnewEndShapeId = idsMap.get(shape.props.end.boundShapeId)\n\t\t\t\t\t\tif (!newEndShapeId) {\n\t\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\t\tconst { x, y } = info.end.point\n\t\t\t\t\t\t\t\tnewShape.props.end = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst infoAfter = getIsArrowStraight(newShape)\n\t\t\t\t\t\t? getStraightArrowInfo(this, newShape)\n\t\t\t\t\t\t: getCurvedArrowInfo(this, newShape)\n\n\t\t\t\t\tif (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {\n\t\t\t\t\t\tconst mpA = Vec.Med(info.start.handle, info.end.handle)\n\t\t\t\t\t\tconst distA = Vec.Dist(info.middle, mpA)\n\t\t\t\t\t\tconst distB = Vec.Dist(infoAfter.middle, mpA)\n\t\t\t\t\t\tif (newShape.props.bend < 0) {\n\t\t\t\t\t\t\tnewShape.props.bend += distB - distA\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewShape.props.bend -= distB - distA\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newShape.props.start.type === 'binding' && newStartShapeId) {\n\t\t\t\t\t\tnewShape.props.start.boundShapeId = newStartShapeId\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newShape.props.end.type === 'binding' && newEndShapeId) {\n\t\t\t\t\t\tnewShape.props.end.boundShapeId = newEndShapeId\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewShape = { ...newShape, id: createId, x: shape.x + ox, y: shape.y + oy, index }\n\n\t\t\t\treturn newShape\n\t\t\t})\n\t\t)\n\n\t\tshapesToCreate.forEach((shape) => {\n\t\t\tif (isShapeId(shape.parentId)) {\n\t\t\t\tif (idsMap.has(shape.parentId)) {\n\t\t\t\t\tshape.parentId = idsMap.get(shape.parentId)!\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.history.batch(() => {\n\t\t\tconst maxShapesReached =\n\t\t\t\tshapesToCreate.length + this.getCurrentPageShapeIds().size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst newShapes = maxShapesReached\n\t\t\t\t? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - this.getCurrentPageShapeIds().size)\n\t\t\t\t: shapesToCreate\n\n\t\t\tconst ids = newShapes.map((s) => s.id)\n\n\t\t\tthis.createShapes(newShapes)\n\t\t\tthis.setSelectedShapes(ids)\n\n\t\t\tif (offset !== undefined) {\n\t\t\t\t// If we've offset the duplicated shapes, check to see whether their new bounds is entirely\n\t\t\t\t// contained in the current viewport. If not, then animate the camera to be centered on the\n\t\t\t\t// new shapes.\n\t\t\t\tconst selectionPageBounds = this.getSelectionPageBounds()\n\t\t\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\t\t\tif (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {\n\t\t\t\t\tthis.centerOnPoint(selectionPageBounds.center, {\n\t\t\t\t\t\tduration: ANIMATION_MEDIUM_MS,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes to page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.moveShapesToPage(['box1', 'box2'], 'page1')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) of the shapes to move.\n\t * @param pageId - The id of the page where the shapes will be moved.\n\t *\n\t * @public\n\t */\n\tmoveShapesToPage(shapes: TLShapeId[] | TLShape[], pageId: TLPageId): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length === 0) return this\n\t\tif (this.getInstanceState().isReadonly) return this\n\n\t\tconst currentPageId = this.getCurrentPageId()\n\n\t\tif (pageId === currentPageId) return this\n\t\tif (!this.store.has(pageId)) return this\n\n\t\t// Basically copy the shapes\n\t\tconst content = this.getContentFromCurrentPage(ids)\n\n\t\t// Just to be sure\n\t\tif (!content) return this\n\n\t\t// If there is no space on pageId, or if the selected shapes\n\t\t// would take the new page above the limit, don't move the shapes\n\t\tif (this.getPageShapeIds(pageId).size + content.shapes.length > MAX_SHAPES_PER_PAGE) {\n\t\t\talertMaxShapes(this, pageId)\n\t\t\treturn this\n\t\t}\n\n\t\tconst fromPageZ = this.getCamera().z\n\n\t\tthis.history.batch(() => {\n\t\t\t// Delete the shapes on the current page\n\t\t\tthis.deleteShapes(ids)\n\n\t\t\t// Move to the next page\n\t\t\tthis.setCurrentPage(pageId)\n\n\t\t\t// Put the shape content onto the new page; parents and indices will\n\t\t\t// be taken care of by the putContent method; make sure to pop any focus\n\t\t\t// layers so that the content will be put onto the page.\n\t\t\tthis.setFocusedGroup(null)\n\t\t\tthis.selectNone()\n\t\t\tthis.putContentOntoCurrentPage(content, {\n\t\t\t\tselect: true,\n\t\t\t\tpreserveIds: true,\n\t\t\t\tpreservePosition: true,\n\t\t\t})\n\n\t\t\t// Force the new page's camera to be at the same zoom level as the\n\t\t\t// \"from\" page's camera, then center the \"to\" page's camera on the\n\t\t\t// pasted shapes\n\t\t\tthis.setCamera({ ...this.getCamera(), z: fromPageZ })\n\t\t\tthis.centerOnPoint(this.getSelectionRotatedPageBounds()!.center)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.\n\t *\n\t * @param shapes - The shapes (or shape ids) to toggle.\n\t *\n\t * @public\n\t */\n\ttoggleLock(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getInstanceState().isReadonly || ids.length === 0) return this\n\n\t\tlet allLocked = true,\n\t\t\tallUnlocked = true\n\t\tconst shapesToToggle: TLShape[] = []\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShape(id)\n\t\t\tif (shape) {\n\t\t\t\tshapesToToggle.push(shape)\n\t\t\t\tif (shape.isLocked) {\n\t\t\t\t\tallUnlocked = false\n\t\t\t\t} else {\n\t\t\t\t\tallLocked = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.batch(() => {\n\t\t\tif (allUnlocked) {\n\t\t\t\tthis.updateShapes(\n\t\t\t\t\tshapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))\n\t\t\t\t)\n\t\t\t\tthis.setSelectedShapes([])\n\t\t\t} else if (allLocked) {\n\t\t\t\tthis.updateShapes(\n\t\t\t\t\tshapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.updateShapes(\n\t\t\t\t\tshapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes to the back of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendToBack(['id1', 'id2'])\n\t * editor.sendToBack(box1, box2)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t *\n\t * @public\n\t */\n\tsendToBack(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'toBack', ids as TLShapeId[])\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes backward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendBackward(['id1', 'id2'])\n\t * editor.sendBackward([box1, box2])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t *\n\t * @public\n\t */\n\tsendBackward(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'backward', ids as TLShapeId[])\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes forward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringForward(['id1', 'id2'])\n\t * editor.bringForward(box1,  box2)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t *\n\t * @public\n\t */\n\tbringForward(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'forward', ids as TLShapeId[])\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes to the front of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringToFront(['id1', 'id2'])\n\t * editor.bringToFront([box1, box2])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t *\n\t * @public\n\t */\n\tbringToFront(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'toFront', ids as TLShapeId[])\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Flip shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.flipShapes([box1, box2], 'horizontal', 32)\n\t * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)\n\t * ```\n\t *\n\t * @param shapes - The ids of the shapes to flip.\n\t * @param operation - Whether to flip horizontally or vertically.\n\t *\n\t * @public\n\t */\n\tflipShapes(shapes: TLShapeId[] | TLShape[], operation: 'horizontal' | 'vertical'): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getInstanceState().isReadonly) return this\n\n\t\tlet shapesToFlip = compact(ids.map((id) => this.getShape(id)))\n\n\t\tif (!shapesToFlip.length) return this\n\n\t\tshapesToFlip = compact(\n\t\t\tshapesToFlip\n\t\t\t\t.map((shape) => {\n\t\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\t\treturn this.getSortedChildIdsForParent(shape.id).map((id) => this.getShape(id))\n\t\t\t\t\t}\n\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t\t.flat()\n\t\t)\n\n\t\tconst scaleOriginPage = Box.Common(\n\t\t\tcompact(shapesToFlip.map((id) => this.getShapePageBounds(id)))\n\t\t).center\n\n\t\tthis.batch(() => {\n\t\t\tfor (const shape of shapesToFlip) {\n\t\t\t\tconst bounds = this.getShapeGeometry(shape).bounds\n\t\t\t\tconst initialPageTransform = this.getShapePageTransform(shape.id)\n\t\t\t\tif (!initialPageTransform) continue\n\t\t\t\tthis.resizeShape(\n\t\t\t\t\tshape.id,\n\t\t\t\t\t{ x: operation === 'horizontal' ? -1 : 1, y: operation === 'vertical' ? -1 : 1 },\n\t\t\t\t\t{\n\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\tinitialPageTransform,\n\t\t\t\t\t\tinitialShape: shape,\n\t\t\t\t\t\tmode: 'scale_shape',\n\t\t\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stack shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stackShapes([box1, box2], 'horizontal', 32)\n\t * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal', 32)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to stack.\n\t * @param operation - Whether to stack horizontally or vertically.\n\t * @param gap - The gap to leave between shapes.\n\t *\n\t * @public\n\t */\n\tstackShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\toperation: 'horizontal' | 'vertical',\n\t\tgap: number\n\t): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tif (this.getInstanceState().isReadonly) return this\n\n\t\tconst shapesToStack = compact(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShape(id)) // always fresh shapes\n\t\t\t\t.filter((shape) => {\n\t\t\t\t\tif (!shape) return false\n\n\t\t\t\t\tif (this.isShapeOfType<TLArrowShape>(shape, 'arrow')) {\n\t\t\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t)\n\n\t\tconst len = shapesToStack.length\n\n\t\tif ((gap === 0 && len < 3) || len < 2) return this\n\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapesToStack.map((shape) => [shape.id, this.getShapePageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tdim = 'height'\n\t\t}\n\n\t\tlet shapeGap: number\n\n\t\tif (gap === 0) {\n\t\t\tconst gaps: { gap: number; count: number }[] = []\n\n\t\t\tshapesToStack.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])\n\n\t\t\t// Collect all of the gaps between shapes. We want to find\n\t\t\t// patterns (equal gaps between shapes) and use the most common\n\t\t\t// one as the gap for all of the shapes.\n\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\tconst shape = shapesToStack[i]\n\t\t\t\tconst nextShape = shapesToStack[i + 1]\n\n\t\t\t\tconst bounds = pageBounds[shape.id]\n\t\t\t\tconst nextBounds = pageBounds[nextShape.id]\n\n\t\t\t\tconst gap = nextBounds[min] - bounds[max]\n\n\t\t\t\tconst current = gaps.find((g) => g.gap === gap)\n\n\t\t\t\tif (current) {\n\t\t\t\t\tcurrent.count++\n\t\t\t\t} else {\n\t\t\t\t\tgaps.push({ gap, count: 1 })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Which gap is the most common?\n\t\t\tlet maxCount = 0\n\t\t\tgaps.forEach((g) => {\n\t\t\t\tif (g.count > maxCount) {\n\t\t\t\t\tmaxCount = g.count\n\t\t\t\t\tshapeGap = g.gap\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// If there is no most-common gap, use the average gap.\n\t\t\tif (maxCount === 1) {\n\t\t\t\tshapeGap = Math.max(0, gaps.reduce((a, c) => a + c.gap * c.count, 0) / (len - 1))\n\t\t\t}\n\t\t} else {\n\t\t\t// If a gap was provided, then use that instead.\n\t\t\tshapeGap = gap\n\t\t}\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tlet v = pageBounds[shapesToStack[0].id][max]\n\n\t\tshapesToStack.forEach((shape, i) => {\n\t\t\tif (i === 0) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\tdelta[val] = v + shapeGap - pageBounds[shape.id][val]\n\n\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\tconst localDelta = parent\n\t\t\t\t? Vec.Rot(delta, -this.getShapePageTransform(parent)!.decompose().rotation)\n\t\t\t\t: delta\n\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id as any,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t}\n\t\t\t)\n\n\t\t\tv += pageBounds[shape.id][dim] + shapeGap\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.packShapes([box1, box2], 32)\n\t * editor.packShapes(editor.getSelectedShapeIds(), 32)\n\t * ```\n\t *\n\t *\n\t * @param shapes - The shapes (or shape ids) to pack.\n\t * @param gap - The padding to apply to the packed shapes. Defaults to 16.\n\t */\n\tpackShapes(shapes: TLShapeId[] | TLShape[], gap: number): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getInstanceState().isReadonly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapesToPack = compact(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShape(id)) // always fresh shapes\n\t\t\t\t.filter((shape) => {\n\t\t\t\t\tif (!shape) return false\n\n\t\t\t\t\tif (this.isShapeOfType<TLArrowShape>(shape, 'arrow')) {\n\t\t\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t)\n\t\tconst shapePageBounds: Record<string, Box> = {}\n\t\tconst nextShapePageBounds: Record<string, Box> = {}\n\n\t\tlet shape: TLShape,\n\t\t\tbounds: Box,\n\t\t\tarea = 0\n\n\t\tfor (let i = 0; i < shapesToPack.length; i++) {\n\t\t\tshape = shapesToPack[i]\n\t\t\tbounds = this.getShapePageBounds(shape)!\n\t\t\tshapePageBounds[shape.id] = bounds\n\t\t\tnextShapePageBounds[shape.id] = bounds.clone()\n\t\t\tarea += bounds.width * bounds.height\n\t\t}\n\n\t\tconst commonBounds = Box.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst maxWidth = commonBounds.width\n\n\t\t// sort the shapes by height, descending\n\t\tshapesToPack.sort((a, b) => shapePageBounds[b.id].height - shapePageBounds[a.id].height)\n\n\t\t// Start with is (sort of) the square of the area\n\t\tconst startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth)\n\n\t\t// first shape fills the width and is infinitely tall\n\t\tconst spaces: Box[] = [new Box(commonBounds.x, commonBounds.y, startWidth, Infinity)]\n\n\t\tlet width = 0\n\t\tlet height = 0\n\t\tlet space: Box\n\t\tlet last: Box\n\n\t\tfor (let i = 0; i < shapesToPack.length; i++) {\n\t\t\tshape = shapesToPack[i]\n\t\t\tbounds = nextShapePageBounds[shape.id]\n\n\t\t\t// starting at the back (smaller shapes)\n\t\t\tfor (let i = spaces.length - 1; i >= 0; i--) {\n\t\t\t\tspace = spaces[i]\n\n\t\t\t\t// find a space that is big enough to contain the shape\n\t\t\t\tif (bounds.width > space.width || bounds.height > space.height) continue\n\n\t\t\t\t// add the shape to its top-left corner\n\t\t\t\tbounds.x = space.x\n\t\t\t\tbounds.y = space.y\n\n\t\t\t\theight = Math.max(height, bounds.maxY)\n\t\t\t\twidth = Math.max(width, bounds.maxX)\n\n\t\t\t\tif (bounds.width === space.width && bounds.height === space.height) {\n\t\t\t\t\t// remove the space on a perfect fit\n\t\t\t\t\tlast = spaces.pop()!\n\t\t\t\t\tif (i < spaces.length) spaces[i] = last\n\t\t\t\t} else if (bounds.height === space.height) {\n\t\t\t\t\t// fit the shape into the space (width)\n\t\t\t\t\tspace.x += bounds.width + gap\n\t\t\t\t\tspace.width -= bounds.width + gap\n\t\t\t\t} else if (bounds.width === space.width) {\n\t\t\t\t\t// fit the shape into the space (height)\n\t\t\t\t\tspace.y += bounds.height + gap\n\t\t\t\t\tspace.height -= bounds.height + gap\n\t\t\t\t} else {\n\t\t\t\t\t// split the space into two spaces\n\t\t\t\t\tspaces.push(\n\t\t\t\t\t\tnew Box(\n\t\t\t\t\t\t\tspace.x + (bounds.width + gap),\n\t\t\t\t\t\t\tspace.y,\n\t\t\t\t\t\t\tspace.width - (bounds.width + gap),\n\t\t\t\t\t\t\tbounds.height\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\tspace.y += bounds.height + gap\n\t\t\t\t\tspace.height -= bounds.height + gap\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst commonAfter = Box.Common(Object.values(nextShapePageBounds))\n\t\tconst centerDelta = Vec.Sub(commonBounds.center, commonAfter.center)\n\n\t\tlet nextBounds: Box\n\n\t\tconst changes: TLShapePartial<any>[] = []\n\n\t\tfor (let i = 0; i < shapesToPack.length; i++) {\n\t\t\tshape = shapesToPack[i]\n\t\t\tbounds = shapePageBounds[shape.id]\n\t\t\tnextBounds = nextShapePageBounds[shape.id]\n\n\t\t\tconst delta = Vec.Sub(nextBounds.point, bounds.point).add(centerDelta)\n\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\tif (parentTransform) delta.rot(-parentTransform.rotation())\n\n\t\t\tconst change: TLShapePartial = {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tx: shape.x + delta.x,\n\t\t\t\ty: shape.y + delta.y,\n\t\t\t}\n\n\t\t\tconst translateStartChange = this.getShapeUtil(shape).onTranslateStart?.({\n\t\t\t\t...shape,\n\t\t\t\t...change,\n\t\t\t})\n\n\t\t\tif (translateStartChange) {\n\t\t\t\tchanges.push({ ...change, ...translateStartChange })\n\t\t\t} else {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length) {\n\t\t\tthis.updateShapes(changes)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Align shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.alignShapes([box1, box2], 'left')\n\t * editor.alignShapes(editor.getSelectedShapeIds(), 'left')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to align.\n\t * @param operation - The align operation to apply.\n\t *\n\t * @public\n\t */\n\n\talignShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\toperation: 'left' | 'center-horizontal' | 'right' | 'top' | 'center-vertical' | 'bottom'\n\t): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getInstanceState().isReadonly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapesToAlign = compact(ids.map((id) => this.getShape(id))) // always fresh shapes\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapesToAlign.map((shape) => [shape.id, this.getShapePageBounds(shape)])\n\t\t)\n\t\tconst commonBounds = Box.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapesToAlign.forEach((shape) => {\n\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\tif (!pageBounds) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\n\t\t\tswitch (operation) {\n\t\t\t\tcase 'top': {\n\t\t\t\t\tdelta.y = commonBounds.minY - pageBounds.minY\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-vertical': {\n\t\t\t\t\tdelta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'bottom': {\n\t\t\t\t\tdelta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'left': {\n\t\t\t\t\tdelta.x = commonBounds.minX - pageBounds.minX\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-horizontal': {\n\t\t\t\t\tdelta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'right': {\n\t\t\t\t\tdelta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\tconst localDelta = parent\n\t\t\t\t? Vec.Rot(delta, -this.getShapePageTransform(parent)!.decompose().rotation)\n\t\t\t\t: delta\n\n\t\t\tchanges.push(this.getChangesToTranslateShape(shape, Vec.Add(shape, localDelta)))\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Distribute shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.distributeShapes([box1, box2], 'horizontal')\n\t * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to distribute.\n\t * @param operation - Whether to distribute shapes horizontally or vertically.\n\t *\n\t * @public\n\t */\n\tdistributeShapes(shapes: TLShapeId[] | TLShape[], operation: 'horizontal' | 'vertical'): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getInstanceState().isReadonly) return this\n\t\tif (ids.length < 3) return this\n\n\t\tconst len = ids.length\n\t\tconst shapesToDistribute = compact(ids.map((id) => this.getShape(id))) // always fresh shapes\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapesToDistribute.map((shape) => [shape.id, this.getShapePageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet mid: 'midX' | 'midY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tmid = 'midX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tmid = 'midY'\n\t\t\tdim = 'height'\n\t\t}\n\t\tconst changes: TLShapePartial[] = []\n\n\t\t// Clustered\n\t\tconst first = shapesToDistribute.sort(\n\t\t\t(a, b) => pageBounds[a.id][min] - pageBounds[b.id][min]\n\t\t)[0]\n\t\tconst last = shapesToDistribute.sort((a, b) => pageBounds[b.id][max] - pageBounds[a.id][max])[0]\n\n\t\tconst midFirst = pageBounds[first.id][mid]\n\t\tconst step = (pageBounds[last.id][mid] - midFirst) / (len - 1)\n\t\tconst v = midFirst + step\n\n\t\tshapesToDistribute\n\t\t\t.filter((shape) => shape !== first && shape !== last)\n\t\t\t.sort((a, b) => pageBounds[a.id][mid] - pageBounds[b.id][mid])\n\t\t\t.forEach((shape, i) => {\n\t\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\t\tdelta[val] = v + step * i - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val]\n\n\t\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\t\tconst localDelta = parent\n\t\t\t\t\t? Vec.Rot(delta, -this.getShapePageTransform(parent)!.rotation())\n\t\t\t\t\t: delta\n\n\t\t\t\tchanges.push(this.getChangesToTranslateShape(shape, Vec.Add(shape, localDelta)))\n\t\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Stretch shape sizes and positions to fill their common bounding box.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stretchShapes([box1, box2], 'horizontal')\n\t * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to stretch.\n\t * @param operation - Whether to stretch shapes horizontally or vertically.\n\t *\n\t * @public\n\t */\n\tstretchShapes(shapes: TLShapeId[] | TLShape[], operation: 'horizontal' | 'vertical'): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getInstanceState().isReadonly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapesToStretch = compact(ids.map((id) => this.getShape(id))) // always fresh shapes\n\t\tconst shapeBounds = Object.fromEntries(ids.map((id) => [id, this.getShapeGeometry(id).bounds]))\n\t\tconst shapePageBounds = Object.fromEntries(ids.map((id) => [id, this.getShapePageBounds(id)!]))\n\t\tconst commonBounds = Box.Common(compact(Object.values(shapePageBounds)))\n\n\t\tswitch (operation) {\n\t\t\tcase 'vertical': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapesToStretch) {\n\t\t\t\t\t\tconst pageRotation = this.getShapePageTransform(shape)!.rotation()\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst localOffset = new Vec(0, commonBounds.minY - pageBounds.minY)\n\t\t\t\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\t\t\t\tif (parentTransform) localOffset.rot(-parentTransform.rotation())\n\n\t\t\t\t\t\tconst { x, y } = Vec.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], { squashing: true })\n\t\t\t\t\t\tconst scale = new Vec(1, commonBounds.height / pageBounds.height)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec(pageBounds.center.x, commonBounds.minY),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'horizontal': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapesToStretch) {\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst pageRotation = this.getShapePageTransform(shape)!.rotation()\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst localOffset = new Vec(commonBounds.minX - pageBounds.minX, 0)\n\t\t\t\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\t\t\t\tif (parentTransform) localOffset.rot(-parentTransform.rotation())\n\n\t\t\t\t\t\tconst { x, y } = Vec.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], { squashing: true })\n\t\t\t\t\t\tconst scale = new Vec(commonBounds.width / pageBounds.width, 1)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec(commonBounds.minX, pageBounds.center.y),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Resize a shape.\n\t *\n\t * @param id - The id of the shape to resize.\n\t * @param scale - The scale factor to apply to the shape.\n\t * @param options - Additional options.\n\t *\n\t * @public\n\t */\n\tresizeShape(\n\t\tshape: TLShapeId | TLShape,\n\t\tscale: VecLike,\n\t\toptions: TLResizeShapeOptions = {}\n\t): this {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tif (this.getInstanceState().isReadonly) return this\n\n\t\tif (!Number.isFinite(scale.x)) scale = new Vec(1, scale.y)\n\t\tif (!Number.isFinite(scale.y)) scale = new Vec(scale.x, 1)\n\n\t\tconst initialShape = options.initialShape ?? this.getShape(id)\n\t\tif (!initialShape) return this\n\n\t\tconst scaleOrigin = options.scaleOrigin ?? this.getShapePageBounds(id)?.center\n\t\tif (!scaleOrigin) return this\n\n\t\tconst pageTransform = options.initialPageTransform\n\t\t\t? Mat.Cast(options.initialPageTransform)\n\t\t\t: this.getShapePageTransform(id)\n\t\tif (!pageTransform) return this\n\n\t\tconst pageRotation = pageTransform.rotation()\n\n\t\tif (pageRotation == null) return this\n\n\t\tconst scaleAxisRotation = options.scaleAxisRotation ?? pageRotation\n\n\t\tconst initialBounds = options.initialBounds ?? this.getShapeGeometry(id).bounds\n\n\t\tif (!initialBounds) return this\n\n\t\tif (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {\n\t\t\t// shape is awkwardly rotated, keep the aspect ratio locked and adopt the scale factor\n\t\t\t// from whichever axis is being scaled the least, to avoid the shape getting bigger\n\t\t\t// than the bounds of the selection\n\t\t\t// const minScale = Math.min(Math.abs(scale.x), Math.abs(scale.y))\n\t\t\treturn this._resizeUnalignedShape(id, scale, {\n\t\t\t\t...options,\n\t\t\t\tinitialBounds,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscaleAxisRotation,\n\t\t\t\tinitialPageTransform: pageTransform,\n\t\t\t\tinitialShape,\n\t\t\t})\n\t\t}\n\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tif (util.isAspectRatioLocked(initialShape)) {\n\t\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\tscale = new Vec(scale.x, Math.sign(scale.y) * Math.abs(scale.x))\n\t\t\t} else {\n\t\t\t\tscale = new Vec(Math.sign(scale.x) * Math.abs(scale.y), scale.y)\n\t\t\t}\n\t\t}\n\n\t\tif (util.onResize && util.canResize(initialShape)) {\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPagePoint = this._scalePagePoint(\n\t\t\t\tMat.applyToPoint(pageTransform, new Vec(0, 0)),\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint)\n\n\t\t\t// resize the shape's local bounding box\n\t\t\tconst myScale = new Vec(scale.x, scale.y)\n\t\t\t// the shape is aligned with the rest of the shapes in the selection, but may be\n\t\t\t// 90deg offset from the main rotation of the selection, in which case\n\t\t\t// we need to flip the width and height scale factors\n\t\t\tconst areWidthAndHeightAlignedWithCorrectAxis = approximately(\n\t\t\t\t(pageRotation - scaleAxisRotation) % Math.PI,\n\t\t\t\t0\n\t\t\t)\n\t\t\tmyScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y\n\t\t\tmyScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x\n\n\t\t\t// adjust initial model for situations where the parent has moved during the resize\n\t\t\t// e.g. groups\n\t\t\tconst initialPagePoint = Mat.applyToPoint(pageTransform, new Vec())\n\n\t\t\t// need to adjust the shape's x and y points in case the parent has moved since start of resizing\n\t\t\tconst { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint)\n\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: newLocalPoint.x,\n\t\t\t\t\t\ty: newLocalPoint.y,\n\t\t\t\t\t\t...util.onResize(\n\t\t\t\t\t\t\t{ ...initialShape, x, y },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewPoint: newLocalPoint,\n\t\t\t\t\t\t\t\thandle: options.dragHandle ?? 'bottom_right',\n\t\t\t\t\t\t\t\t// don't set isSingle to true for children\n\t\t\t\t\t\t\t\tmode: options.mode ?? 'scale_shape',\n\t\t\t\t\t\t\t\tscaleX: myScale.x,\n\t\t\t\t\t\t\t\tscaleY: myScale.y,\n\t\t\t\t\t\t\t\tinitialBounds,\n\t\t\t\t\t\t\t\tinitialShape,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t{ squashing: true }\n\t\t\t)\n\t\t} else {\n\t\t\tconst initialPageCenter = Mat.applyToPoint(pageTransform, initialBounds.center)\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPageCenter = this._scalePagePoint(\n\t\t\t\tinitialPageCenter,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst initialPageCenterInParentSpace = this.getPointInParentSpace(\n\t\t\t\tinitialShape.id,\n\t\t\t\tinitialPageCenter\n\t\t\t)\n\t\t\tconst newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter)\n\n\t\t\tconst delta = Vec.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace)\n\t\t\t// apply the changes to the model\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: initialShape.x + delta.x,\n\t\t\t\t\t\ty: initialShape.y + delta.y,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t{ squashing: true }\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _scalePagePoint(\n\t\tpoint: VecLike,\n\t\tscaleOrigin: VecLike,\n\t\tscale: VecLike,\n\t\tscaleAxisRotation: number\n\t) {\n\t\tconst relativePoint = Vec.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin)\n\n\t\t// calculate the new point position relative to the scale origin\n\t\tconst newRelativePagePoint = Vec.MulV(relativePoint, scale)\n\n\t\t// and rotate it back to page coords to get the new page point of the resized shape\n\t\tconst destination = Vec.Add(newRelativePagePoint, scaleOrigin).rotWith(\n\t\t\tscaleOrigin,\n\t\t\tscaleAxisRotation\n\t\t)\n\n\t\treturn destination\n\t}\n\n\t/** @internal */\n\tprivate _resizeUnalignedShape(\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds: Box\n\t\t\tscaleOrigin: VecLike\n\t\t\tscaleAxisRotation: number\n\t\t\tinitialShape: TLShape\n\t\t\tinitialPageTransform: MatLike\n\t\t}\n\t) {\n\t\tconst { type } = options.initialShape\n\t\t// If a shape is not aligned with the scale axis we need to treat it differently to avoid skewing.\n\t\t// Instead of skewing we normalize the scale aspect ratio (i.e. keep the same scale magnitude in both axes)\n\t\t// and then after applying the scale to the shape we also rotate it if required and translate it so that it's center\n\t\t// point ends up in the right place.\n\n\t\tconst shapeScale = new Vec(scale.x, scale.y)\n\n\t\t// // make sure we are constraining aspect ratio, and using the smallest scale axis to avoid shapes getting bigger\n\t\t// // than the selection bounding box\n\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\tshapeScale.x = Math.sign(scale.x) * Math.abs(scale.y)\n\t\t} else {\n\t\t\tshapeScale.y = Math.sign(scale.y) * Math.abs(scale.x)\n\t\t}\n\n\t\t// first we can scale the shape about its center point\n\t\tthis.resizeShape(id, shapeScale, {\n\t\t\tinitialShape: options.initialShape,\n\t\t\tinitialBounds: options.initialBounds,\n\t\t})\n\n\t\t// then if the shape is flipped in one axis only, we need to apply an extra rotation\n\t\t// to make sure the shape is mirrored correctly\n\t\tif (Math.sign(scale.x) * Math.sign(scale.y) < 0) {\n\t\t\tlet { rotation } = Mat.Decompose(options.initialPageTransform)\n\t\t\trotation -= 2 * rotation\n\t\t\tthis.updateShapes([{ id, type, rotation }], { squashing: true })\n\t\t}\n\n\t\t// Next we need to translate the shape so that it's center point ends up in the right place.\n\t\t// To do that we first need to calculate the center point of the shape in the current page space before the scale was applied.\n\t\tconst preScaleShapePageCenter = Mat.applyToPoint(\n\t\t\toptions.initialPageTransform,\n\t\t\toptions.initialBounds.center\n\t\t)\n\n\t\t// And now we scale the center point by the original scale factor\n\t\tconst postScaleShapePageCenter = this._scalePagePoint(\n\t\t\tpreScaleShapePageCenter,\n\t\t\toptions.scaleOrigin,\n\t\t\tscale,\n\t\t\toptions.scaleAxisRotation\n\t\t)\n\n\t\t// now calculate how far away the shape is from where it needs to be\n\t\tconst pageBounds = this.getShapePageBounds(id)!\n\t\tconst pageTransform = this.getShapePageTransform(id)!\n\t\tconst currentPageCenter = pageBounds.center\n\t\tconst shapePageTransformOrigin = pageTransform.point()\n\t\tif (!currentPageCenter || !shapePageTransformOrigin) return this\n\t\tconst pageDelta = Vec.Sub(postScaleShapePageCenter, currentPageCenter)\n\n\t\t// and finally figure out what the shape's new position should be\n\t\tconst postScaleShapePagePoint = Vec.Add(shapePageTransformOrigin, pageDelta)\n\t\tconst { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint)\n\n\t\tthis.updateShapes([{ id, type, x, y }], { squashing: true })\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the initial meta value for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getInitialMetaForShape = (shape) => {\n\t *   if (shape.type === 'note') {\n\t *     return { createdBy: myCurrentUser.id }\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @param shape - The shape to get the initial meta for.\n\t *\n\t * @public\n\t */\n\tgetInitialMetaForShape(_shape: TLShape): JsonObject {\n\t\treturn {}\n\t}\n\n\t/**\n\t * Create a single shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createShape(myShape)\n\t * editor.createShape({ id: 'box1', type: 'text', props: { text: \"ok\" } })\n\t * ```\n\t *\n\t * @param shape - The shape (or shape partial) to create.\n\t *\n\t * @public\n\t */\n\tcreateShape<T extends TLUnknownShape>(shape: OptionalKeys<TLShapePartial<T>, 'id'>): this {\n\t\tthis._createShapes([shape])\n\t\treturn this\n\t}\n\n\t/**\n\t * Create shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createShapes([myShape])\n\t * editor.createShapes([{ id: 'box1', type: 'text', props: { text: \"ok\" } }])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape partials) to create.\n\t * @param select - Whether to select the created shapes. Defaults to false.\n\t *\n\t * @public\n\t */\n\tcreateShapes<T extends TLUnknownShape>(shapes: OptionalKeys<TLShapePartial<T>, 'id'>[]) {\n\t\tif (!Array.isArray(shapes)) {\n\t\t\tthrow Error('Editor.createShapes: must provide an array of shapes or shape partials')\n\t\t}\n\t\tthis._createShapes(shapes)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createShapes = this.history.createCommand(\n\t\t'createShapes',\n\t\t(partials: OptionalKeys<TLShapePartial, 'id'>[]) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst currentPageShapeIds = this.getCurrentPageShapeIds()\n\n\t\t\tconst maxShapesReached = partials.length + currentPageShapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\t// can't create more shapes than fit on the page\n\t\t\t\talertMaxShapes(this)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (partials.length === 0) return null\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tcurrentPageId: this.getCurrentPageId(),\n\t\t\t\t\tpartials: partials.map((p) =>\n\t\t\t\t\t\tp.id ? p : { ...p, id: createShapeId() }\n\t\t\t\t\t) as TLShapePartial[],\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ partials }) => {\n\t\t\t\tconst focusedGroupId = this.getFocusedGroupId()\n\n\t\t\t\t// 1. Parents\n\n\t\t\t\t// Make sure that each partial will become the child of either the\n\t\t\t\t// page or another shape that exists (or that will exist) in this page.\n\n\t\t\t\t// find last parent id\n\t\t\t\tconst currentPageShapesSorted = this.getCurrentPageShapesSorted()\n\n\t\t\t\tpartials = partials.map((partial) => {\n\t\t\t\t\t// If the partial does not provide the parentId OR if the provided\n\t\t\t\t\t// parentId is NOT in the store AND NOT among the other shapes being\n\t\t\t\t\t// created, then we need to find a parent for the shape. This can be\n\t\t\t\t\t// another shape that exists under that point and which can receive\n\t\t\t\t\t// children of the creating shape's type, or else the page itself.\n\t\t\t\t\tif (\n\t\t\t\t\t\t!partial.parentId ||\n\t\t\t\t\t\t!(this.store.has(partial.parentId) || partials.some((p) => p.id === partial.parentId))\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet parentId: TLParentId = this.getFocusedGroupId()\n\n\t\t\t\t\t\tfor (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tconst parent = currentPageShapesSorted[i]\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t// parent.type === 'frame'\n\t\t\t\t\t\t\t\tthis.getShapeUtil(parent).canReceiveNewChildrenOfType(parent, partial.type) &&\n\t\t\t\t\t\t\t\tthis.isPointInShape(\n\t\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\t\t// If no parent is provided, then we can treat the\n\t\t\t\t\t\t\t\t\t// shape's provided x/y as being in the page's space.\n\t\t\t\t\t\t\t\t\t{ x: partial.x ?? 0, y: partial.y ?? 0 },\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmargin: 0,\n\t\t\t\t\t\t\t\t\t\thitInside: true,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tparentId = parent.id\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst prevParentId = partial.parentId\n\n\t\t\t\t\t\t// a shape cannot be it's own parent. This was a rare issue with frames/groups in the syncFuzz tests.\n\t\t\t\t\t\tif (parentId === partial.id) {\n\t\t\t\t\t\t\tparentId = focusedGroupId\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the parentid has changed...\n\t\t\t\t\t\tif (parentId !== prevParentId) {\n\t\t\t\t\t\t\tpartial = { ...partial }\n\n\t\t\t\t\t\t\tpartial.parentId = parentId\n\n\t\t\t\t\t\t\t// If the parent is a shape (rather than a page) then insert the\n\t\t\t\t\t\t\t// shapes into the shape's children. Adjust the point and page rotation to be\n\t\t\t\t\t\t\t// preserved relative to the parent.\n\t\t\t\t\t\t\tif (isShapeId(parentId)) {\n\t\t\t\t\t\t\t\tconst point = this.getPointInShapeSpace(this.getShape(parentId)!, {\n\t\t\t\t\t\t\t\t\tx: partial.x ?? 0,\n\t\t\t\t\t\t\t\t\ty: partial.y ?? 0,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tpartial.x = point.x\n\t\t\t\t\t\t\t\tpartial.y = point.y\n\t\t\t\t\t\t\t\tpartial.rotation =\n\t\t\t\t\t\t\t\t\t-this.getShapePageTransform(parentId)!.rotation() + (partial.rotation ?? 0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn partial\n\t\t\t\t})\n\n\t\t\t\t// 2. Indices\n\n\t\t\t\t// Get the highest index among the parents of each of the\n\t\t\t\t// the shapes being created; we'll increment from there.\n\n\t\t\t\tconst parentIndices = new Map<TLParentId, IndexKey>()\n\n\t\t\t\tconst shapeRecordsToCreate: TLShape[] = []\n\n\t\t\t\tfor (const partial of partials) {\n\t\t\t\t\tconst util = this.getShapeUtil(partial)\n\n\t\t\t\t\t// If an index is not explicitly provided, then add the\n\t\t\t\t\t// shapes to the top of their parents' children; using the\n\t\t\t\t\t// value in parentsMappedToIndex, get the index above, use it,\n\t\t\t\t\t// and set it back to parentsMappedToIndex for next time.\n\t\t\t\t\tlet index = partial.index\n\n\t\t\t\t\tif (!index) {\n\t\t\t\t\t\t// Hello bug-seeker: have you just created a frame and then a shape\n\t\t\t\t\t\t// and found that the shape is automatically the child of the frame?\n\t\t\t\t\t\t// this is the reason why! It would be harder to have each shape specify\n\t\t\t\t\t\t// the frame as the parent when creating a shape inside of a frame, so\n\t\t\t\t\t\t// we do it here.\n\t\t\t\t\t\tconst parentId = partial.parentId ?? focusedGroupId\n\n\t\t\t\t\t\tif (!parentIndices.has(parentId)) {\n\t\t\t\t\t\t\tparentIndices.set(parentId, this.getHighestIndexForParent(parentId))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = parentIndices.get(parentId)!\n\t\t\t\t\t\tparentIndices.set(parentId, getIndexAbove(index))\n\t\t\t\t\t}\n\n\t\t\t\t\t// The initial props starts as the shape utility's default props\n\t\t\t\t\tconst initialProps = util.getDefaultProps()\n\n\t\t\t\t\t// We then look up each key in the tab state's styles; and if it's there,\n\t\t\t\t\t// we use the value from the tab state's styles instead of the default.\n\t\t\t\t\tfor (const [style, propKey] of this.styleProps[partial.type]) {\n\t\t\t\t\t\t;(initialProps as any)[propKey] = this.getStyleForNextShape(style)\n\t\t\t\t\t}\n\n\t\t\t\t\t// When we create the shape, take in the partial (the props coming into the\n\t\t\t\t\t// function) and merge it with the default props.\n\t\t\t\t\tlet shapeRecordToCreate = (\n\t\t\t\t\t\tthis.store.schema.types.shape as RecordType<\n\t\t\t\t\t\t\tTLShape,\n\t\t\t\t\t\t\t'type' | 'props' | 'index' | 'parentId'\n\t\t\t\t\t\t>\n\t\t\t\t\t).create({\n\t\t\t\t\t\t...partial,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\topacity: partial.opacity ?? this.getInstanceState().opacityForNextShape,\n\t\t\t\t\t\tparentId: partial.parentId ?? focusedGroupId,\n\t\t\t\t\t\tprops: 'props' in partial ? { ...initialProps, ...partial.props } : initialProps,\n\t\t\t\t\t})\n\n\t\t\t\t\tif (shapeRecordToCreate.index === undefined) {\n\t\t\t\t\t\tthrow Error('no index!')\n\t\t\t\t\t}\n\n\t\t\t\t\tconst next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate)\n\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tshapeRecordToCreate = next\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeRecordsToCreate.push(shapeRecordToCreate)\n\t\t\t\t}\n\n\t\t\t\t// Add meta properties, if any, to the shapes\n\t\t\t\tshapeRecordsToCreate.forEach((shape) => {\n\t\t\t\t\tshape.meta = {\n\t\t\t\t\t\t...this.getInitialMetaForShape(shape),\n\t\t\t\t\t\t...shape.meta,\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tthis.store.put(shapeRecordsToCreate)\n\t\t\t},\n\t\t\tundo: ({ partials }) => {\n\t\t\t\tthis.store.remove(partials.map((p) => p.id))\n\t\t\t},\n\t\t}\n\t)\n\n\tprivate animatingShapes = new Map<TLShapeId, string>()\n\n\t/**\n\t * Animate a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })\n\t * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { duration: 100, ease: t => t*t })\n\t * ```\n\t *\n\t * @param partial - The shape partial to update.\n\t * @param options - The animation's options.\n\t *\n\t * @public\n\t */\n\tanimateShape(\n\t\tpartial: TLShapePartial | null | undefined,\n\t\tanimationOptions?: TLAnimationOptions\n\t): this {\n\t\treturn this.animateShapes([partial], animationOptions)\n\t}\n\n\t/**\n\t * Animate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])\n\t * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { duration: 100, ease: t => t*t })\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @param options - The animation's options.\n\t *\n\t * @public\n\t */\n\tanimateShapes(\n\t\tpartials: (TLShapePartial | null | undefined)[],\n\t\tanimationOptions = {} as TLAnimationOptions\n\t): this {\n\t\tconst { duration = 500, easing = EASINGS.linear } = animationOptions\n\n\t\tconst animationId = uniqueId()\n\n\t\tlet remaining = duration\n\t\tlet t: number\n\n\t\ttype ShapeAnimation = {\n\t\t\tpartial: TLShapePartial\n\t\t\tvalues: { prop: string; from: number; to: number }[]\n\t\t}\n\n\t\tconst animations: ShapeAnimation[] = []\n\n\t\tlet partial: TLShapePartial | null | undefined, result: ShapeAnimation\n\t\tfor (let i = 0, n = partials.length; i < n; i++) {\n\t\t\tpartial = partials[i]\n\t\t\tif (!partial) continue\n\n\t\t\tresult = {\n\t\t\t\tpartial,\n\t\t\t\tvalues: [],\n\t\t\t}\n\n\t\t\tconst shape = this.getShape(partial.id)!\n\t\t\tif (!shape) continue\n\n\t\t\t// We only support animations for certain props\n\t\t\tfor (const key of ['x', 'y', 'rotation'] as const) {\n\t\t\t\tif (partial[key] !== undefined && shape[key] !== partial[key]) {\n\t\t\t\t\tresult.values.push({ prop: key, from: shape[key], to: partial[key] as number })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(result)\n\t\t\tthis.animatingShapes.set(shape.id, animationId)\n\t\t}\n\n\t\tlet value: ShapeAnimation\n\n\t\tconst handleTick = (elapsed: number) => {\n\t\t\tremaining -= elapsed\n\n\t\t\tif (remaining < 0) {\n\t\t\t\tconst { animatingShapes } = this\n\t\t\t\tconst partialsToUpdate = partials.filter(\n\t\t\t\t\t(p) => p && animatingShapes.get(p.id) === animationId\n\t\t\t\t)\n\t\t\t\tif (partialsToUpdate.length) {\n\t\t\t\t\tthis.updateShapes(partialsToUpdate, { squashing: false })\n\t\t\t\t\t// update shapes also removes the shape from animating shapes\n\t\t\t\t}\n\n\t\t\t\tthis.removeListener('tick', handleTick)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt = easing(1 - remaining / duration)\n\n\t\t\tconst { animatingShapes } = this\n\n\t\t\tconst updates: TLShapePartial[] = []\n\n\t\t\tlet animationIdForShape: string | undefined\n\t\t\tfor (let i = 0, n = animations.length; i < n; i++) {\n\t\t\t\tvalue = animations[i]\n\t\t\t\t// Is the animation for this shape still active?\n\t\t\t\tanimationIdForShape = animatingShapes.get(value.partial.id)\n\t\t\t\tif (animationIdForShape !== animationId) continue\n\n\t\t\t\t// Create the update\n\t\t\t\tupdates.push({\n\t\t\t\t\tid: value.partial.id,\n\t\t\t\t\ttype: value.partial.type,\n\t\t\t\t\t...value.values.reduce((acc, { prop, from, to }) => {\n\t\t\t\t\t\tacc[prop] = from + (to - from) * t\n\t\t\t\t\t\treturn acc\n\t\t\t\t\t}, {} as any),\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis._updateShapes(updates, { squashing: true })\n\t\t}\n\n\t\tthis.addListener('tick', handleTick)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Create a group containing the provided shapes.\n\t *\n\t * @param shapes - The shapes (or shape ids) to group. Defaults to the selected shapes.\n\t * @param groupId - The id of the group to create.\n\t *\n\t * @public\n\t */\n\tgroupShapes(shapes: TLShapeId[] | TLShape[], groupId = createShapeId()): this {\n\t\tif (!Array.isArray(shapes)) {\n\t\t\tthrow Error('Editor.groupShapes: must provide an array of shapes or shape ids')\n\t\t}\n\t\tif (this.getInstanceState().isReadonly) return this\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes.map((s) => (s as TLShape).id) as TLShapeId[])\n\n\t\tif (ids.length <= 1) return this\n\n\t\tconst shapesToGroup = compact(this._getUnlockedShapeIds(ids).map((id) => this.getShape(id)))\n\t\tconst sortedShapeIds = shapesToGroup.sort(sortByIndex).map((s) => s.id)\n\t\tconst pageBounds = Box.Common(compact(shapesToGroup.map((id) => this.getShapePageBounds(id))))\n\n\t\tconst { x, y } = pageBounds.point\n\n\t\tconst parentId = this.findCommonAncestor(shapesToGroup) ?? this.getCurrentPageId()\n\n\t\t// Only group when the select tool is active\n\t\tif (this.getCurrentToolId() !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// Find all the shapes that have the same parentId, and use the highest index.\n\t\tconst shapesWithRootParent = shapesToGroup\n\t\t\t.filter((shape) => shape.parentId === parentId)\n\t\t\t.sort(sortByIndex)\n\n\t\tconst highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index\n\n\t\tthis.batch(() => {\n\t\t\tthis.createShapes<TLGroupShape>([\n\t\t\t\t{\n\t\t\t\t\tid: groupId,\n\t\t\t\t\ttype: 'group',\n\t\t\t\t\tparentId,\n\t\t\t\t\tindex: highestIndex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tprops: {},\n\t\t\t\t},\n\t\t\t])\n\t\t\tthis.reparentShapes(sortedShapeIds, groupId)\n\t\t\tthis.select(groupId)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Ungroup some shapes.\n\t *\n\t * @param ids - Ids of the shapes to ungroup. Defaults to the selected shapes.\n\t *\n\t * @public\n\t */\n\tungroupShapes(ids: TLShapeId[]): this\n\tungroupShapes(ids: TLShape[]): this\n\tungroupShapes(_ids: TLShapeId[] | TLShape[]) {\n\t\tconst ids =\n\t\t\ttypeof _ids[0] === 'string' ? (_ids as TLShapeId[]) : (_ids as TLShape[]).map((s) => s.id)\n\t\tif (this.getInstanceState().isReadonly) return this\n\t\tif (ids.length === 0) return this\n\n\t\t// Only ungroup when the select tool is active\n\t\tif (this.getCurrentToolId() !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// The ids of the selected shapes after ungrouping;\n\t\t// these include all of the grouped shapes children,\n\t\t// plus any shapes that were selected apart from the groups.\n\t\tconst idsToSelect = new Set<TLShapeId>()\n\n\t\t// Get all groups in the selection\n\t\tconst shapes = compact(ids.map((id) => this.getShape(id)))\n\n\t\tconst groups: TLGroupShape[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\tgroups.push(shape)\n\t\t\t} else {\n\t\t\t\tidsToSelect.add(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tif (groups.length === 0) return this\n\n\t\tthis.batch(() => {\n\t\t\tlet group: TLGroupShape\n\n\t\t\tfor (let i = 0, n = groups.length; i < n; i++) {\n\t\t\t\tgroup = groups[i]\n\t\t\t\tconst childIds = this.getSortedChildIdsForParent(group.id)\n\n\t\t\t\tfor (let j = 0, n = childIds.length; j < n; j++) {\n\t\t\t\t\tidsToSelect.add(childIds[j])\n\t\t\t\t}\n\n\t\t\t\tthis.reparentShapes(childIds, group.parentId, group.index)\n\t\t\t}\n\n\t\t\tthis.deleteShapes(groups.map((group) => group.id))\n\t\t\tthis.select(...idsToSelect)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Update a shape using a partial of the shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })\n\t * ```\n\t *\n\t * @param partial - The shape partial to update.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tupdateShape<T extends TLUnknownShape>(\n\t\tpartial: TLShapePartial<T> | null | undefined,\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t) {\n\t\tthis.updateShapes([partial], historyOptions)\n\t\treturn this\n\t}\n\n\t/**\n\t * Update shapes using partials of each shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tupdateShapes<T extends TLUnknownShape>(\n\t\tpartials: (TLShapePartial<T> | null | undefined)[],\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t) {\n\t\tconst compactedPartials: TLShapePartial<T>[] = Array(partials.length)\n\n\t\tfor (let i = 0, n = partials.length; i < n; i++) {\n\t\t\tconst partial = partials[i]\n\t\t\tif (!partial) continue\n\t\t\t// Get the current shape referenced by the partial\n\t\t\tconst shape = this.getShape(partial.id)\n\t\t\tif (!shape) continue\n\n\t\t\t// If the shape is locked and we're not setting isLocked to true, continue\n\t\t\tif (this.isShapeOrAncestorLocked(shape) && !Object.hasOwn(partial, 'isLocked')) continue\n\n\t\t\t// Remove any animating shapes from the list of partials\n\t\t\tthis.animatingShapes.delete(partial.id)\n\n\t\t\tcompactedPartials.push(partial)\n\t\t}\n\n\t\tthis._updateShapes(compactedPartials, historyOptions)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateShapes = this.history.createCommand(\n\t\t'updateShapes',\n\t\t(\n\t\t\t_partials: (TLShapePartial | null | undefined)[],\n\t\t\thistoryOptions?: TLCommandHistoryOptions\n\t\t) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\n\t\t\tconst snapshots: Record<string, TLShape> = {}\n\t\t\tconst updates: Record<string, TLShape> = {}\n\n\t\t\tlet shape: TLShape | undefined\n\t\t\tlet updated: TLShape\n\n\t\t\tfor (let i = 0, n = _partials.length; i < n; i++) {\n\t\t\t\tconst partial = _partials[i]\n\t\t\t\t// Skip nullish partials (sometimes created by map fns returning undefined)\n\t\t\t\tif (!partial) continue\n\n\t\t\t\t// Get the current shape referenced by the partial\n\t\t\t\t// If there is no current shape, we'll skip this update\n\t\t\t\tshape = this.getShape(partial.id)\n\t\t\t\tif (!shape) continue\n\n\t\t\t\t// Get the updated version of the shape\n\t\t\t\t// If the update had no effect, we'll skip this update\n\t\t\t\tupdated = applyPartialToShape(shape, partial)\n\t\t\t\tif (updated === shape) continue\n\n\t\t\t\tsnapshots[shape.id] = shape\n\t\t\t\tupdates[shape.id] = updated\n\t\t\t}\n\n\t\t\treturn { data: { snapshots, updates }, ...historyOptions }\n\t\t},\n\t\t{\n\t\t\tdo: ({ updates }) => {\n\t\t\t\t// Iterate through array; if any shape has an onBeforeUpdate handler, call it\n\t\t\t\t// and, if the handler returns a new shape, replace the old shape with\n\t\t\t\t// the new one. This is used for example when repositioning a text shape\n\t\t\t\t// based on its new text content.\n\t\t\t\tthis.store.put(\n\t\t\t\t\tobjectMapValues(updates).map((shape) => {\n\t\t\t\t\t\tconst current = this.store.get(shape.id)\n\t\t\t\t\t\tif (current) {\n\t\t\t\t\t\t\tconst next = this.getShapeUtil(shape).onBeforeUpdate?.(current, shape)\n\t\t\t\t\t\t\tif (next) return next\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn shape\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\t// keep the oldest snapshots\n\t\t\t\t\tsnapshots: { ...nextData.snapshots, ...prevData.snapshots },\n\t\t\t\t\t// keep the newest updates\n\t\t\t\t\tupdates: { ...prevData.updates, ...nextData.updates },\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/** @internal */\n\tprivate _getUnlockedShapeIds(ids: TLShapeId[]): TLShapeId[] {\n\t\treturn ids.filter((id) => !this.getShape(id)?.isLocked)\n\t}\n\n\t/**\n\t * Delete shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteShapes(['box1', 'box2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to delete.\n\t *\n\t * @public\n\t */\n\tdeleteShapes(ids: TLShapeId[]): this\n\tdeleteShapes(shapes: TLShape[]): this\n\tdeleteShapes(_ids: TLShapeId[] | TLShape[]) {\n\t\tif (!Array.isArray(_ids)) {\n\t\t\tthrow Error('Editor.deleteShapes: must provide an array of shapes or shapeIds')\n\t\t}\n\t\tthis._deleteShapes(\n\t\t\tthis._getUnlockedShapeIds(\n\t\t\t\ttypeof _ids[0] === 'string' ? (_ids as TLShapeId[]) : (_ids as TLShape[]).map((s) => s.id)\n\t\t\t)\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteShapes(['box1', 'box2'])\n\t * ```\n\t *\n\t * @param id - The id of the shape to delete.\n\t *\n\t * @public\n\t */\n\tdeleteShape(id: TLShapeId): this\n\tdeleteShape(shape: TLShape): this\n\tdeleteShape(_id: TLShapeId | TLShape) {\n\t\tthis.deleteShapes([typeof _id === 'string' ? _id : _id.id])\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _deleteShapes = this.history.createCommand(\n\t\t'delete_shapes',\n\t\t(ids: TLShapeId[]) => {\n\t\t\tif (this.getInstanceState().isReadonly) return null\n\t\t\tif (ids.length === 0) return null\n\t\t\tconst prevSelectedShapeIds = [...this.getCurrentPageState().selectedShapeIds]\n\n\t\t\tconst allIds = new Set(ids)\n\n\t\t\tfor (const id of ids) {\n\t\t\t\tthis.visitDescendants(id, (childId) => {\n\t\t\t\t\tallIds.add(childId)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst deletedIds = [...allIds]\n\t\t\tconst arrowBindings = this._getArrowBindingsIndex().get()\n\t\t\tconst snapshots = compact(\n\t\t\t\tdeletedIds.flatMap((id) => {\n\t\t\t\t\tconst shape = this.getShape(id)\n\n\t\t\t\t\t// Add any bound arrows to the snapshots, so that we can restore the bindings on undo\n\t\t\t\t\tconst bindings = arrowBindings[id]\n\t\t\t\t\tif (bindings && bindings.length > 0) {\n\t\t\t\t\t\treturn bindings.map(({ arrowId }) => this.getShape(arrowId)).concat(shape)\n\t\t\t\t\t}\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tconst postSelectedShapeIds = prevSelectedShapeIds.filter((id) => !allIds.has(id))\n\n\t\t\treturn { data: { deletedIds, snapshots, prevSelectedShapeIds, postSelectedShapeIds } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedIds, postSelectedShapeIds }) => {\n\t\t\t\tthis.store.remove(deletedIds)\n\t\t\t\tthis.store.update(this.getCurrentPageState().id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedShapeIds: postSelectedShapeIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tundo: ({ snapshots, prevSelectedShapeIds }) => {\n\t\t\t\tthis.store.put(snapshots)\n\t\t\t\tthis.store.update(this.getCurrentPageState().id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedShapeIds: prevSelectedShapeIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t}\n\t)\n\n\t/* --------------------- Styles --------------------- */\n\n\t/**\n\t * Get all the current styles among the users selected shapes\n\t *\n\t * @internal\n\t */\n\tprivate _extractSharedStyles(shape: TLShape, sharedStyleMap: SharedStyleMap) {\n\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t// For groups, ignore the styles of the group shape and instead include the styles of the\n\t\t\t// group's children. These are the shapes that would have their styles changed if the\n\t\t\t// user called `setStyle` on the current selection.\n\t\t\tconst childIds = this._parentIdsToChildIds.get()[shape.id]\n\t\t\tif (!childIds) return\n\n\t\t\tfor (let i = 0, n = childIds.length; i < n; i++) {\n\t\t\t\tthis._extractSharedStyles(this.getShape(childIds[i])!, sharedStyleMap)\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [style, propKey] of this.styleProps[shape.type]) {\n\t\t\t\tsharedStyleMap.applyValue(style, getOwnProperty(shape.props, propKey))\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A derived map containing all current styles among the user's selected shapes.\n\t *\n\t * @internal\n\t */\n\t@computed\n\tprivate _getSelectionSharedStyles(): ReadonlySharedStyleMap {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\n\t\tconst sharedStyles = new SharedStyleMap()\n\t\tfor (const selectedShape of selectedShapes) {\n\t\t\tthis._extractSharedStyles(selectedShape, sharedStyles)\n\t\t}\n\n\t\treturn sharedStyles\n\t}\n\n\t/** @internal */\n\tgetStyleForNextShape<T>(style: StyleProp<T>): T {\n\t\tconst value = this.getInstanceState().stylesForNextShape[style.id]\n\t\treturn value === undefined ? style.defaultValue : (value as T)\n\t}\n\n\tgetShapeStyleIfExists<T>(shape: TLShape, style: StyleProp<T>): T | undefined {\n\t\tconst styleKey = this.styleProps[shape.type].get(style)\n\t\tif (styleKey === undefined) return undefined\n\t\treturn getOwnProperty(shape.props, styleKey) as T | undefined\n\t}\n\n\t/**\n\t * A map of all the current styles either in the current selection, or that are relevant to the\n\t * current tool.\n\t *\n\t * @example\n\t * ```ts\n\t * const color = editor.getSharedStyles().get(DefaultColorStyle)\n\t * if (color && color.type === 'shared') {\n\t *   print('All selected shapes have the same color:', color.value)\n\t * }\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed<ReadonlySharedStyleMap>({ isEqual: (a, b) => a.equals(b) })\n\tgetSharedStyles(): ReadonlySharedStyleMap {\n\t\t// If we're in selecting and if we have a selection, return the shared styles from the\n\t\t// current selection\n\t\tif (this.isIn('select') && this.getSelectedShapeIds().length > 0) {\n\t\t\treturn this._getSelectionSharedStyles()\n\t\t}\n\n\t\t// If the current tool is associated with a shape, return the styles for that shape.\n\t\t// Otherwise, just return an empty map.\n\t\tconst currentTool = this.root.getCurrent()!\n\t\tconst styles = new SharedStyleMap()\n\n\t\tif (!currentTool) return styles\n\n\t\tif (currentTool.shapeType) {\n\t\t\tfor (const style of this.styleProps[currentTool.shapeType].keys()) {\n\t\t\t\tstyles.applyValue(style, this.getStyleForNextShape(style))\n\t\t\t}\n\t\t}\n\n\t\treturn styles\n\t}\n\n\t/**\n\t * Get the currently selected shared opacity.\n\t * If any shapes are selected, this returns the shared opacity of the selected shapes.\n\t * Otherwise, this returns the chosen opacity for the next shape.\n\t *\n\t * @public\n\t */\n\t@computed getSharedOpacity(): SharedStyle<number> {\n\t\tif (this.isIn('select') && this.getSelectedShapeIds().length > 0) {\n\t\t\tconst shapesToCheck: TLShape[] = []\n\t\t\tconst addShape = (shapeId: TLShapeId) => {\n\t\t\t\tconst shape = this.getShape(shapeId)\n\t\t\t\tif (!shape) return\n\t\t\t\t// For groups, ignore the opacity of the group shape and instead include\n\t\t\t\t// the opacity of the group's children. These are the shapes that would have\n\t\t\t\t// their opacity changed if the user called `setOpacity` on the current selection.\n\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\tfor (const childId of this.getSortedChildIdsForParent(shape.id)) {\n\t\t\t\t\t\taddShape(childId)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshapesToCheck.push(shape)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const shapeId of this.getSelectedShapeIds()) {\n\t\t\t\taddShape(shapeId)\n\t\t\t}\n\n\t\t\tlet opacity: number | null = null\n\t\t\tfor (const shape of shapesToCheck) {\n\t\t\t\tif (opacity === null) {\n\t\t\t\t\topacity = shape.opacity\n\t\t\t\t} else if (opacity !== shape.opacity) {\n\t\t\t\t\treturn { type: 'mixed' }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opacity !== null) return { type: 'shared', value: opacity }\n\t\t}\n\t\treturn { type: 'shared', value: this.getInstanceState().opacityForNextShape }\n\t}\n\n\t/**\n\t * Set the opacity for the next shapes. This will effect subsequently created shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setOpacityForNextShapes(0.5)\n\t * editor.setOpacityForNextShapes(0.5, { squashing: true })\n\t * ```\n\t *\n\t * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n\t * @param historyOptions - The history options for the change.\n\t */\n\tsetOpacityForNextShapes(opacity: number, historyOptions?: TLCommandHistoryOptions): this {\n\t\tthis.updateInstanceState({ opacityForNextShape: opacity }, historyOptions)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current opacity. This will effect any selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setOpacityForSelectedShapes(0.5)\n\t * editor.setOpacityForSelectedShapes(0.5, { squashing: true })\n\t * ```\n\t *\n\t * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n\t * @param historyOptions - The history options for the change.\n\t */\n\tsetOpacityForSelectedShapes(opacity: number, historyOptions?: TLCommandHistoryOptions): this {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\n\t\tif (selectedShapes.length > 0) {\n\t\t\tconst shapesToUpdate: TLShape[] = []\n\n\t\t\t// We can have many deep levels of grouped shape\n\t\t\t// Making a recursive function to look through all the levels\n\t\t\tconst addShapeById = (shape: TLShape) => {\n\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\tconst childIds = this.getSortedChildIdsForParent(shape)\n\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\taddShapeById(this.getShape(childId)!)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshapesToUpdate.push(shape)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id of selectedShapes) {\n\t\t\t\taddShapeById(id)\n\t\t\t}\n\n\t\t\tthis.updateShapes(\n\t\t\t\tshapesToUpdate.map((shape) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\topacity,\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\thistoryOptions\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setStyleForNextShapes(DefaultColorStyle, 'red')\n\t * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })\n\t * ```\n\t *\n\t * @param style - The style to set.\n\t * @param value - The value to set.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tsetStyleForNextShapes<T>(\n\t\tstyle: StyleProp<T>,\n\t\tvalue: T,\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t): this {\n\t\tconst stylesForNextShape = this.getInstanceState().stylesForNextShape\n\n\t\tthis.updateInstanceState(\n\t\t\t{ stylesForNextShape: { ...stylesForNextShape, [style.id]: value } },\n\t\t\thistoryOptions\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')\n\t * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red', { ephemeral: true })\n\t * ```\n\t *\n\t * @param style - The style to set.\n\t * @param value - The value to set.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tsetStyleForSelectedShapes<S extends StyleProp<any>>(\n\t\tstyle: S,\n\t\tvalue: StylePropValue<S>,\n\t\thistoryOptions?: TLCommandHistoryOptions\n\t): this {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\n\t\tif (selectedShapes.length > 0) {\n\t\t\tconst updates: {\n\t\t\t\tutil: ShapeUtil\n\t\t\t\toriginalShape: TLShape\n\t\t\t\tupdatePartial: TLShapePartial\n\t\t\t}[] = []\n\n\t\t\t// We can have many deep levels of grouped shape\n\t\t\t// Making a recursive function to look through all the levels\n\t\t\tconst addShapeById = (shape: TLShape) => {\n\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\tconst childIds = this.getSortedChildIdsForParent(shape.id)\n\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\taddShapeById(this.getShape(childId)!)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\tconst stylePropKey = this.styleProps[shape.type].get(style)\n\t\t\t\t\tif (stylePropKey) {\n\t\t\t\t\t\tconst shapePartial: TLShapePartial = {\n\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\tprops: { [stylePropKey]: value },\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdates.push({\n\t\t\t\t\t\t\tutil,\n\t\t\t\t\t\t\toriginalShape: shape,\n\t\t\t\t\t\t\tupdatePartial: shapePartial,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const shape of selectedShapes) {\n\t\t\t\taddShapeById(shape)\n\t\t\t}\n\n\t\t\tthis.updateShapes(\n\t\t\t\tupdates.map(({ updatePartial }) => updatePartial),\n\t\t\t\thistoryOptions\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/* --------------------- Content -------------------- */\n\n\t/** @internal */\n\texternalAssetContentHandlers: {\n\t\t[K in TLExternalAssetContent['type']]: {\n\t\t\t[Key in K]:\n\t\t\t\t| null\n\t\t\t\t| ((info: TLExternalAssetContent & { type: Key }) => Promise<TLAsset | undefined>)\n\t\t}[K]\n\t} = {\n\t\tfile: null,\n\t\turl: null,\n\t}\n\n\t/**\n\t * Register an external content handler. This handler will be called when the editor receives\n\t * external content of the provided type. For example, the 'image' type handler will be called\n\t * when a user drops an image onto the canvas.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerExternalAssetHandler('text', myHandler)\n\t * ```\n\t *\n\t * @param type - The type of external content.\n\t * @param handler - The handler to use for this content type.\n\t *\n\t * @public\n\t */\n\tregisterExternalAssetHandler<T extends TLExternalAssetContent['type']>(\n\t\ttype: T,\n\t\thandler: null | ((info: TLExternalAssetContent & { type: T }) => Promise<TLAsset>)\n\t): this {\n\t\tthis.externalAssetContentHandlers[type] = handler as any\n\t\treturn this\n\t}\n\n\t/**\n\t * Get an asset for an external asset content type.\n\t *\n\t * @example\n\t * ```ts\n\t * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })\n\t * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })\n\t * ```\n\t *\n\t * @param info - Info about the external content.\n\t * @returns The asset.\n\t */\n\tasync getAssetForExternalContent(info: TLExternalAssetContent): Promise<TLAsset | undefined> {\n\t\treturn await this.externalAssetContentHandlers[info.type]?.(info as any)\n\t}\n\n\t/** @internal */\n\texternalContentHandlers: {\n\t\t[K in TLExternalContent['type']]: {\n\t\t\t[Key in K]: null | ((info: TLExternalContent & { type: Key }) => void)\n\t\t}[K]\n\t} = {\n\t\ttext: null,\n\t\tfiles: null,\n\t\tembed: null,\n\t\t'svg-text': null,\n\t\turl: null,\n\t}\n\n\t/**\n\t * Register an external content handler. This handler will be called when the editor receives\n\t * external content of the provided type. For example, the 'image' type handler will be called\n\t * when a user drops an image onto the canvas.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerExternalContentHandler('text', myHandler)\n\t * ```\n\t *\n\t * @param type - The type of external content.\n\t * @param handler - The handler to use for this content type.\n\t *\n\t * @public\n\t */\n\tregisterExternalContentHandler<T extends TLExternalContent['type']>(\n\t\ttype: T,\n\t\thandler:\n\t\t\t| null\n\t\t\t| ((\n\t\t\t\t\tinfo: T extends TLExternalContent['type']\n\t\t\t\t\t\t? TLExternalContent & { type: T }\n\t\t\t\t\t\t: TLExternalContent\n\t\t\t  ) => void)\n\t): this {\n\t\tthis.externalContentHandlers[type] = handler as any\n\t\treturn this\n\t}\n\n\t/**\n\t * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.\n\t *\n\t * @param info - Info about the external content.\n\t */\n\tasync putExternalContent(info: TLExternalContent): Promise<void> {\n\t\treturn this.externalContentHandlers[info.type]?.(info as any)\n\t}\n\n\t/**\n\t * Get content that can be exported for the given shape ids.\n\t *\n\t * @param shapes - The shapes (or shape ids) to get content for.\n\t *\n\t * @returns The exported content.\n\t *\n\t * @public\n\t */\n\tgetContentFromCurrentPage(shapes: TLShapeId[] | TLShape[]): TLContent | undefined {\n\t\t// todo: make this work with any page, not just the current page\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (!ids) return\n\t\tif (ids.length === 0) return\n\n\t\tconst pageTransforms: Record<string, MatModel> = {}\n\n\t\tlet shapesForContent = dedupe(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShape(id)!)\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.flatMap((shape) => {\n\t\t\t\t\tconst allShapes = [shape]\n\t\t\t\t\tthis.visitDescendants(shape.id, (descendant) => {\n\t\t\t\t\t\tallShapes.push(this.getShape(descendant)!)\n\t\t\t\t\t})\n\t\t\t\t\treturn allShapes\n\t\t\t\t})\n\t\t)\n\n\t\tshapesForContent = shapesForContent.map((shape) => {\n\t\t\tpageTransforms[shape.id] = this.getShapePageTransform(shape.id)!\n\n\t\t\tshape = structuredClone(shape) as typeof shape\n\n\t\t\tif (this.isShapeOfType<TLArrowShape>(shape, 'arrow')) {\n\t\t\t\tconst startBindingId =\n\t\t\t\t\tshape.props.start.type === 'binding' ? shape.props.start.boundShapeId : undefined\n\n\t\t\t\tconst endBindingId =\n\t\t\t\t\tshape.props.end.type === 'binding' ? shape.props.end.boundShapeId : undefined\n\n\t\t\t\tconst info = this.getArrowInfo(shape)\n\n\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\tif (!shapesForContent.some((s) => s.id === startBindingId)) {\n\t\t\t\t\t\t// Uh oh, the arrow's bound-to shape isn't among the shapes\n\t\t\t\t\t\t// that we're getting the content for. We should try to adjust\n\t\t\t\t\t\t// the arrow so that it appears in the place it would be\n\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\tconst { x, y } = info.start.point\n\t\t\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\tif (!shapesForContent.some((s) => s.id === endBindingId)) {\n\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\tconst { x, y } = info.end.point\n\t\t\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst infoAfter = getIsArrowStraight(shape)\n\t\t\t\t\t? getStraightArrowInfo(this, shape)\n\t\t\t\t\t: getCurvedArrowInfo(this, shape)\n\n\t\t\t\tif (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {\n\t\t\t\t\tconst mpA = Vec.Med(info.start.handle, info.end.handle)\n\t\t\t\t\tconst distA = Vec.Dist(info.middle, mpA)\n\t\t\t\t\tconst distB = Vec.Dist(infoAfter.middle, mpA)\n\t\t\t\t\tif (shape.props.bend < 0) {\n\t\t\t\t\t\tshape.props.bend += distB - distA\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshape.props.bend -= distB - distA\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn shape\n\t\t\t}\n\n\t\t\treturn shape\n\t\t})\n\n\t\tconst rootShapeIds: TLShapeId[] = []\n\n\t\tshapesForContent.forEach((shape) => {\n\t\t\tif (shapesForContent.find((s) => s.id === shape.parentId) === undefined) {\n\t\t\t\t// Need to get page point and rotation of the shape because shapes in\n\t\t\t\t// groups use local position/rotation\n\n\t\t\t\tconst pageTransform = this.getShapePageTransform(shape.id)!\n\t\t\t\tconst pagePoint = pageTransform.point()\n\t\t\t\tconst pageRotation = pageTransform.rotation()\n\t\t\t\tshape.x = pagePoint.x\n\t\t\t\tshape.y = pagePoint.y\n\t\t\t\tshape.rotation = pageRotation\n\t\t\t\tshape.parentId = this.getCurrentPageId()\n\n\t\t\t\trootShapeIds.push(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tconst assetsSet = new Set<TLAssetId>()\n\n\t\tshapesForContent.forEach((shape) => {\n\t\t\tif ('assetId' in shape.props) {\n\t\t\t\tif (shape.props.assetId !== null) {\n\t\t\t\t\tassetsSet.add(shape.props.assetId)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn {\n\t\t\tshapes: shapesForContent,\n\t\t\trootShapeIds,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tassets: compact(Array.from(assetsSet).map((id) => this.getAsset(id))),\n\t\t}\n\t}\n\n\t/**\n\t * Place content into the editor.\n\t *\n\t * @param content - The content.\n\t * @param options - Options for placing the content.\n\t *\n\t * @public\n\t */\n\tputContentOntoCurrentPage(\n\t\tcontent: TLContent,\n\t\toptions: {\n\t\t\tpoint?: VecLike\n\t\t\tselect?: boolean\n\t\t\tpreservePosition?: boolean\n\t\t\tpreserveIds?: boolean\n\t\t} = {}\n\t): this {\n\t\tif (this.getInstanceState().isReadonly) return this\n\n\t\t// todo: make this able to support putting content onto any page, not just the current page\n\n\t\tif (!content.schema) {\n\t\t\tthrow Error('Could not put content:\\ncontent is missing a schema.')\n\t\t}\n\n\t\tconst { select = false, preserveIds = false, preservePosition = false } = options\n\t\tlet { point = undefined } = options\n\n\t\t// decide on a parent for the put shapes; if the parent is among the put shapes(?) then use its parent\n\n\t\tconst currentPageId = this.getCurrentPageId()\n\t\tconst { rootShapeIds } = content\n\n\t\t// We need to collect the migrated shapes and assets\n\t\tconst assets: TLAsset[] = []\n\t\tconst shapes: TLShape[] = []\n\n\t\t// Let's treat the content as a store, and then migrate that store.\n\t\tconst store: StoreSnapshot<TLRecord> = {\n\t\t\tstore: {\n\t\t\t\t...Object.fromEntries(content.assets.map((asset) => [asset.id, asset] as const)),\n\t\t\t\t...Object.fromEntries(content.shapes.map((asset) => [asset.id, asset] as const)),\n\t\t\t},\n\t\t\tschema: content.schema,\n\t\t}\n\t\tconst result = this.store.schema.migrateStoreSnapshot(store)\n\t\tif (result.type === 'error') {\n\t\t\tthrow Error('Could not put content: could not migrate content')\n\t\t}\n\t\tfor (const record of Object.values(result.value)) {\n\t\t\tswitch (record.typeName) {\n\t\t\t\tcase 'asset': {\n\t\t\t\t\tassets.push(record)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'shape': {\n\t\t\t\t\tshapes.push(record)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst idMap = new Map<any, TLShapeId>(shapes.map((shape) => [shape.id, createShapeId()]))\n\n\t\t// By default, the paste parent will be the current page.\n\t\tlet pasteParentId = this.getCurrentPageId() as TLPageId | TLShapeId\n\t\tlet lowestDepth = Infinity\n\t\tlet lowestAncestors: TLShape[] = []\n\n\t\t// Among the selected shapes, find the shape with the fewest ancestors and use its first ancestor.\n\t\tfor (const shape of this.getSelectedShapes()) {\n\t\t\tif (lowestDepth === 0) break\n\n\t\t\tconst isFrame = this.isShapeOfType<TLFrameShape>(shape, 'frame')\n\t\t\tconst ancestors = this.getShapeAncestors(shape)\n\t\t\tif (isFrame) ancestors.push(shape)\n\n\t\t\tconst depth = isFrame ? ancestors.length + 1 : ancestors.length\n\n\t\t\tif (depth < lowestDepth) {\n\t\t\t\tlowestDepth = depth\n\t\t\t\tlowestAncestors = ancestors\n\t\t\t\tpasteParentId = isFrame ? shape.id : shape.parentId\n\t\t\t} else if (depth === lowestDepth) {\n\t\t\t\tif (lowestAncestors.length !== ancestors.length) {\n\t\t\t\t\tthrow Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`)\n\t\t\t\t}\n\n\t\t\t\tif (lowestAncestors.length === 0) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tfor (let i = 0; i < lowestAncestors.length; i++) {\n\t\t\t\t\t\tif (ancestors[i] !== lowestAncestors[i]) break\n\t\t\t\t\t\tpasteParentId = ancestors[i].id\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet isDuplicating = false\n\n\t\tif (!isPageId(pasteParentId)) {\n\t\t\tconst parent = this.getShape(pasteParentId)\n\t\t\tif (parent) {\n\t\t\t\tif (!this.getViewportPageBounds().includes(this.getShapePageBounds(parent)!)) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t} else {\n\t\t\t\t\tif (rootShapeIds.length === 1) {\n\t\t\t\t\t\tconst rootShape = shapes.find((s) => s.id === rootShapeIds[0])!\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.isShapeOfType<TLFrameShape>(parent, 'frame') &&\n\t\t\t\t\t\t\tthis.isShapeOfType<TLFrameShape>(rootShape, 'frame') &&\n\t\t\t\t\t\t\trootShape.props.w === parent?.props.w &&\n\t\t\t\t\t\t\trootShape.props.h === parent?.props.h\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisDuplicating = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpasteParentId = currentPageId\n\t\t\t}\n\t\t}\n\n\t\tif (!isDuplicating) {\n\t\t\tisDuplicating = idMap.has(pasteParentId)\n\t\t}\n\n\t\tif (isDuplicating) {\n\t\t\tpasteParentId = this.getShape(pasteParentId)!.parentId\n\t\t}\n\n\t\tlet index = this.getHighestIndexForParent(pasteParentId) // todo: requires that the putting page is the current page\n\n\t\tconst rootShapes: TLShape[] = []\n\n\t\tconst newShapes: TLShape[] = shapes.map((shape): TLShape => {\n\t\t\tlet newShape: TLShape\n\n\t\t\tif (preserveIds) {\n\t\t\t\tnewShape = deepCopy(shape)\n\t\t\t\tidMap.set(shape.id, shape.id)\n\t\t\t} else {\n\t\t\t\tconst id = idMap.get(shape.id)!\n\n\t\t\t\t// Create the new shape (new except for the id)\n\t\t\t\tnewShape = deepCopy({ ...shape, id })\n\t\t\t}\n\n\t\t\tif (rootShapeIds.includes(shape.id)) {\n\t\t\t\tnewShape.parentId = currentPageId\n\t\t\t\trootShapes.push(newShape)\n\t\t\t}\n\n\t\t\t// Assign the child to its new parent.\n\n\t\t\t// If the child's parent is among the putting shapes, then assign\n\t\t\t// it to the new parent's id.\n\t\t\tif (idMap.has(newShape.parentId)) {\n\t\t\t\tnewShape.parentId = idMap.get(shape.parentId)!\n\t\t\t} else {\n\t\t\t\trootShapeIds.push(newShape.id)\n\t\t\t\t// newShape.parentId = pasteParentId\n\t\t\t\tnewShape.index = index\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\n\t\t\tif (this.isShapeOfType<TLArrowShape>(newShape, 'arrow')) {\n\t\t\t\tif (newShape.props.start.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.start.boundShapeId)\n\t\t\t\t\tnewShape.props.start = mappedId\n\t\t\t\t\t\t? { ...newShape.props.start, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t\t// convert the binding to a point at the time of copying\n\t\t\t\t\t\t\t{ type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t\tif (newShape.props.end.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.end.boundShapeId)\n\t\t\t\t\tnewShape.props.end = mappedId\n\t\t\t\t\t\t? { ...newShape.props.end, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t\t// convert the binding to a point at the time of copying\n\t\t\t\t\t\t\t{ type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newShape\n\t\t})\n\n\t\tif (newShapes.length + this.getCurrentPageShapeIds().size > MAX_SHAPES_PER_PAGE) {\n\t\t\t// There's some complexity here involving children\n\t\t\t// that might be created without their parents, so\n\t\t\t// if we're going over the limit then just don't paste.\n\t\t\talertMaxShapes(this)\n\t\t\treturn this\n\t\t}\n\n\t\t// Migrate the new shapes\n\n\t\tlet assetsToCreate: TLAsset[] = []\n\n\t\tconst assetsToUpdate: (TLImageAsset | TLVideoAsset)[] = []\n\n\t\tassetsToCreate = assets\n\t\t\t.filter((asset) => !this.store.has(asset.id))\n\t\t\t.map((asset) => {\n\t\t\t\tif (asset.type === 'image' || asset.type === 'video') {\n\t\t\t\t\tif (asset.props.src && asset.props.src?.startsWith('data:image')) {\n\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\tasset.props.src = null\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn asset\n\t\t\t})\n\n\t\tPromise.allSettled(\n\t\t\tassetsToUpdate.map(async (asset) => {\n\t\t\t\tconst file = await dataUrlToFile(\n\t\t\t\t\tasset.props.src!,\n\t\t\t\t\tasset.props.name,\n\t\t\t\t\tasset.props.mimeType ?? 'image/png'\n\t\t\t\t)\n\n\t\t\t\tconst newAsset = await this.getAssetForExternalContent({ type: 'file', file })\n\n\t\t\t\tif (!newAsset) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\treturn [asset, newAsset] as const\n\t\t\t})\n\t\t).then((assets) => {\n\t\t\tthis.updateAssets(\n\t\t\t\tcompact(\n\t\t\t\t\tassets.map((result) =>\n\t\t\t\t\t\tresult.status === 'fulfilled' && result.value\n\t\t\t\t\t\t\t? { ...result.value[1], id: result.value[0].id }\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t})\n\n\t\tthis.batch(() => {\n\t\t\t// Create any assets that need to be created\n\t\t\tif (assetsToCreate.length > 0) {\n\t\t\t\tthis.createAssets(assetsToCreate)\n\t\t\t}\n\n\t\t\t// Create the shapes with root shapes as children of the page\n\t\t\tthis.createShapes(newShapes)\n\n\t\t\tif (select) {\n\t\t\t\tthis.select(...rootShapes.map((s) => s.id))\n\t\t\t}\n\n\t\t\t// And then, if needed, reparent the root shapes to the paste parent\n\t\t\tif (pasteParentId !== currentPageId) {\n\t\t\t\tthis.reparentShapes(\n\t\t\t\t\trootShapes.map((s) => s.id),\n\t\t\t\t\tpasteParentId\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst newCreatedShapes = newShapes.map((s) => this.getShape(s.id)!)\n\t\t\tconst bounds = Box.Common(newCreatedShapes.map((s) => this.getShapePageBounds(s)!))\n\n\t\t\tif (point === undefined) {\n\t\t\t\tif (!isPageId(pasteParentId)) {\n\t\t\t\t\t// Put the shapes in the middle of the (on screen) parent\n\t\t\t\t\tconst shape = this.getShape(pasteParentId)!\n\t\t\t\t\tpoint = Mat.applyToPoint(\n\t\t\t\t\t\tthis.getShapePageTransform(shape),\n\t\t\t\t\t\tthis.getShapeGeometry(shape).bounds.center\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\t\t\t\tif (preservePosition || viewportPageBounds.includes(Box.From(bounds))) {\n\t\t\t\t\t\t// Otherwise, put shapes where they used to be\n\t\t\t\t\t\tpoint = bounds.center\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the old bounds are outside of the viewport...\n\t\t\t\t\t\t// put the shapes in the middle of the viewport\n\t\t\t\t\t\tpoint = viewportPageBounds.center\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rootShapes.length === 1) {\n\t\t\t\tconst onlyRoot = rootShapes[0] as TLFrameShape\n\t\t\t\t// If the old bounds are in the viewport...\n\t\t\t\tif (this.isShapeOfType<TLFrameShape>(onlyRoot, 'frame')) {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tthis.getShapesAtPoint(point).some(\n\t\t\t\t\t\t\t(shape) =>\n\t\t\t\t\t\t\t\tthis.isShapeOfType<TLFrameShape>(shape, 'frame') &&\n\t\t\t\t\t\t\t\tshape.props.w === onlyRoot.props.w &&\n\t\t\t\t\t\t\t\tshape.props.h === onlyRoot.props.h\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tpoint.x += bounds.w + 16\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst pageCenter = Box.Common(\n\t\t\t\tcompact(rootShapes.map(({ id }) => this.getShapePageBounds(id)))\n\t\t\t).center\n\n\t\t\tconst offset = Vec.Sub(point, pageCenter)\n\n\t\t\tthis.updateShapes(\n\t\t\t\trootShapes.map(({ id }) => {\n\t\t\t\t\tconst s = this.getShape(id)!\n\t\t\t\t\tconst localRotation = this.getShapeParentTransform(id).decompose().rotation\n\t\t\t\t\tconst localDelta = Vec.Rot(offset, -localRotation)\n\n\t\t\t\t\treturn { id: s.id, type: s.type, x: s.x + localDelta.x, y: s.y + localDelta.y }\n\t\t\t\t})\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get an exported SVG of the given shapes.\n\t *\n\t * @param ids - The shapes (or shape ids) to export.\n\t * @param opts - Options for the export.\n\t *\n\t * @returns The SVG element.\n\t *\n\t * @public\n\t */\n\tasync getSvg(shapes: TLShapeId[] | TLShape[], opts = {} as Partial<TLSvgOptions>) {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length === 0) return\n\t\tif (!window.document) throw Error('No document')\n\n\t\tconst {\n\t\t\tscale = 1,\n\t\t\tbackground = false,\n\t\t\tpadding = SVG_PADDING,\n\t\t\tpreserveAspectRatio = false,\n\t\t} = opts\n\n\t\tconst isDarkMode = opts.darkMode ?? this.user.getIsDarkMode()\n\t\tconst theme = getDefaultColorTheme({ isDarkMode })\n\n\t\t// ---Figure out which shapes we need to include\n\t\tconst shapeIdsToInclude = this.getShapeAndDescendantIds(ids)\n\t\tconst renderingShapes = this.getUnorderedRenderingShapes(false).filter(({ id }) =>\n\t\t\tshapeIdsToInclude.has(id)\n\t\t)\n\n\t\t// --- Common bounding box of all shapes\n\t\tlet bbox = null\n\t\tif (opts.bounds) {\n\t\t\tbbox = opts.bounds\n\t\t} else {\n\t\t\tfor (const { maskedPageBounds } of renderingShapes) {\n\t\t\t\tif (!maskedPageBounds) continue\n\t\t\t\tif (bbox) {\n\t\t\t\t\tbbox.union(maskedPageBounds)\n\t\t\t\t} else {\n\t\t\t\t\tbbox = maskedPageBounds.clone()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// no unmasked shapes to export\n\t\tif (!bbox) return\n\n\t\tconst singleFrameShapeId =\n\t\t\tids.length === 1 && this.isShapeOfType<TLFrameShape>(this.getShape(ids[0])!, 'frame')\n\t\t\t\t? ids[0]\n\t\t\t\t: null\n\t\tif (!singleFrameShapeId) {\n\t\t\t// Expand by an extra 32 pixels\n\t\t\tbbox.expandBy(padding)\n\t\t}\n\n\t\t// We want the svg image to be BIGGER THAN USUAL to account for image quality\n\t\tconst w = bbox.width * scale\n\t\tconst h = bbox.height * scale\n\n\t\t// --- Create the SVG\n\n\t\t// Embed our custom fonts\n\t\tconst svg = window.document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n\n\t\tif (preserveAspectRatio) {\n\t\t\tsvg.setAttribute('preserveAspectRatio', preserveAspectRatio)\n\t\t}\n\n\t\tsvg.setAttribute('direction', 'ltr')\n\t\tsvg.setAttribute('width', w + '')\n\t\tsvg.setAttribute('height', h + '')\n\t\tsvg.setAttribute('viewBox', `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`)\n\t\tsvg.setAttribute('stroke-linecap', 'round')\n\t\tsvg.setAttribute('stroke-linejoin', 'round')\n\t\t// Add current background color, or else background will be transparent\n\n\t\tif (background) {\n\t\t\tif (singleFrameShapeId) {\n\t\t\t\tsvg.style.setProperty('background', theme.solid)\n\t\t\t} else {\n\t\t\t\tsvg.style.setProperty('background-color', theme.background)\n\t\t\t}\n\t\t} else {\n\t\t\tsvg.style.setProperty('background-color', 'transparent')\n\t\t}\n\n\t\ttry {\n\t\t\tdocument.body.focus?.() // weird but necessary\n\t\t} catch (e) {\n\t\t\t// not implemented\n\t\t}\n\n\t\t// Add the defs to the svg\n\t\tconst defs = window.document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n\t\tsvg.append(defs)\n\n\t\tconst exportDefPromisesById = new Map<string, Promise<void>>()\n\t\tconst exportContext: SvgExportContext = {\n\t\t\tisDarkMode,\n\t\t\taddExportDef: (def: SvgExportDef) => {\n\t\t\t\tif (exportDefPromisesById.has(def.key)) return\n\t\t\t\tconst promise = (async () => {\n\t\t\t\t\tconst elements = await def.getElement()\n\t\t\t\t\tif (!elements) return\n\n\t\t\t\t\tconst comment = document.createComment(`def: ${def.key}`)\n\t\t\t\t\tdefs.appendChild(comment)\n\n\t\t\t\t\tfor (const element of Array.isArray(elements) ? elements : [elements]) {\n\t\t\t\t\t\tdefs.appendChild(element)\n\t\t\t\t\t}\n\t\t\t\t})()\n\t\t\t\texportDefPromisesById.set(def.key, promise)\n\t\t\t},\n\t\t}\n\n\t\tconst unorderedShapeElements = (\n\t\t\tawait Promise.all(\n\t\t\t\trenderingShapes.map(async ({ id, opacity, index, backgroundIndex }) => {\n\t\t\t\t\t// Don't render the frame if we're only exporting a single frame\n\t\t\t\t\tif (id === singleFrameShapeId) return []\n\n\t\t\t\t\tconst shape = this.getShape(id)!\n\n\t\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) return []\n\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\n\t\t\t\t\tlet shapeSvgElement = await util.toSvg?.(shape, exportContext)\n\t\t\t\t\tlet backgroundSvgElement = await util.toBackgroundSvg?.(shape, exportContext)\n\n\t\t\t\t\t// wrap the shapes in groups so we can apply properties without overwriting ones from the shape util\n\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\touterElement.appendChild(shapeSvgElement)\n\t\t\t\t\t\tshapeSvgElement = outerElement\n\t\t\t\t\t}\n\n\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\touterElement.appendChild(backgroundSvgElement)\n\t\t\t\t\t\tbackgroundSvgElement = outerElement\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!shapeSvgElement && !backgroundSvgElement) {\n\t\t\t\t\t\tconst bounds = this.getShapePageBounds(shape)!\n\t\t\t\t\t\tconst elm = window.document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\t\t\t\telm.setAttribute('width', bounds.width + '')\n\t\t\t\t\t\telm.setAttribute('height', bounds.height + '')\n\t\t\t\t\t\telm.setAttribute('fill', theme.solid)\n\t\t\t\t\t\telm.setAttribute('stroke', theme.grey.pattern)\n\t\t\t\t\t\telm.setAttribute('stroke-width', '1')\n\t\t\t\t\t\tshapeSvgElement = elm\n\t\t\t\t\t}\n\n\t\t\t\t\tlet pageTransform = this.getShapePageTransform(shape)!.toCssString()\n\t\t\t\t\tif ('scale' in shape.props) {\n\t\t\t\t\t\tif (shape.props.scale !== 1) {\n\t\t\t\t\t\t\tpageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeSvgElement?.setAttribute('transform', pageTransform)\n\t\t\t\t\tbackgroundSvgElement?.setAttribute('transform', pageTransform)\n\t\t\t\t\tshapeSvgElement?.setAttribute('opacity', opacity + '')\n\t\t\t\t\tbackgroundSvgElement?.setAttribute('opacity', opacity + '')\n\n\t\t\t\t\t// Create svg mask if shape has a frame as parent\n\t\t\t\t\tconst pageMask = this.getShapeMask(shape.id)\n\t\t\t\t\tif (pageMask) {\n\t\t\t\t\t\t// Create a clip path and add it to defs\n\t\t\t\t\t\tconst clipPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')\n\t\t\t\t\t\tdefs.appendChild(clipPathEl)\n\t\t\t\t\t\tconst id = uniqueId()\n\t\t\t\t\t\tclipPathEl.id = id\n\n\t\t\t\t\t\t// Create a polyline mask that does the clipping\n\t\t\t\t\t\tconst mask = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\t\t\t\t\t\tmask.setAttribute('d', `M${pageMask.map(({ x, y }) => `${x},${y}`).join('L')}Z`)\n\t\t\t\t\t\tclipPathEl.appendChild(mask)\n\n\t\t\t\t\t\t// Create group that uses the clip path and wraps the shape elements\n\t\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\t\touterElement.setAttribute('clip-path', `url(#${id})`)\n\t\t\t\t\t\t\touterElement.appendChild(shapeSvgElement)\n\t\t\t\t\t\t\tshapeSvgElement = outerElement\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\t\touterElement.setAttribute('clip-path', `url(#${id})`)\n\t\t\t\t\t\t\touterElement.appendChild(backgroundSvgElement)\n\t\t\t\t\t\t\tbackgroundSvgElement = outerElement\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst elements = []\n\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\telements.push({ zIndex: index, element: shapeSvgElement })\n\t\t\t\t\t}\n\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\telements.push({ zIndex: backgroundIndex, element: backgroundSvgElement })\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elements\n\t\t\t\t})\n\t\t\t)\n\t\t).flat()\n\n\t\tawait Promise.all(exportDefPromisesById.values())\n\n\t\tfor (const { element } of unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex)) {\n\t\t\tsvg.appendChild(element)\n\t\t}\n\n\t\treturn svg\n\t}\n\n\t/* --------------------- Events --------------------- */\n\n\t/**\n\t * The app's current input state.\n\t *\n\t * @public\n\t */\n\tinputs = {\n\t\t/** The most recent pointer down's position in the current page space. */\n\t\toriginPagePoint: new Vec(),\n\t\t/** The most recent pointer down's position in screen space. */\n\t\toriginScreenPoint: new Vec(),\n\t\t/** The previous pointer position in the current page space. */\n\t\tpreviousPagePoint: new Vec(),\n\t\t/** The previous pointer position in screen space. */\n\t\tpreviousScreenPoint: new Vec(),\n\t\t/** The most recent pointer position in the current page space. */\n\t\tcurrentPagePoint: new Vec(),\n\t\t/** The most recent pointer position in screen space. */\n\t\tcurrentScreenPoint: new Vec(),\n\t\t/** A set containing the currently pressed keys. */\n\t\tkeys: new Set<string>(),\n\t\t/** A set containing the currently pressed buttons. */\n\t\tbuttons: new Set<number>(),\n\t\t/** Whether the input is from a pe. */\n\t\tisPen: false,\n\t\t/** Whether the shift key is currently pressed. */\n\t\tshiftKey: false,\n\t\t/** Whether the control or command key is currently pressed. */\n\t\tctrlKey: false,\n\t\t/** Whether the alt or option key is currently pressed. */\n\t\taltKey: false,\n\t\t/** Whether the user is dragging. */\n\t\tisDragging: false,\n\t\t/** Whether the user is pointing. */\n\t\tisPointing: false,\n\t\t/** Whether the user is pinching. */\n\t\tisPinching: false,\n\t\t/** Whether the user is editing. */\n\t\tisEditing: false,\n\t\t/** Whether the user is panning. */\n\t\tisPanning: false,\n\t\t/** Velocity of mouse pointer, in pixels per millisecond */\n\t\tpointerVelocity: new Vec(),\n\t}\n\n\t/**\n\t * Update the input points from a pointer, pinch, or wheel event.\n\t *\n\t * @param info - The event info.\n\t */\n\tprivate _updateInputsFromEvent(\n\t\tinfo: TLPointerEventInfo | TLPinchEventInfo | TLWheelEventInfo\n\t): void {\n\t\tconst { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } =\n\t\t\tthis.inputs\n\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\n\t\tconst sx = info.point.x - screenBounds.x\n\t\tconst sy = info.point.y - screenBounds.y\n\t\tconst sz = info.point.z\n\n\t\tpreviousScreenPoint.setTo(currentScreenPoint)\n\t\tpreviousPagePoint.setTo(currentPagePoint)\n\n\t\t// The \"screen bounds\" is relative to the user's actual screen.\n\t\t// The \"screen point\" is relative to the \"screen bounds\";\n\t\t// it will be 0,0 when its actual screen position is equal\n\t\t// to screenBounds.point. This is confusing!\n\t\tcurrentScreenPoint.set(sx, sy)\n\t\tcurrentPagePoint.set(sx / cz - cx, sy / cz - cy, sz ?? 0.5)\n\n\t\tthis.inputs.isPen = info.type === 'pointer' && info.isPen\n\n\t\t// Reset velocity on pointer down\n\t\tif (info.name === 'pointer_down') {\n\t\t\tthis.inputs.pointerVelocity.set(0, 0)\n\t\t}\n\n\t\t// todo: We only have to do this if there are multiple users in the document\n\t\tthis.store.put([\n\t\t\t{\n\t\t\t\tid: TLPOINTER_ID,\n\t\t\t\ttypeName: 'pointer',\n\t\t\t\tx: currentPagePoint.x,\n\t\t\t\ty: currentPagePoint.y,\n\t\t\t\tlastActivityTimestamp:\n\t\t\t\t\t// If our pointer moved only because we're following some other user, then don't\n\t\t\t\t\t// update our last activity timestamp; otherwise, update it to the current timestamp.\n\t\t\t\t\tinfo.type === 'pointer' && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE\n\t\t\t\t\t\t? this.store.get(TLPOINTER_ID)?.lastActivityTimestamp ?? Date.now()\n\t\t\t\t\t\t: Date.now(),\n\t\t\t\tmeta: {},\n\t\t\t},\n\t\t])\n\t}\n\n\t/**\n\t * Dispatch a cancel event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.cancel()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcancel(): this {\n\t\tthis.dispatch({ type: 'misc', name: 'cancel' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch an interrupt event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.interrupt()\n\t * ```\n\t *\n\t * @public\n\t */\n\tinterrupt(): this {\n\t\tthis.dispatch({ type: 'misc', name: 'interrupt' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a complete event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.complete()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcomplete(): this {\n\t\tthis.dispatch({ type: 'misc', name: 'complete' })\n\t\treturn this\n\t}\n\n\t/**\n\t * A manager for recording multiple click events.\n\t *\n\t * @internal\n\t */\n\tprotected _clickManager = new ClickManager(this)\n\n\t/**\n\t * Prevent a double click event from firing the next time the user clicks\n\t *\n\t * @public\n\t */\n\tcancelDoubleClick() {\n\t\tthis._clickManager.cancelDoubleClickTimeout()\n\t}\n\n\t/**\n\t * The previous cursor. Used for restoring the cursor after pan events.\n\t *\n\t * @internal\n\t */\n\tprivate _prevCursor: TLCursorType = 'default'\n\n\t/** @internal */\n\tprivate _shiftKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setShiftKeyTimeout = () => {\n\t\tthis.inputs.shiftKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Shift',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'ShiftLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _altKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setAltKeyTimeout = () => {\n\t\tthis.inputs.altKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Alt',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'AltLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _ctrlKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setCtrlKeyTimeout = () => {\n\t\tthis.inputs.ctrlKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Ctrl',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'ControlLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _restoreToolId = 'select'\n\n\t/** @internal */\n\tprivate _pinchStart = 1\n\n\t/** @internal */\n\tprivate _didPinch = false\n\n\t/** @internal */\n\tprivate _selectedShapeIdsAtPointerDown: TLShapeId[] = []\n\n\t/** @internal */\n\tcapturedPointerId: number | null = null\n\n\t/**\n\t * Dispatch an event to the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.dispatch(myPointerEvent)\n\t * ```\n\t *\n\t * @param info - The event info.\n\t *\n\t * @public\n\t */\n\tdispatch = (info: TLEventInfo): this => {\n\t\t// prevent us from spamming similar event errors if we're crashed.\n\t\t// todo: replace with new readonly mode?\n\t\tif (this.getCrashingError()) return this\n\n\t\tconst { inputs } = this\n\t\tconst { type } = info\n\n\t\tthis.batch(() => {\n\t\t\tif (info.type === 'misc') {\n\t\t\t\t// stop panning if the interaction is cancelled or completed\n\t\t\t\tif (info.name === 'cancel' || info.name === 'complete') {\n\t\t\t\t\tthis.inputs.isDragging = false\n\n\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\tcursor: {\n\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\trotation: 0,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (info.shiftKey) {\n\t\t\t\tclearInterval(this._shiftKeyTimeout)\n\t\t\t\tthis._shiftKeyTimeout = -1\n\t\t\t\tinputs.shiftKey = true\n\t\t\t} else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {\n\t\t\t\tthis._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.altKey) {\n\t\t\t\tclearInterval(this._altKeyTimeout)\n\t\t\t\tthis._altKeyTimeout = -1\n\t\t\t\tinputs.altKey = true\n\t\t\t} else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {\n\t\t\t\tthis._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.ctrlKey) {\n\t\t\t\tclearInterval(this._ctrlKeyTimeout)\n\t\t\t\tthis._ctrlKeyTimeout = -1\n\t\t\t\tinputs.ctrlKey = true /** @internal */ /** @internal */ /** @internal */\n\t\t\t} else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {\n\t\t\t\tthis._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tconst { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs\n\n\t\t\tif (!inputs.isPointing) {\n\t\t\t\tinputs.isDragging = false\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'pinch': {\n\t\t\t\t\tif (!this.getInstanceState().canMoveCamera) return\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pinch_start': {\n\t\t\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\t\t\tif (!inputs.isEditing) {\n\t\t\t\t\t\t\t\tthis._pinchStart = this.getCamera().z\n\t\t\t\t\t\t\t\tif (!this._selectedShapeIdsAtPointerDown.length) {\n\t\t\t\t\t\t\t\t\tthis._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds()\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis._didPinch = true\n\n\t\t\t\t\t\t\t\tinputs.isPinching = true\n\n\t\t\t\t\t\t\t\tthis.interrupt()\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tpoint: { z = 1 },\n\t\t\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\t\t} = info\n\n\t\t\t\t\t\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\t\t\t\t\t\tconst { x, y } = Vec.SubXY(info.point, screenBounds.x, screenBounds.y)\n\n\t\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z))\n\n\t\t\t\t\t\t\tthis.setCamera({\n\t\t\t\t\t\t\t\tx: cx + dx / cz - x / cz + x / zoom,\n\t\t\t\t\t\t\t\ty: cy + dy / cz - y / cz + y / zoom,\n\t\t\t\t\t\t\t\tz: zoom,\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch_end': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return this\n\n\t\t\t\t\t\t\tinputs.isPinching = false\n\t\t\t\t\t\t\tconst { _selectedShapeIdsAtPointerDown } = this\n\t\t\t\t\t\t\tthis.setSelectedShapes(this._selectedShapeIdsAtPointerDown, { squashing: true })\n\t\t\t\t\t\t\tthis._selectedShapeIdsAtPointerDown = []\n\n\t\t\t\t\t\t\tif (this._didPinch) {\n\t\t\t\t\t\t\t\tthis._didPinch = false\n\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\tif (!this._didPinch) {\n\t\t\t\t\t\t\t\t\t\tthis.setSelectedShapes(_selectedShapeIdsAtPointerDown, { squashing: true })\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'wheel': {\n\t\t\t\t\tif (!this.getInstanceState().canMoveCamera) return\n\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tif (this.getIsMenuOpen()) {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (inputs.ctrlKey) {\n\t\t\t\t\t\t\t// todo: Start or update the zoom end interval\n\n\t\t\t\t\t\t\t// If the alt or ctrl keys are pressed,\n\t\t\t\t\t\t\t// zoom or pan the camera and then return.\n\n\t\t\t\t\t\t\t// Subtract the top left offset from the user's point\n\n\t\t\t\t\t\t\tconst { x, y } = this.inputs.currentScreenPoint\n\n\t\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cz + (info.delta.z ?? 0) * cz))\n\n\t\t\t\t\t\t\tthis.setCamera({\n\t\t\t\t\t\t\t\tx: cx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\ty: cy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\tz: zoom,\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t// We want to return here because none of the states in our\n\t\t\t\t\t\t\t// statechart should respond to this event (a camera zoom)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the camera here, which will dispatch a pointer move...\n\t\t\t\t\t\t// this will also update the pointer position, etc\n\t\t\t\t\t\tthis.pan(info.delta)\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\toriginPagePoint.dist(currentPagePoint) >\n\t\t\t\t\t\t\t\t(this.getInstanceState().isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) /\n\t\t\t\t\t\t\t\t\tthis.getZoomLevel()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'pointer': {\n\t\t\t\t\t// If we're pinching, return\n\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tconst { isPen } = info\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tthis.clearOpenMenus()\n\n\t\t\t\t\t\t\tthis._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds()\n\n\t\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t\t// If it's a left-mouse-click, we store the pointer id for later user\n\t\t\t\t\t\t\tif (info.button === 0) {\n\t\t\t\t\t\t\t\tthis.capturedPointerId = info.pointerId\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.add(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = true\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.getInstanceState().isPenMode) {\n\t\t\t\t\t\t\t\tif (!isPen) {\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (isPen) {\n\t\t\t\t\t\t\t\t\tthis.updateInstanceState({ isPenMode: true })\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\tthis._restoreToolId = this.getCurrentToolId()\n\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\tthis.setCurrentTool('eraser')\n\t\t\t\t\t\t\t} else if (info.button === 1) {\n\t\t\t\t\t\t\t\t// Middle mouse pan activates panning\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.getInstanceState().cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\t\t\tcursor: {\n\t\t\t\t\t\t\t\t\t\ttype: 'grabbing',\n\t\t\t\t\t\t\t\t\t\trotation: 0,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\treturn this\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toriginScreenPoint.setTo(currentScreenPoint)\n\t\t\t\t\t\t\toriginPagePoint.setTo(currentPagePoint)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\t// If the user is in pen mode, but the pointer is not a pen, stop here.\n\t\t\t\t\t\t\tif (!isPen && this.getInstanceState().isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning && this.inputs.isPointing) {\n\t\t\t\t\t\t\t\t// Handle panning\n\t\t\t\t\t\t\t\tconst { currentScreenPoint, previousScreenPoint } = this.inputs\n\t\t\t\t\t\t\t\tthis.pan(Vec.Sub(currentScreenPoint, previousScreenPoint))\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\t\toriginPagePoint.dist(currentPagePoint) >\n\t\t\t\t\t\t\t\t\t(this.getInstanceState().isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) /\n\t\t\t\t\t\t\t\t\t\tthis.getZoomLevel()\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\t// Remove the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.delete(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = false\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.getIsMenuOpen()) {\n\t\t\t\t\t\t\t\t// Suppressing pointerup here as <ContextMenu/> doesn't seem to do what we what here.\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isPen && this.getInstanceState().isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t\t// If it's the same pointer that we stored earlier...\n\t\t\t\t\t\t\t// ... then it's probably still a left-mouse-click!\n\t\t\t\t\t\t\tif (this.capturedPointerId === info.pointerId) {\n\t\t\t\t\t\t\t\tthis.capturedPointerId = null\n\t\t\t\t\t\t\t\tinfo.button = 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (inputs.isPanning) {\n\t\t\t\t\t\t\t\tif (info.button === 1) {\n\t\t\t\t\t\t\t\t\tif (!this.inputs.keys.has(' ')) {\n\t\t\t\t\t\t\t\t\t\tinputs.isPanning = false\n\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: CAMERA_SLIDE_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\t\t\t\t\tcursor: { type: this._prevCursor, rotation: 0 },\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: CAMERA_SLIDE_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\t\t\t\t\tcursor: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t\t\t\trotation: 0,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (info.button === 0) {\n\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\tfriction: CAMERA_SLIDE_FRICTION,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\t\t\t\tcursor: {\n\t\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t\t\trotation: 0,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\t\tthis.setCurrentTool(this._restoreToolId)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'keyboard': {\n\t\t\t\t\t// please, please\n\t\t\t\t\tif (info.key === 'ShiftRight') info.key = 'ShiftLeft'\n\t\t\t\t\tif (info.key === 'AltRight') info.key = 'AltLeft'\n\t\t\t\t\tif (info.code === 'ControlRight') info.code = 'ControlLeft'\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'key_down': {\n\t\t\t\t\t\t\t// Add the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.add(info.code)\n\n\t\t\t\t\t\t\t// If the space key is pressed (but meta / control isn't!) activate panning\n\t\t\t\t\t\t\tif (!info.ctrlKey && info.code === 'Space') {\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.getInstanceState().cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\t\t\tcursor: { type: this.inputs.isPointing ? 'grabbing' : 'grab', rotation: 0 },\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_up': {\n\t\t\t\t\t\t\t// Remove the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.delete(info.code)\n\n\t\t\t\t\t\t\tif (info.code === 'Space' && !this.inputs.buttons.has(1)) {\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\t\t\tthis.updateInstanceState({\n\t\t\t\t\t\t\t\t\tcursor: { type: this._prevCursor, rotation: 0 },\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_repeat': {\n\t\t\t\t\t\t\t// noop\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Correct the info name for right / middle clicks\n\t\t\tif (info.type === 'pointer') {\n\t\t\t\tif (info.button === 1) {\n\t\t\t\t\tinfo.name = 'middle_click'\n\t\t\t\t} else if (info.button === 2) {\n\t\t\t\t\tinfo.name = 'right_click'\n\t\t\t\t}\n\n\t\t\t\t// If a pointer event, send the event to the click manager.\n\t\t\t\tif (info.isPen === this.getInstanceState().isPenMode) {\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerDownEvent(info)\n\t\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerUpEvent(info)\n\t\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\tthis._clickManager.handleMove()\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Send the event to the statechart. It will be handled by all\n\t\t\t// active states, starting at the root.\n\t\t\tthis.root.handleEvent(info)\n\t\t\tthis.emit('event', info)\n\t\t})\n\n\t\treturn this\n\t}\n}\n\nfunction alertMaxShapes(editor: Editor, pageId = editor.getCurrentPageId()) {\n\tconst name = editor.getPage(pageId)!.name\n\teditor.emit('max-shapes', { name, pageId, count: MAX_SHAPES_PER_PAGE })\n}\n\nfunction applyPartialToShape<T extends TLShape>(prev: T, partial?: TLShapePartial<T>): T {\n\tif (!partial) return prev\n\tlet next = null as null | T\n\tconst entries = Object.entries(partial)\n\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\tconst [k, v] = entries[i]\n\t\tif (v === undefined) continue\n\n\t\t// Is the key a special key? We don't update those\n\t\tif (k === 'id' || k === 'type' || k === 'typeName') continue\n\n\t\t// Is the value the same as it was before?\n\t\tif (v === (prev as any)[k]) continue\n\n\t\t// There's a new value, so create the new shape if we haven't already (should we be cloning this?)\n\t\tif (!next) next = { ...prev }\n\n\t\t// for props / meta properties, we support updates with partials of this object\n\t\tif (k === 'props' || k === 'meta') {\n\t\t\tnext[k] = { ...prev[k] } as JsonObject\n\t\t\tfor (const [nextKey, nextValue] of Object.entries(v as object)) {\n\t\t\t\tif (nextValue !== undefined) {\n\t\t\t\t\t;(next[k] as JsonObject)[nextKey] = nextValue\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// base property\n\t\t;(next as any)[k] = v\n\t}\n\tif (!next) return prev\n\treturn next\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "shape", "highlightedUserIds", "distance", "ancestor", "ids", "gap", "i", "animatingShapes", "n", "group", "assets", "result", "id", "currentScreenPoint"]
}
