{
  "version": 3,
  "sources": ["../../../../../../src/lib/editor/shapes/shared/arrow/straight-arrow.ts"],
  "sourcesContent": ["import { TLArrowShape } from '@tldraw/tlschema'\nimport { Mat, MatModel } from '../../../../primitives/Mat'\nimport { Vec, VecLike } from '../../../../primitives/Vec'\nimport {\n\tintersectLineSegmentPolygon,\n\tintersectLineSegmentPolyline,\n} from '../../../../primitives/intersect'\nimport { Editor } from '../../../Editor'\nimport { TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tBoundShapeInfo,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tgetBoundShapeRelationships,\n} from './shared'\n\nexport function getStraightArrowInfo(editor: Editor, shape: TLArrowShape): TLArrowInfo {\n\tconst { start, end, arrowheadStart, arrowheadEnd } = shape.props\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape)\n\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = Vec.Med(a, b)\n\n\tif (Vec.Equals(a, b)) {\n\t\treturn {\n\t\t\tisStraight: true,\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst uAB = Vec.Sub(b, a).uni()\n\n\t// Update the arrowhead points using intersections with the bound shapes, if any.\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, start)\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, end)\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\t// Update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\tb, // <-- will be mutated\n\t\tterminalsInArrowSpace.start,\n\t\tarrowPageTransform,\n\t\tendShapeInfo\n\t)\n\n\t// Then update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\ta, // <-- will be mutated\n\t\tterminalsInArrowSpace.end,\n\t\tarrowPageTransform,\n\t\tstartShapeInfo\n\t)\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\tlet strokeOffsetA = 0\n\tlet strokeOffsetB = 0\n\tlet minLength = MIN_ARROW_LENGTH\n\n\tconst isSelfIntersection =\n\t\tstartShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape\n\n\tconst relationship =\n\t\tstartShapeInfo && endShapeInfo\n\t\t\t? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id)\n\t\t\t: 'safe'\n\n\tif (\n\t\trelationship === 'safe' &&\n\t\tstartShapeInfo &&\n\t\tendShapeInfo &&\n\t\t!isSelfIntersection &&\n\t\t!startShapeInfo.isExact &&\n\t\t!endShapeInfo.isExact\n\t) {\n\t\tif (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, then make it\n\t\t\t// a short arrow ending at the end shape intersection.\n\n\t\t\tif (startShapeInfo.isClosed) {\n\t\t\t\ta.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH)))\n\t\t\t}\n\t\t} else if (!endShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, or if neither\n\t\t\t// shape intersected, then make it a short arrow starting\n\t\t\t// at the start shape intersection.\n\t\t\tif (endShapeInfo.isClosed) {\n\t\t\t\tb.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH)))\n\t\t\t}\n\t\t}\n\t}\n\n\tconst distance = Vec.Sub(b, a)\n\t// Check for divide-by-zero before we call uni()\n\tconst u = Vec.Len(distance) ? distance.uni() : Vec.From(distance)\n\tconst didFlip = !Vec.Equals(u, uAB)\n\n\t// If the arrow is bound non-exact to a start shape and the\n\t// start point has an arrowhead, then offset the start point\n\tif (!isSelfIntersection) {\n\t\tif (\n\t\t\trelationship !== 'start-contains-end' &&\n\t\t\tstartShapeInfo &&\n\t\t\tarrowheadStart !== 'none' &&\n\t\t\t!startShapeInfo.isExact\n\t\t) {\n\t\t\tstrokeOffsetA =\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t: 0)\n\t\t\toffsetA = BOUND_ARROW_OFFSET + strokeOffsetA\n\t\t\tminLength += strokeOffsetA\n\t\t}\n\n\t\t// If the arrow is bound non-exact to an end shape and the\n\t\t// end point has an arrowhead offset the end point\n\t\tif (\n\t\t\trelationship !== 'end-contains-start' &&\n\t\t\tendShapeInfo &&\n\t\t\tarrowheadEnd !== 'none' &&\n\t\t\t!endShapeInfo.isExact\n\t\t) {\n\t\t\tstrokeOffsetB =\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\toffsetB = BOUND_ARROW_OFFSET + strokeOffsetB\n\t\t\tminLength += strokeOffsetB\n\t\t}\n\t}\n\n\t// Adjust offsets if the length of the arrow is too small\n\n\tconst tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tconst tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\tconst distAB = Vec.Dist(tA, tB)\n\n\tif (distAB < minLength) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\t// both bound + offset\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\t// start bound + offset\n\t\t\toffsetA *= -1\n\t\t} else if (offsetB !== 0) {\n\t\t\t// end bound + offset\n\t\t\toffsetB *= -1\n\t\t} else {\n\t\t\t// noop, its just a really short arrow\n\t\t}\n\t}\n\n\ta.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tb.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\n\t// If the handles flipped their order, then set the center handle\n\t// to the midpoint of the terminals (rather than the midpoint of the\n\t// arrow body); otherwise, it may not be \"between\" the other terminals.\n\tif (didFlip) {\n\t\tif (startShapeInfo && endShapeInfo) {\n\t\t\t// If we have two bound shapes...then make the arrow a short arrow from\n\t\t\t// the start point towards where the end point should be.\n\t\t\tb.setTo(Vec.Add(a, u.clone().mul(-MIN_ARROW_LENGTH)))\n\t\t}\n\t\tc.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end))\n\t} else {\n\t\tc.setTo(Vec.Med(a, b))\n\t}\n\n\tconst length = Vec.Dist(a, b)\n\n\treturn {\n\t\tisStraight: true,\n\t\tstart: {\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tpoint: a,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tpoint: b,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\tisValid: length > 0,\n\t\tlength,\n\t}\n}\n\n/** Get an intersection point from A -> B with bound shape (target) from shape (arrow). */\nfunction updateArrowheadPointWithBoundShape(\n\tpoint: Vec,\n\topposite: Vec,\n\tarrowPageTransform: MatModel,\n\ttargetShapeInfo?: BoundShapeInfo\n) {\n\tif (targetShapeInfo === undefined) {\n\t\t// No bound shape? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tif (targetShapeInfo.isExact) {\n\t\t// Exact type binding? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\t// From and To in page space\n\tconst pageFrom = Mat.applyToPoint(arrowPageTransform, opposite)\n\tconst pageTo = Mat.applyToPoint(arrowPageTransform, point)\n\n\t// From and To in local space of the target shape\n\tconst targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom)\n\tconst targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo)\n\n\tconst isClosed = targetShapeInfo.isClosed\n\tconst fn = isClosed ? intersectLineSegmentPolygon : intersectLineSegmentPolyline\n\n\tconst intersection = fn(targetFrom, targetTo, targetShapeInfo.outline)\n\n\tlet targetInt: VecLike | undefined\n\n\tif (intersection !== null) {\n\t\ttargetInt =\n\t\t\tintersection.sort((p1, p2) => Vec.Dist(p1, targetFrom) - Vec.Dist(p2, targetFrom))[0] ??\n\t\t\t(isClosed ? undefined : targetTo)\n\t}\n\n\tif (targetInt === undefined) {\n\t\t// No intersection? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tconst pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt)\n\tconst arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt)\n\n\tpoint.setTo(arrowInt)\n\n\ttargetShapeInfo.didIntersect = true\n}\n"],
  "mappings": "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",
  "names": []
}
