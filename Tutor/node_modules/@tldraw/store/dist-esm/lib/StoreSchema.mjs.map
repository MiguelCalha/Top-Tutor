{
  "version": 3,
  "sources": ["../../src/lib/StoreSchema.ts"],
  "sourcesContent": ["import { getOwnProperty, objectMapValues } from '@tldraw/utils'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { RecordType } from './RecordType'\nimport { SerializedStore, Store, StoreSnapshot } from './Store'\nimport {\n\tMigrationFailureReason,\n\tMigrationResult,\n\tMigrations,\n\tmigrate,\n\tmigrateRecord,\n} from './migrate'\n\n/** @public */\nexport interface SerializedSchema {\n\t/** Schema version is the version for this type you're looking at right now */\n\tschemaVersion: number\n\t/**\n\t * Store version is the version for the structure of the store. e.g. higher level structure like\n\t * removing or renaming a record type.\n\t */\n\tstoreVersion: number\n\t/** Record versions are the versions for each record type. e.g. adding a new field to a record */\n\trecordVersions: Record<\n\t\tstring,\n\t\t| {\n\t\t\t\tversion: number\n\t\t  }\n\t\t| {\n\t\t\t\t// subtypes are used for migrating shape and asset props\n\t\t\t\tversion: number\n\t\t\t\tsubTypeVersions: Record<string, number>\n\t\t\t\tsubTypeKey: string\n\t\t  }\n\t>\n}\n\n/** @public */\nexport type StoreSchemaOptions<R extends UnknownRecord, P> = {\n\t/** @public */\n\tsnapshotMigrations?: Migrations\n\t/** @public */\n\tonValidationFailure?: (data: {\n\t\terror: unknown\n\t\tstore: Store<R>\n\t\trecord: R\n\t\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\t\trecordBefore: R | null\n\t}) => R\n\t/** @internal */\n\tcreateIntegrityChecker?: (store: Store<R, P>) => void\n}\n\n/** @public */\nexport class StoreSchema<R extends UnknownRecord, P = unknown> {\n\tstatic create<R extends UnknownRecord, P = unknown>(\n\t\t// HACK: making this param work with RecordType is an enormous pain\n\t\t// let's just settle for making sure each typeName has a corresponding RecordType\n\t\t// and accept that this function won't be able to infer the record type from it's arguments\n\t\ttypes: { [TypeName in R['typeName']]: { createId: any } },\n\t\toptions?: StoreSchemaOptions<R, P>\n\t): StoreSchema<R, P> {\n\t\treturn new StoreSchema<R, P>(types as any, options ?? {})\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly types: {\n\t\t\t[Record in R as Record['typeName']]: RecordType<R, any>\n\t\t},\n\t\tprivate readonly options: StoreSchemaOptions<R, P>\n\t) {}\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget currentStoreVersion(): number {\n\t\treturn this.options.snapshotMigrations?.currentVersion ?? 0\n\t}\n\n\tvalidateRecord(\n\t\tstore: Store<R>,\n\t\trecord: R,\n\t\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests',\n\t\trecordBefore: R | null\n\t): R {\n\t\ttry {\n\t\t\tconst recordType = getOwnProperty(this.types, record.typeName)\n\t\t\tif (!recordType) {\n\t\t\t\tthrow new Error(`Missing definition for record type ${record.typeName}`)\n\t\t\t}\n\t\t\treturn recordType.validate(record, recordBefore ?? undefined)\n\t\t} catch (error: unknown) {\n\t\t\tif (this.options.onValidationFailure) {\n\t\t\t\treturn this.options.onValidationFailure({\n\t\t\t\t\tstore,\n\t\t\t\t\trecord,\n\t\t\t\t\tphase,\n\t\t\t\t\trecordBefore,\n\t\t\t\t\terror,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t}\n\t}\n\n\tmigratePersistedRecord(\n\t\trecord: R,\n\t\tpersistedSchema: SerializedSchema,\n\t\tdirection: 'up' | 'down' = 'up'\n\t): MigrationResult<R> {\n\t\tconst ourType = getOwnProperty(this.types, record.typeName)\n\t\tconst persistedType = persistedSchema.recordVersions[record.typeName]\n\t\tif (!persistedType || !ourType) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.UnknownType }\n\t\t}\n\t\tconst ourVersion = ourType.migrations.currentVersion\n\t\tconst persistedVersion = persistedType.version\n\t\tif (ourVersion !== persistedVersion) {\n\t\t\tconst result =\n\t\t\t\tdirection === 'up'\n\t\t\t\t\t? migrateRecord<R>({\n\t\t\t\t\t\t\trecord,\n\t\t\t\t\t\t\tmigrations: ourType.migrations,\n\t\t\t\t\t\t\tfromVersion: persistedVersion,\n\t\t\t\t\t\t\ttoVersion: ourVersion,\n\t\t\t\t\t\t})\n\t\t\t\t\t: migrateRecord<R>({\n\t\t\t\t\t\t\trecord,\n\t\t\t\t\t\t\tmigrations: ourType.migrations,\n\t\t\t\t\t\t\tfromVersion: ourVersion,\n\t\t\t\t\t\t\ttoVersion: persistedVersion,\n\t\t\t\t\t\t})\n\t\t\tif (result.type === 'error') {\n\t\t\t\treturn result\n\t\t\t}\n\t\t\trecord = result.value\n\t\t}\n\n\t\tif (!ourType.migrations.subTypeKey) {\n\t\t\treturn { type: 'success', value: record }\n\t\t}\n\n\t\t// we've handled the main version migration, now we need to handle subtypes\n\t\t// subtypes are used by shape and asset types to migrate the props shape, which is configurable\n\t\t// by library consumers.\n\n\t\tconst ourSubTypeMigrations =\n\t\t\tourType.migrations.subTypeMigrations?.[\n\t\t\t\trecord[ourType.migrations.subTypeKey as keyof R] as string\n\t\t\t]\n\n\t\tconst persistedSubTypeVersion =\n\t\t\t'subTypeVersions' in persistedType\n\t\t\t\t? persistedType.subTypeVersions[record[ourType.migrations.subTypeKey as keyof R] as string]\n\t\t\t\t: undefined\n\n\t\t// if ourSubTypeMigrations is undefined then we don't have access to the migrations for this subtype\n\t\t// that is almost certainly because we are running on the server and this type was supplied by a 3rd party.\n\t\t// It could also be that we are running in a client that is outdated. Either way, we can't migrate this record\n\t\t// and we need to let the consumer know so they can handle it.\n\t\tif (ourSubTypeMigrations === undefined) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.UnrecognizedSubtype }\n\t\t}\n\n\t\t// if the persistedSubTypeVersion is undefined then the record was either created after the schema\n\t\t// was persisted, or it was created in a different place to where the schema was persisted.\n\t\t// either way we don't know what to do with it safely, so let's return failure.\n\t\tif (persistedSubTypeVersion === undefined) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.IncompatibleSubtype }\n\t\t}\n\n\t\tconst result =\n\t\t\tdirection === 'up'\n\t\t\t\t? migrateRecord<R>({\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tmigrations: ourSubTypeMigrations,\n\t\t\t\t\t\tfromVersion: persistedSubTypeVersion,\n\t\t\t\t\t\ttoVersion: ourSubTypeMigrations.currentVersion,\n\t\t\t\t\t})\n\t\t\t\t: migrateRecord<R>({\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tmigrations: ourSubTypeMigrations,\n\t\t\t\t\t\tfromVersion: ourSubTypeMigrations.currentVersion,\n\t\t\t\t\t\ttoVersion: persistedSubTypeVersion,\n\t\t\t\t\t})\n\n\t\tif (result.type === 'error') {\n\t\t\treturn result\n\t\t}\n\n\t\treturn { type: 'success', value: result.value }\n\t}\n\n\tmigrateStoreSnapshot(snapshot: StoreSnapshot<R>): MigrationResult<SerializedStore<R>> {\n\t\tlet { store } = snapshot\n\n\t\tconst migrations = this.options.snapshotMigrations\n\t\tif (!migrations) {\n\t\t\treturn { type: 'success', value: store }\n\t\t}\n\t\t// apply store migrations first\n\t\tconst ourStoreVersion = migrations.currentVersion\n\t\tconst persistedStoreVersion = snapshot.schema.storeVersion ?? 0\n\n\t\tif (ourStoreVersion < persistedStoreVersion) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.TargetVersionTooOld }\n\t\t}\n\n\t\tif (ourStoreVersion > persistedStoreVersion) {\n\t\t\tconst result = migrate<SerializedStore<R>>({\n\t\t\t\tvalue: store,\n\t\t\t\tmigrations,\n\t\t\t\tfromVersion: persistedStoreVersion,\n\t\t\t\ttoVersion: ourStoreVersion,\n\t\t\t})\n\n\t\t\tif (result.type === 'error') {\n\t\t\t\treturn result\n\t\t\t}\n\t\t\tstore = result.value\n\t\t}\n\n\t\tconst updated: R[] = []\n\t\tfor (const r of objectMapValues(store)) {\n\t\t\tconst result = this.migratePersistedRecord(r, snapshot.schema)\n\t\t\tif (result.type === 'error') {\n\t\t\t\treturn result\n\t\t\t} else if (result.value && result.value !== r) {\n\t\t\t\tupdated.push(result.value)\n\t\t\t}\n\t\t}\n\t\tif (updated.length) {\n\t\t\tstore = { ...store }\n\t\t\tfor (const r of updated) {\n\t\t\t\tstore[r.id as IdOf<R>] = r\n\t\t\t}\n\t\t}\n\t\treturn { type: 'success', value: store }\n\t}\n\n\t/** @internal */\n\tcreateIntegrityChecker(store: Store<R, P>): (() => void) | undefined {\n\t\treturn this.options.createIntegrityChecker?.(store) ?? undefined\n\t}\n\n\tserialize(): SerializedSchema {\n\t\treturn {\n\t\t\tschemaVersion: 1,\n\t\t\tstoreVersion: this.options.snapshotMigrations?.currentVersion ?? 0,\n\t\t\trecordVersions: Object.fromEntries(\n\t\t\t\tobjectMapValues(this.types).map((type) => [\n\t\t\t\t\ttype.typeName,\n\t\t\t\t\ttype.migrations.subTypeKey && type.migrations.subTypeMigrations\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tversion: type.migrations.currentVersion,\n\t\t\t\t\t\t\t\tsubTypeKey: type.migrations.subTypeKey,\n\t\t\t\t\t\t\t\tsubTypeVersions: type.migrations.subTypeMigrations\n\t\t\t\t\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\t\t\t\t\tObject.entries(type.migrations.subTypeMigrations).map(([k, v]) => [\n\t\t\t\t\t\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\t\t\t\t\t\tv.currentVersion,\n\t\t\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tversion: type.migrations.currentVersion,\n\t\t\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t),\n\t\t}\n\t}\n\n\tserializeEarliestVersion(): SerializedSchema {\n\t\treturn {\n\t\t\tschemaVersion: 1,\n\t\t\tstoreVersion: this.options.snapshotMigrations?.firstVersion ?? 0,\n\t\t\trecordVersions: Object.fromEntries(\n\t\t\t\tobjectMapValues(this.types).map((type) => [\n\t\t\t\t\ttype.typeName,\n\t\t\t\t\ttype.migrations.subTypeKey && type.migrations.subTypeMigrations\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tversion: type.migrations.firstVersion,\n\t\t\t\t\t\t\t\tsubTypeKey: type.migrations.subTypeKey,\n\t\t\t\t\t\t\t\tsubTypeVersions: type.migrations.subTypeMigrations\n\t\t\t\t\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\t\t\t\t\tObject.entries(type.migrations.subTypeMigrations).map(([k, v]) => [\n\t\t\t\t\t\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\t\t\t\t\t\tv.firstVersion,\n\t\t\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tversion: type.migrations.firstVersion,\n\t\t\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t),\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
